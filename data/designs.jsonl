{"hash": "e8caaf0c11a7692198b9e17448386a889238f7144d2e786e516c6412c8cac646", "equivalence_group": "e8caaf0c11a7692198b9e17448386a889238f7144d2e786e516c6412c8cac646", "content": "\n\nmodule JC_counter\n(\n  input clk,\n  input rst_n,\n  output reg [63:0] Q\n);\n\n\n  always @(posedge clk or negedge rst_n) begin\n    if(!rst_n) Q <= 'd0; \n    else if(!Q[0]) Q <= { 1'b1, Q[63:1] }; \n    else Q <= { 1'b0, Q[63:1] };\n  end\n\n\nendmodule\n\n"}
{"hash": "542ea6552493d69fb31818cc2796aa896eb82b8b801581a2e2e96e85c4e21a7b", "equivalence_group": "542ea6552493d69fb31818cc2796aa896eb82b8b801581a2e2e96e85c4e21a7b", "content": "\n\nmodule LFSR\n(\n  out,\n  clk,\n  rst\n);\n\n  input clk;\n  input rst;\n  output [3:0] out;\n  reg [3:0] out;\n  wire feedback;\n  assign feedback = ~(out[3] ^ out[2]);\n\n  always @(posedge clk or posedge rst) begin\n    if(rst) out = 4'b0; \n    else out = { out[2:0], feedback };\n  end\n\n\nendmodule\n\n"}
{"hash": "f28c7bfe03f711259ded0284c60afb91d687773de7e2d6656ed417c3823e94f1", "equivalence_group": "f28c7bfe03f711259ded0284c60afb91d687773de7e2d6656ed417c3823e94f1", "content": "\n\nmodule LIFObuffer\n(\n  input [3:0] dataIn,\n  input RW,\n  input EN,\n  input Rst,\n  input Clk,\n  output reg EMPTY,\n  output reg FULL,\n  output reg [3:0] dataOut\n);\n\n  reg [3:0] stack_mem [0:3];\n  reg [2:0] SP;\n  integer i;\n\n  always @(posedge Clk) begin\n    if(EN == 0) begin\n    end else begin\n      if(Rst == 1) begin\n        SP = 3'd4;\n        EMPTY = SP[2];\n        dataOut = 4'h0;\n        for(i=0; i<4; i=i+1) begin\n          stack_mem[i] = 0;\n        end\n      end else if(Rst == 0) begin\n        FULL = (SP)? 0 : 1;\n        EMPTY = SP[2];\n        dataOut = 4'hx;\n        if((FULL == 1'b0) && (RW == 1'b0)) begin\n          SP = SP - 1'b1;\n          FULL = (SP)? 0 : 1;\n          EMPTY = SP[2];\n          stack_mem[SP] = dataIn;\n        end else if((EMPTY == 1'b0) && (RW == 1'b1)) begin\n          dataOut = stack_mem[SP];\n          stack_mem[SP] = 0;\n          SP = SP + 1;\n          FULL = (SP)? 0 : 1;\n          EMPTY = SP[2];\n        end else begin\n        end\n      end else begin\n      end\n    end\n  end\n\n\nendmodule\n\n"}
{"hash": "b2ea94d15359cbb85a04f9b31ab517de7f48c777ab76bb8bf89613892a175764", "equivalence_group": "b2ea94d15359cbb85a04f9b31ab517de7f48c777ab76bb8bf89613892a175764", "content": "\n\nmodule verified_RAM\n(\n  input clk,\n  input rst_n,\n  input write_en,\n  input [7:0] write_addr,\n  input [5:0] write_data,\n  input read_en,\n  input [7:0] read_addr,\n  output reg [5:0] read_data\n);\n\n  reg [7:0] RAM [11:0];\n  integer i;\n\n  always @(posedge clk or negedge rst_n) begin\n    if(!rst_n) begin\n      for(i=0; i<8; i=i+1) begin\n        RAM[i] <= 'd0;\n      end\n    end else if(write_en) RAM[write_addr] <= write_data; \n  end\n\n\n  always @(posedge clk or negedge rst_n) begin\n    if(!rst_n) read_data <= 'd0; \n    else if(read_en) read_data <= RAM[read_addr]; \n    else read_data <= 'd0;\n  end\n\n\nendmodule\n\n"}
{"hash": "d4b68ad09d71e754b062527c961a3ee5194220a960c03550df9b752912eda418", "equivalence_group": "d4b68ad09d71e754b062527c961a3ee5194220a960c03550df9b752912eda418", "content": "\n\nmodule ROM\n(\n  input wire [7:0] addr,\n  output reg [15:0] dout\n);\n\n  reg [15:0] mem [0:255];\n\n  initial begin\n    mem[0] = 16'hA0A0;\n    mem[1] = 16'hB1B1;\n    mem[2] = 16'hC2C2;\n    mem[3] = 16'hD3D3;\n  end\n\n\n  always @(*) begin\n    dout = mem[addr];\n  end\n\n\nendmodule\n\n"}
{"hash": "e2ab4b3e61f197faae3140b32affd031974e27056b1308e99057d8cbc541d6b9", "equivalence_group": "e2ab4b3e61f197faae3140b32affd031974e27056b1308e99057d8cbc541d6b9", "content": "\n\nmodule verified_accu\n(\n  input clk,\n  input rst_n,\n  input [7:0] data_in,\n  input valid_in,\n  output reg valid_out,\n  output reg [9:0] data_out\n);\n\n  reg [1:0] count;\n  wire add_cnt;\n  wire ready_add;\n  wire end_cnt;\n  reg [9:0] data_out_reg;\n  assign add_cnt = ready_add;\n  assign end_cnt = ready_add && (count == 'd3);\n\n  always @(posedge clk or negedge rst_n) begin\n    if(!rst_n) begin\n      count <= 0;\n    end else if(end_cnt) begin\n      count <= 0;\n    end else if(add_cnt) begin\n      count <= count + 1;\n    end \n  end\n\n\n  always @(posedge clk or negedge rst_n) begin\n    if(!rst_n) begin\n      data_out_reg <= 0;\n    end else if(add_cnt && (count == 0)) begin\n      data_out_reg <= data_in;\n    end else if(add_cnt) begin\n      data_out_reg <= data_out_reg + data_in;\n    end \n  end\n\n\n  always @(posedge clk or negedge rst_n) begin\n    if(!rst_n) begin\n      data_out <= 0;\n    end else if(add_cnt && (count == 0)) begin\n      data_out <= data_in;\n    end else if(add_cnt) begin\n      data_out <= data_out + data_in;\n    end \n  end\n\n  assign ready_add = !valid_out | valid_in;\n\n  always @(posedge clk or negedge rst_n) begin\n    if(!rst_n) begin\n      valid_out <= 0;\n    end else if(end_cnt) begin\n      valid_out <= 1;\n    end else begin\n      valid_out <= 0;\n    end\n  end\n\n\nendmodule\n\n"}
{"hash": "2b10d1482de9bddc941d2829446e421591c8df16b7ffd11a6036559eef1a11f5", "equivalence_group": "2b10d1482de9bddc941d2829446e421591c8df16b7ffd11a6036559eef1a11f5", "content": "\n\nmodule verified_adder_16bit\n(\n  input wire [15:0] a,\n  input wire [15:0] b,\n  input wire Cin,\n  output wire [15:0] y,\n  output wire Co\n);\n\n  wire Co_temp;\n\n  add8\n  add8_inst1\n  (\n    .a(a[15:8]),\n    .b(b[15:8]),\n    .Cin(Co_temp),\n    .y(y[15:8]),\n    .Co(Co)\n  );\n\n\n  add8\n  add8_inst2\n  (\n    .a(a[7:0]),\n    .b(b[7:0]),\n    .Cin(Cin),\n    .y(y[7:0]),\n    .Co(Co_temp)\n  );\n\n\nendmodule\n\n\n\nmodule add8\n(\n  input wire [7:0] a,\n  input wire [7:0] b,\n  input wire Cin,\n  output wire [7:0] y,\n  output wire Co\n);\n\n  wire Co_temp;\n\n  add4\n  add4_inst1\n  (\n    .a(a[7:4]),\n    .b(b[7:4]),\n    .Cin(Co_temp),\n    .y(y[7:4]),\n    .Co(Co)\n  );\n\n\n  add4\n  add4_inst2\n  (\n    .a(a[3:0]),\n    .b(b[3:0]),\n    .Cin(Cin),\n    .y(y[3:0]),\n    .Co(Co_temp)\n  );\n\n\nendmodule\n\n\n\nmodule add4\n(\n  input wire [3:0] a,\n  input wire [3:0] b,\n  input wire Cin,\n  output wire [3:0] y,\n  output wire Co\n);\n\n  wire Co_temp;\n\n  add2\n  add2_inst1\n  (\n    .a(a[3:2]),\n    .b(b[3:2]),\n    .Cin(Co_temp),\n    .y(y[3:2]),\n    .Co(Co)\n  );\n\n\n  add2\n  add2_inst2\n  (\n    .a(a[1:0]),\n    .b(b[1:0]),\n    .Cin(Cin),\n    .y(y[1:0]),\n    .Co(Co_temp)\n  );\n\n\nendmodule\n\n\n\nmodule add2\n(\n  input wire [1:0] a,\n  input wire [1:0] b,\n  input wire Cin,\n  output wire [1:0] y,\n  output wire Co\n);\n\n  wire Co_temp;\n\n  add1\n  add1_inst1\n  (\n    .a(a[1]),\n    .b(b[1]),\n    .Cin(Co_temp),\n    .y(y[1]),\n    .Co(Co)\n  );\n\n\n  add1\n  add1_inst2\n  (\n    .a(a[0]),\n    .b(b[0]),\n    .Cin(Cin),\n    .y(y[0]),\n    .Co(Co_temp)\n  );\n\n\nendmodule\n\n\n\nmodule add1\n(\n  input wire a,\n  input wire b,\n  input wire Cin,\n  output wire y,\n  output wire Co\n);\n\n  assign y = ~a & ~b & Cin | ~a & b & ~Cin | a & ~b & ~Cin | a & b & Cin;\n  assign Co = ~a & b & Cin | a & ~b & Cin | a & b & ~Cin | a & b & Cin;\n\nendmodule\n\n"}
{"hash": "5d92a345bc8a0008b365c883094fdf17f393fad345ed35b5804e6d4ead1137b6", "equivalence_group": "5d92a345bc8a0008b365c883094fdf17f393fad345ed35b5804e6d4ead1137b6", "content": "\n\nmodule verified_adder_8bit\n(\n  input [7:0] a,\n  input [7:0] b,\n  input cin,\n  output [7:0] sum,\n  output cout\n);\n\n  wire [8:0] c;\n\n  full_adder\n  FA0\n  (\n    .a(a[0]),\n    .b(b[0]),\n    .cin(cin),\n    .sum(sum[0]),\n    .cout(c[0])\n  );\n\n\n  full_adder\n  FA1\n  (\n    .a(a[1]),\n    .b(b[1]),\n    .cin(c[0]),\n    .sum(sum[1]),\n    .cout(c[1])\n  );\n\n\n  full_adder\n  FA2\n  (\n    .a(a[2]),\n    .b(b[2]),\n    .cin(c[1]),\n    .sum(sum[2]),\n    .cout(c[2])\n  );\n\n\n  full_adder\n  FA3\n  (\n    .a(a[3]),\n    .b(b[3]),\n    .cin(c[2]),\n    .sum(sum[3]),\n    .cout(c[3])\n  );\n\n\n  full_adder\n  FA4\n  (\n    .a(a[4]),\n    .b(b[4]),\n    .cin(c[3]),\n    .sum(sum[4]),\n    .cout(c[4])\n  );\n\n\n  full_adder\n  FA5\n  (\n    .a(a[5]),\n    .b(b[5]),\n    .cin(c[4]),\n    .sum(sum[5]),\n    .cout(c[5])\n  );\n\n\n  full_adder\n  FA6\n  (\n    .a(a[6]),\n    .b(b[6]),\n    .cin(c[5]),\n    .sum(sum[6]),\n    .cout(c[6])\n  );\n\n\n  full_adder\n  FA7\n  (\n    .a(a[7]),\n    .b(b[7]),\n    .cin(c[6]),\n    .sum(sum[7]),\n    .cout(c[7])\n  );\n\n  assign cout = c[7];\n\nendmodule\n\n\n\nmodule full_adder\n(\n  input a,\n  input b,\n  input cin,\n  output sum,\n  output cout\n);\n\n  assign { cout, sum } = a + b + cin;\n\nendmodule\n\n"}
{"hash": "1a51a4a6479280138287b25dec5fd7fe2d592e77f0b8b035ef1f4fb80c28aa78", "equivalence_group": "1a51a4a6479280138287b25dec5fd7fe2d592e77f0b8b035ef1f4fb80c28aa78", "content": "\n\nmodule adder_bcd\n(\n  input [3:0] A,\n  input [3:0] B,\n  input Cin,\n  output [3:0] Sum,\n  output Cout\n);\n\n  wire [4:0] temp_sum;\n  wire [3:0] corrected_sum;\n  wire carry_out;\n  assign temp_sum = A + B + Cin;\n  assign carry_out = (temp_sum > 9)? 1 : 0;\n  assign corrected_sum = (temp_sum > 9)? temp_sum + 4'b0110 : temp_sum;\n  assign Sum = corrected_sum[3:0];\n  assign Cout = carry_out;\n\nendmodule\n\n"}
{"hash": "08e1a07a3727a595fe4c5f47561ad19e468ed2573d20d06f1e110772e8e57067", "equivalence_group": "08e1a07a3727a595fe4c5f47561ad19e468ed2573d20d06f1e110772e8e57067", "content": "\n\nmodule verified_alu\n(\n  input [31:0] a,\n  input [31:0] b,\n  input [5:0] aluc,\n  output [31:0] r,\n  output zero,\n  output carry,\n  output negative,\n  output overflow,\n  output flag\n);\n\n  parameter ADD = 6'b100000;\n  parameter ADDU = 6'b100001;\n  parameter SUB = 6'b100010;\n  parameter SUBU = 6'b100011;\n  parameter AND = 6'b100100;\n  parameter OR = 6'b100101;\n  parameter XOR = 6'b100110;\n  parameter NOR = 6'b100111;\n  parameter SLT = 6'b101010;\n  parameter SLTU = 6'b101011;\n  parameter SLL = 6'b000000;\n  parameter SRL = 6'b000010;\n  parameter SRA = 6'b000011;\n  parameter SLLV = 6'b000100;\n  parameter SRLV = 6'b000110;\n  parameter SRAV = 6'b000111;\n  parameter JR = 6'b001000;\n  parameter LUI = 6'b001111;\n  wire signed [31:0] a_signed;\n  wire signed [31:0] b_signed;\n  reg [32:0] res;\n  assign a_signed = a;\n  assign b_signed = b;\n  assign r = res[31:0];\n  assign flag = ((aluc == SLT) || (aluc == SLTU))? (aluc == SLT)? a_signed < b_signed : a < b : 1'bz;\n  assign zero = (res == 32'b0)? 1'b1 : 1'b0;\n\n  always @(a or b or aluc) begin\n    case(aluc)\n      ADD: begin\n        res <= a_signed + b_signed;\n      end\n      ADDU: begin\n        res <= a + b;\n      end\n      SUB: begin\n        res <= a_signed - b_signed;\n      end\n      SUBU: begin\n        res <= a - b;\n      end\n      AND: begin\n        res <= a & b;\n      end\n      OR: begin\n        res <= a | b;\n      end\n      XOR: begin\n        res <= a ^ b;\n      end\n      NOR: begin\n        res <= ~(a | b);\n      end\n      SLT: begin\n        res <= (a_signed < b_signed)? 1 : 0;\n      end\n      SLTU: begin\n        res <= (a < b)? 1 : 0;\n      end\n      SLL: begin\n        res <= b << a;\n      end\n      SRL: begin\n        res <= b >> a;\n      end\n      SRA: begin\n        res <= b_signed >>> a_signed;\n      end\n      SLLV: begin\n        res <= b << a[4:0];\n      end\n      SRLV: begin\n        res <= b >> a[4:0];\n      end\n      SRAV: begin\n        res <= b_signed >>> a_signed[4:0];\n      end\n      LUI: begin\n        res <= { a[15:0], 16'h0000 };\n      end\n      default: begin\n        res <= 32'bz;\n      end\n    endcase\n  end\n\n\nendmodule\n\n"}
{"hash": "dbc14a46633219b54abce9309c26f9ab8e141021e30cd085502e1f3a689f8440", "equivalence_group": "dbc14a46633219b54abce9309c26f9ab8e141021e30cd085502e1f3a689f8440", "content": "\n\nmodule dual_port_RAM #\n(\n  parameter DEPTH = 16,\n  parameter WIDTH = 8\n)\n(\n  input wclk,\n  input wenc,\n  input [$clog2(DEPTH)-1:0] waddr,\n  input [WIDTH-1:0] wdata,\n  input rclk,\n  input renc,\n  input [$clog2(DEPTH)-1:0] raddr,\n  output reg [WIDTH-1:0] rdata\n);\n\n  reg [WIDTH-1:0] RAM_MEM [0:DEPTH-1];\n\n  always @(posedge wclk) begin\n    if(wenc) RAM_MEM[waddr] <= wdata; \n  end\n\n\n  always @(posedge rclk) begin\n    if(renc) rdata <= RAM_MEM[raddr]; \n  end\n\n\nendmodule\n\n\n\nmodule verified_asyn_fifo #\n(\n  parameter WIDTH = 8,\n  parameter DEPTH = 16\n)\n(\n  input wclk,\n  input rclk,\n  input wrstn,\n  input rrstn,\n  input winc,\n  input rinc,\n  input [WIDTH-1:0] wdata,\n  output wire wfull,\n  output wire rempty,\n  output wire [WIDTH-1:0] rdata\n);\n\n  parameter ADDR_WIDTH = $clog2(DEPTH);\n  reg [ADDR_WIDTH:0] waddr_bin;\n  reg [ADDR_WIDTH:0] raddr_bin;\n\n  always @(posedge wclk or negedge wrstn) begin\n    if(~wrstn) begin\n      waddr_bin <= 'd0;\n    end else if(!wfull && winc) begin\n      waddr_bin <= waddr_bin + 1'd1;\n    end \n  end\n\n\n  always @(posedge rclk or negedge rrstn) begin\n    if(~rrstn) begin\n      raddr_bin <= 'd0;\n    end else if(!rempty && rinc) begin\n      raddr_bin <= raddr_bin + 1'd1;\n    end \n  end\n\n  wire [ADDR_WIDTH:0] waddr_gray;\n  wire [ADDR_WIDTH:0] raddr_gray;\n  reg [ADDR_WIDTH:0] wptr;\n  reg [ADDR_WIDTH:0] rptr;\n  assign waddr_gray = waddr_bin ^ (waddr_bin >> 1);\n  assign raddr_gray = raddr_bin ^ (raddr_bin >> 1);\n\n  always @(posedge wclk or negedge wrstn) begin\n    if(~wrstn) begin\n      wptr <= 'd0;\n    end else begin\n      wptr <= waddr_gray;\n    end\n  end\n\n\n  always @(posedge rclk or negedge rrstn) begin\n    if(~rrstn) begin\n      rptr <= 'd0;\n    end else begin\n      rptr <= raddr_gray;\n    end\n  end\n\n  reg [ADDR_WIDTH:0] wptr_buff;\n  reg [ADDR_WIDTH:0] wptr_syn;\n  reg [ADDR_WIDTH:0] rptr_buff;\n  reg [ADDR_WIDTH:0] rptr_syn;\n\n  always @(posedge wclk or negedge wrstn) begin\n    if(~wrstn) begin\n      rptr_buff <= 'd0;\n      rptr_syn <= 'd0;\n    end else begin\n      rptr_buff <= rptr;\n      rptr_syn <= rptr_buff;\n    end\n  end\n\n\n  always @(posedge rclk or negedge rrstn) begin\n    if(~rrstn) begin\n      wptr_buff <= 'd0;\n      wptr_syn <= 'd0;\n    end else begin\n      wptr_buff <= wptr;\n      wptr_syn <= wptr_buff;\n    end\n  end\n\n  assign wfull = wptr == { ~rptr_syn[ADDR_WIDTH:ADDR_WIDTH-1], rptr_syn[ADDR_WIDTH-2:0] };\n  assign rempty = rptr == wptr_syn;\n  wire wen;\n  wire ren;\n  wire wren;\n  wire [ADDR_WIDTH-1:0] waddr;\n  wire [ADDR_WIDTH-1:0] raddr;\n  assign wen = winc & !wfull;\n  assign ren = rinc & !rempty;\n  assign waddr = waddr_bin[ADDR_WIDTH-1:0];\n  assign raddr = raddr_bin[ADDR_WIDTH-1:0];\n\n  dual_port_RAM\n  #(\n    .DEPTH(DEPTH),\n    .WIDTH(WIDTH)\n  )\n  dual_port_RAM\n  (\n    .wclk(wclk),\n    .wenc(wen),\n    .waddr(waddr[ADDR_WIDTH-1:0]),\n    .wdata(wdata),\n    .rclk(rclk),\n    .renc(ren),\n    .raddr(raddr[ADDR_WIDTH-1:0]),\n    .rdata(rdata)\n  );\n\n\nendmodule\n\n"}
{"hash": "a8ef43ffee7a82fa81d8fb32f000d27915851b2a5622e00c050f829e7022e204", "equivalence_group": "a8ef43ffee7a82fa81d8fb32f000d27915851b2a5622e00c050f829e7022e204", "content": "\n\nmodule barrel_shifter\n(\n  in,\n  ctrl,\n  out\n);\n\n  input [7:0] in;\n  input [2:0] ctrl;\n  output [7:0] out;\n  wire [7:0] x;\n  wire [7:0] y;\n\n  mux2X1\n  ins_17\n  (\n    .in0(in[7]),\n    .in1(1'b0),\n    .sel(ctrl[2]),\n    .out(x[7])\n  );\n\n\n  mux2X1\n  ins_16\n  (\n    .in0(in[6]),\n    .in1(1'b0),\n    .sel(ctrl[2]),\n    .out(x[6])\n  );\n\n\n  mux2X1\n  ins_15\n  (\n    .in0(in[5]),\n    .in1(1'b0),\n    .sel(ctrl[2]),\n    .out(x[5])\n  );\n\n\n  mux2X1\n  ins_14\n  (\n    .in0(in[4]),\n    .in1(1'b0),\n    .sel(ctrl[2]),\n    .out(x[4])\n  );\n\n\n  mux2X1\n  ins_13\n  (\n    .in0(in[3]),\n    .in1(in[7]),\n    .sel(ctrl[2]),\n    .out(x[3])\n  );\n\n\n  mux2X1\n  ins_12\n  (\n    .in0(in[2]),\n    .in1(in[6]),\n    .sel(ctrl[2]),\n    .out(x[2])\n  );\n\n\n  mux2X1\n  ins_11\n  (\n    .in0(in[1]),\n    .in1(in[5]),\n    .sel(ctrl[2]),\n    .out(x[1])\n  );\n\n\n  mux2X1\n  ins_10\n  (\n    .in0(in[0]),\n    .in1(in[4]),\n    .sel(ctrl[2]),\n    .out(x[0])\n  );\n\n\n  mux2X1\n  ins_27\n  (\n    .in0(x[7]),\n    .in1(1'b0),\n    .sel(ctrl[1]),\n    .out(y[7])\n  );\n\n\n  mux2X1\n  ins_26\n  (\n    .in0(x[6]),\n    .in1(1'b0),\n    .sel(ctrl[1]),\n    .out(y[6])\n  );\n\n\n  mux2X1\n  ins_25\n  (\n    .in0(x[5]),\n    .in1(x[7]),\n    .sel(ctrl[1]),\n    .out(y[5])\n  );\n\n\n  mux2X1\n  ins_24\n  (\n    .in0(x[4]),\n    .in1(x[6]),\n    .sel(ctrl[1]),\n    .out(y[4])\n  );\n\n\n  mux2X1\n  ins_23\n  (\n    .in0(x[3]),\n    .in1(x[5]),\n    .sel(ctrl[1]),\n    .out(y[3])\n  );\n\n\n  mux2X1\n  ins_22\n  (\n    .in0(x[2]),\n    .in1(x[4]),\n    .sel(ctrl[1]),\n    .out(y[2])\n  );\n\n\n  mux2X1\n  ins_21\n  (\n    .in0(x[1]),\n    .in1(x[3]),\n    .sel(ctrl[1]),\n    .out(y[1])\n  );\n\n\n  mux2X1\n  ins_20\n  (\n    .in0(x[0]),\n    .in1(x[2]),\n    .sel(ctrl[1]),\n    .out(y[0])\n  );\n\n\n  mux2X1\n  ins_07\n  (\n    .in0(y[7]),\n    .in1(1'b0),\n    .sel(ctrl[0]),\n    .out(out[7])\n  );\n\n\n  mux2X1\n  ins_06\n  (\n    .in0(y[6]),\n    .in1(y[7]),\n    .sel(ctrl[0]),\n    .out(out[6])\n  );\n\n\n  mux2X1\n  ins_05\n  (\n    .in0(y[5]),\n    .in1(y[6]),\n    .sel(ctrl[0]),\n    .out(out[5])\n  );\n\n\n  mux2X1\n  ins_04\n  (\n    .in0(y[4]),\n    .in1(y[5]),\n    .sel(ctrl[0]),\n    .out(out[4])\n  );\n\n\n  mux2X1\n  ins_03\n  (\n    .in0(y[3]),\n    .in1(y[4]),\n    .sel(ctrl[0]),\n    .out(out[3])\n  );\n\n\n  mux2X1\n  ins_02\n  (\n    .in0(y[2]),\n    .in1(y[3]),\n    .sel(ctrl[0]),\n    .out(out[2])\n  );\n\n\n  mux2X1\n  ins_01\n  (\n    .in0(y[1]),\n    .in1(y[2]),\n    .sel(ctrl[0]),\n    .out(out[1])\n  );\n\n\n  mux2X1\n  ins_00\n  (\n    .in0(y[0]),\n    .in1(y[1]),\n    .sel(ctrl[0]),\n    .out(out[0])\n  );\n\n\nendmodule\n\n\n\nmodule mux2X1\n(\n  in0,\n  in1,\n  sel,\n  out\n);\n\n  input in0;\n  input in1;\n  input sel;\n  output out;\n  assign out = (sel)? in1 : in0;\n\nendmodule\n\n"}
{"hash": "0efd1410c30da7ff5a77bd78832957a6223aefe8eea4cd85668b0b207137b16d", "equivalence_group": "0efd1410c30da7ff5a77bd78832957a6223aefe8eea4cd85668b0b207137b16d", "content": "\n\nmodule verified_calendar\n(\n  CLK,\n  RST,\n  Hours,\n  Mins,\n  Secs\n);\n\n  input CLK;\n  input RST;\n  output [5:0] Hours;\n  output [5:0] Mins;\n  output [5:0] Secs;\n  reg [5:0] Hours;\n  reg [5:0] Mins;\n  reg [5:0] Secs;\n\n  always @(posedge CLK or posedge RST) begin\n    if(RST) Secs <= 0; \n    else if(Secs == 59) Secs <= 0; \n    else Secs <= Secs + 1;\n  end\n\n\n  always @(posedge CLK or posedge RST) begin\n    if(RST) Mins <= 0; \n    else if((Mins == 59) && (Secs == 59)) Mins <= 0; \n    else if(Secs == 59) Mins <= Mins + 1; \n    else Mins <= Mins;\n  end\n\n\n  always @(posedge CLK or posedge RST) begin\n    if(RST) Hours <= 0; \n    else if((Hours == 23) && (Mins == 59) && (Secs == 59)) Hours <= 0; \n    else if((Mins == 59) && (Secs == 59)) Hours <= Hours + 1; \n    else Hours <= Hours;\n  end\n\n\nendmodule\n\n"}
{"hash": "4d6c07b66ea432b714ca9ff1d44e190ea0aabb4e438effa1e28b68f47c437770", "equivalence_group": "4d6c07b66ea432b714ca9ff1d44e190ea0aabb4e438effa1e28b68f47c437770", "content": "\n\nmodule clkgenerator\n(\n  output reg clk\n);\n\n  parameter PERIOD = 10;\n\n  initial begin\n    clk = 0;\n  end\n\n\n  always @(*) begin\n    #(PERIOD / 2) clk = ~clk;\n  end\n\n\nendmodule\n\n"}
{"hash": "d7c6e49b1f7b7b06856e2a6fad60eded05c933a0a626ee859e1491309f5b1640", "equivalence_group": "d7c6e49b1f7b7b06856e2a6fad60eded05c933a0a626ee859e1491309f5b1640", "content": "\n\nmodule comparator_3bit\n(\n  input [2:0] A,\n  input [2:0] B,\n  output A_greater,\n  output A_equal,\n  output A_less\n);\n\n  assign A_greater = (A > B)? 1'b1 : 1'b0;\n  assign A_equal = (A == B)? 1'b1 : 1'b0;\n  assign A_less = (A < B)? 1'b1 : 1'b0;\n\nendmodule\n\n"}
{"hash": "6cc5297b099a2212835f95fc152fe6f28d951184417acc3665ea007e5b0aa7f8", "equivalence_group": "6cc5297b099a2212835f95fc152fe6f28d951184417acc3665ea007e5b0aa7f8", "content": "\n\nmodule comparator_4bit\n(\n  input [3:0] A,\n  input [3:0] B,\n  output A_greater,\n  output A_equal,\n  output A_less\n);\n\n  wire [3:0] diff;\n  wire cout;\n  assign { cout, diff } = A - B;\n  assign A_greater = ~cout && (diff != 4'b0000);\n  assign A_equal = A == B;\n  assign A_less = cout;\n\nendmodule\n\n"}
{"hash": "c6e96c865e7d4ff7370851a8855d60ca36c45b81fbd063ea57eb1a8555e73e9b", "equivalence_group": "c6e96c865e7d4ff7370851a8855d60ca36c45b81fbd063ea57eb1a8555e73e9b", "content": "\n\nmodule verified_counter_12\n(\n  input rst_n,\n  input clk,\n  input valid_count,\n  output reg [3:0] out\n);\n\n\n  always @(posedge clk or negedge rst_n) begin\n    if(!rst_n) begin\n      out <= 4'b0000;\n    end else if(valid_count) begin\n      if(out == 4'd11) begin\n        out <= 4'b0000;\n      end else begin\n        out <= out + 1;\n      end\n    end else begin\n      out <= out;\n    end\n  end\n\n\nendmodule\n\n"}
{"hash": "09c5e0ff028a6baa22588b62eee7c035ff4c4645e844785a14872cf023143278", "equivalence_group": "09c5e0ff028a6baa22588b62eee7c035ff4c4645e844785a14872cf023143278", "content": "\n\nmodule verified_div_16bit\n(\n  input wire [15:0] A,\n  input wire [7:0] B,\n  output wire [15:0] result,\n  output wire [15:0] odd\n);\n\n  reg [15:0] a_reg;\n  reg [15:0] b_reg;\n  reg [31:0] tmp_a;\n  reg [31:0] tmp_b;\n  integer i;\n\n  always @(*) begin\n    a_reg = A;\n    b_reg = B;\n  end\n\n\n  always @(*) begin\n    begin\n      tmp_a = { 16'b0, a_reg };\n      tmp_b = { b_reg, 16'b0 };\n      for(i=0; i<16; i=i+1) begin\n        tmp_a = tmp_a << 1;\n        if(tmp_a >= tmp_b) begin\n          tmp_a = tmp_a - tmp_b + 1;\n        end else begin\n          tmp_a = tmp_a;\n        end\n      end\n    end\n  end\n\n  assign odd = tmp_a[31:16];\n  assign result = tmp_a[15:0];\n\nendmodule\n\n"}
{"hash": "d234b4a23f71b056b47c2ce6fd45a76c4787e080701d4ab2f056e5d806eaee95", "equivalence_group": "d234b4a23f71b056b47c2ce6fd45a76c4787e080701d4ab2f056e5d806eaee95", "content": "\n\nmodule verified_edge_detect\n(\n  input clk,\n  input rst_n,\n  input a,\n  output reg rise,\n  output reg down\n);\n\n  reg a0;\n\n  always @(posedge clk or negedge rst_n) begin\n    if(~rst_n) begin\n      rise <= 1'b0;\n      down <= 1'b0;\n    end else begin\n      if(a & ~a0) begin\n        rise <= 1;\n        down <= 0;\n      end else if(~a & a0) begin\n        rise <= 0;\n        down <= 1;\n      end else begin\n        rise <= 0;\n        down <= 0;\n      end\n    end\n  end\n\n\n  always @(posedge clk or negedge rst_n) begin\n    if(~rst_n) a0 <= 0; \n    else a0 <= a;\n  end\n\n\nendmodule\n\n"}
{"hash": "af86473888900f20ec5ad5a1390b3549b51babb280cd11ac52b72267496308ea", "equivalence_group": "af86473888900f20ec5ad5a1390b3549b51babb280cd11ac52b72267496308ea", "content": "\n\nmodule fixed_point_adder #\n(\n  parameter Q = 15,\n  parameter N = 32\n)\n(\n  input [N-1:0] a,\n  input [N-1:0] b,\n  output [N-1:0] c\n);\n\n  reg [N-1:0] res;\n  assign c = res;\n\n  always @(a or b) begin\n    if(a[N - 1] == b[N - 1]) begin\n      res[N-2:0] = a[N-2:0] + b[N-2:0];\n      res[N - 1] = a[N - 1];\n    end else if((a[N - 1] == 0) && (b[N - 1] == 1)) begin\n      if(a[N-2:0] > b[N-2:0]) begin\n        res[N-2:0] = a[N-2:0] - b[N-2:0];\n        res[N - 1] = 0;\n      end else begin\n        res[N-2:0] = b[N-2:0] - a[N-2:0];\n        if(res[N-2:0] == 0) res[N - 1] = 0; \n        else res[N - 1] = 1;\n      end\n    end else begin\n      if(a[N-2:0] > b[N-2:0]) begin\n        res[N-2:0] = a[N-2:0] - b[N-2:0];\n        if(res[N-2:0] == 0) res[N - 1] = 0; \n        else res[N - 1] = 1;\n      end else begin\n        res[N-2:0] = b[N-2:0] - a[N-2:0];\n        res[N - 1] = 0;\n      end\n    end\n  end\n\n\nendmodule\n\n"}
{"hash": "ec805fa127b134fd8d41660bbd07c3b4350d602555eeafe6bc01c75d4fdd3487", "equivalence_group": "ec805fa127b134fd8d41660bbd07c3b4350d602555eeafe6bc01c75d4fdd3487", "content": "\n\nmodule fixed_point_subtractor #\n(\n  parameter Q = 15,\n  parameter N = 32\n)\n(\n  input [N-1:0] a,\n  input [N-1:0] b,\n  output [N-1:0] c\n);\n\n  reg [N-1:0] res;\n  assign c = res;\n\n  always @(a or b) begin\n    if(a[N - 1] == b[N - 1]) begin\n      res[N-2:0] = a[N-2:0] - b[N-2:0];\n      res[N - 1] = a[N - 1];\n    end else if((a[N - 1] == 0) && (b[N - 1] == 1)) begin\n      if(a[N-2:0] > b[N-2:0]) begin\n        res[N-2:0] = a[N-2:0] + b[N-2:0];\n        res[N - 1] = 0;\n      end else begin\n        res[N-2:0] = b[N-2:0] + a[N-2:0];\n        if(res[N-2:0] == 0) res[N - 1] = 0; \n        else res[N - 1] = 1;\n      end\n    end else begin\n      if(a[N-2:0] > b[N-2:0]) begin\n        res[N-2:0] = a[N-2:0] + b[N-2:0];\n        if(res[N-2:0] == 0) res[N - 1] = 0; \n        else res[N - 1] = 1;\n      end else begin\n        res[N-2:0] = b[N-2:0] + a[N-2:0];\n        res[N - 1] = 0;\n      end\n    end\n  end\n\n\nendmodule\n\n"}
{"hash": "3da2108b085d95e878f5f905f099dc4b457c5876712600845dfc9c5e8fa754c0", "equivalence_group": "3da2108b085d95e878f5f905f099dc4b457c5876712600845dfc9c5e8fa754c0", "content": "\n\nmodule freq_div\n(\n  CLK_in,\n  CLK_50,\n  CLK_10,\n  CLK_1,\n  RST\n);\n\n  input CLK_in;\n  input RST;\n  output CLK_50;\n  reg CLK_50;\n  output CLK_10;\n  reg CLK_10;\n  output CLK_1;\n  reg CLK_1;\n  reg [3:0] cnt_10;\n  reg [6:0] cnt_100;\n\n  always @(posedge CLK_in or posedge RST) begin\n    if(RST) begin\n      CLK_50 <= 1'b0;\n    end else begin\n      CLK_50 <= ~CLK_50;\n    end\n  end\n\n\n  always @(posedge CLK_in or posedge RST) begin\n    if(RST) begin\n      CLK_10 <= 1'b0;\n      cnt_10 <= 0;\n    end else if(cnt_10 == 4) begin\n      CLK_10 <= ~CLK_10;\n      cnt_10 <= 0;\n    end else begin\n      cnt_10 <= cnt_10 + 1;\n    end\n  end\n\n\n  always @(posedge CLK_in or posedge RST) begin\n    if(RST) begin\n      CLK_1 <= 1'b0;\n      cnt_100 <= 0;\n    end else if(cnt_100 == 49) begin\n      CLK_1 <= ~CLK_1;\n      cnt_100 <= 0;\n    end else begin\n      cnt_100 <= cnt_100 + 1;\n    end\n  end\n\n\nendmodule\n\n"}
{"hash": "530d77b4fb1623350259a280468174f4798b5ba44769fcb0b25698fa066285e9", "equivalence_group": "530d77b4fb1623350259a280468174f4798b5ba44769fcb0b25698fa066285e9", "content": "\n\nmodule freq_divbyeven\n(\n  clk,\n  rst_n,\n  clk_div\n);\n\n  input clk;\n  input rst_n;\n  output clk_div;\n  reg clk_div;\n  parameter NUM_DIV = 6;\n  reg [3:0] cnt;\n\n  always @(posedge clk or negedge rst_n) if(!rst_n) begin\n    cnt <= 4'd0;\n    clk_div <= 1'b0;\n  end else if(cnt < NUM_DIV / 2 - 1) begin\n    cnt <= cnt + 1'b1;\n    clk_div <= clk_div;\n  end else begin\n    cnt <= 4'd0;\n    clk_div <= ~clk_div;\n  end\n\n\nendmodule\n\n"}
{"hash": "2b9268f33d665fc76383c9364930301901d7777f02c53fd5863f3ef9b3b4a72e", "equivalence_group": "2b9268f33d665fc76383c9364930301901d7777f02c53fd5863f3ef9b3b4a72e", "content": "\n\nmodule freq_divbyfrac\n(\n  input rst_n,\n  input clk,\n  output clk_div\n);\n\n  parameter MUL2_DIV_CLK = 7;\n  reg [3:0] cnt;\n\n  always @(posedge clk or negedge rst_n) begin\n    if(!rst_n) begin\n      cnt <= 'b0;\n    end else if(cnt == MUL2_DIV_CLK - 1) begin\n      cnt <= 'b0;\n    end else begin\n      cnt <= cnt + 1'b1;\n    end\n  end\n\n  reg clk_ave_r;\n\n  always @(posedge clk or negedge rst_n) begin\n    if(!rst_n) begin\n      clk_ave_r <= 1'b0;\n    end else if(cnt == 0) begin\n      clk_ave_r <= 1;\n    end else if(cnt == MUL2_DIV_CLK / 2 + 1) begin\n      clk_ave_r <= 1;\n    end else begin\n      clk_ave_r <= 0;\n    end\n  end\n\n  reg clk_adjust_r;\n\n  always @(negedge clk or negedge rst_n) begin\n    if(!rst_n) begin\n      clk_adjust_r <= 1'b0;\n    end else if(cnt == 1) begin\n      clk_adjust_r <= 1;\n    end else if(cnt == MUL2_DIV_CLK / 2 + 1) begin\n      clk_adjust_r <= 1;\n    end else begin\n      clk_adjust_r <= 0;\n    end\n  end\n\n  assign clk_div = clk_adjust_r | clk_ave_r;\n\nendmodule\n\n"}
{"hash": "0e99cb0d5d7083514a721247f92163a8d5ca32a3909cdc9a328515f2278b12a1", "equivalence_group": "0e99cb0d5d7083514a721247f92163a8d5ca32a3909cdc9a328515f2278b12a1", "content": "\n\nmodule freq_divbyodd\n(\n  clk,\n  rst_n,\n  clk_div\n);\n\n  input clk;\n  input rst_n;\n  output clk_div;\n  reg clk_div;\n  parameter NUM_DIV = 5;\n  reg [2:0] cnt1;\n  reg [2:0] cnt2;\n  reg clk_div1;\n  reg clk_div2;\n\n  always @(posedge clk or negedge rst_n) if(!rst_n) cnt1 <= 0; \n  else if(cnt1 < NUM_DIV - 1) cnt1 <= cnt1 + 1'b1; \n  else cnt1 <= 0;\n\n\n  always @(posedge clk or negedge rst_n) if(!rst_n) clk_div1 <= 1'b1; \n  else if(cnt1 < NUM_DIV / 2) clk_div1 <= 1'b1; \n  else clk_div1 <= 1'b0;\n\n\n  always @(negedge clk or negedge rst_n) if(!rst_n) cnt2 <= 0; \n  else if(cnt2 < NUM_DIV - 1) cnt2 <= cnt2 + 1'b1; \n  else cnt2 <= 0;\n\n\n  always @(negedge clk or negedge rst_n) if(!rst_n) clk_div2 <= 1'b1; \n  else if(cnt2 < NUM_DIV / 2) clk_div2 <= 1'b1; \n  else clk_div2 <= 1'b0;\n\n  assign clk_div = clk_div1 | clk_div2;\n\nendmodule\n\n"}
{"hash": "6e60fb26bca0efb25cc58e98d389c700668be39675dcff49985bfe11b30a2383", "equivalence_group": "6e60fb26bca0efb25cc58e98d389c700668be39675dcff49985bfe11b30a2383", "content": "\n\nmodule verified_fsm\n(\n  IN,\n  MATCH,\n  CLK,\n  RST\n);\n\n  input IN;\n  input CLK;\n  input RST;\n  output MATCH;\n  reg MATCH;\n  reg [2:0] ST_cr;\n  reg [2:0] ST_nt;\n  parameter s0 = 3'b000;\n  parameter s1 = 3'b001;\n  parameter s2 = 3'b010;\n  parameter s3 = 3'b011;\n  parameter s4 = 3'b100;\n  parameter s5 = 3'b101;\n\n  always @(posedge CLK or posedge RST) begin\n    if(RST) ST_cr <= s0; \n    else ST_cr <= ST_nt;\n  end\n\n\n  always @(*) begin\n    case(ST_cr)\n      s0: begin\n        if(IN == 0) ST_nt = s0; \n        else ST_nt = s1;\n      end\n      s1: begin\n        if(IN == 0) ST_nt = s2; \n        else ST_nt = s1;\n      end\n      s2: begin\n        if(IN == 0) ST_nt = s3; \n        else ST_nt = s1;\n      end\n      s3: begin\n        if(IN == 0) ST_nt = s0; \n        else ST_nt = s4;\n      end\n      s4: begin\n        if(IN == 0) ST_nt = s2; \n        else ST_nt = s5;\n      end\n      s5: begin\n        if(IN == 0) ST_nt = s2; \n        else ST_nt = s1;\n      end\n    endcase\n  end\n\n\n  always @(*) begin\n    if(RST) MATCH <= 0; \n    else if((ST_cr == s4) && (IN == 1)) MATCH <= 1; \n    else MATCH <= 0;\n  end\n\n\nendmodule\n\n"}
{"hash": "a48ff56d79af641a4087ff7090605cabcf6eb136419ad09663f88a3382f7f068", "equivalence_group": "a48ff56d79af641a4087ff7090605cabcf6eb136419ad09663f88a3382f7f068", "content": "\n\nmodule instr_reg\n(\n  input clk,\n  input rst,\n  input [1:0] fetch,\n  input [7:0] data,\n  output [2:0] ins,\n  output [4:0] ad1,\n  output [7:0] ad2\n);\n\n  reg [7:0] ins_p1;\n  reg [7:0] ins_p2;\n  reg [2:0] state;\n\n  always @(posedge clk or negedge rst) begin\n    if(!rst) begin\n      ins_p1 <= 8'd0;\n      ins_p2 <= 8'd0;\n    end else begin\n      if(fetch == 2'b01) begin\n        ins_p1 <= data;\n        ins_p2 <= ins_p2;\n      end else if(fetch == 2'b10) begin\n        ins_p1 <= ins_p1;\n        ins_p2 <= data;\n      end else begin\n        ins_p1 <= ins_p1;\n        ins_p2 <= ins_p2;\n      end\n    end\n  end\n\n  assign ins = ins_p1[7:5];\n  assign ad1 = ins_p1[4:0];\n  assign ad2 = ins_p2;\n\nendmodule\n\n"}
{"hash": "dcfd8c675f9e85ccdfe44576cfaca0895f13fb8e9afe4eec550808b5884b4fcd", "equivalence_group": "dcfd8c675f9e85ccdfe44576cfaca0895f13fb8e9afe4eec550808b5884b4fcd", "content": "\n\nmodule verified_multi_16bit\n(\n  input clk,\n  input rst_n,\n  input start,\n  input [15:0] ain,\n  input [15:0] bin,\n  output [31:0] yout,\n  output done\n);\n\n  reg [15:0] areg;\n  reg [15:0] breg;\n  reg [31:0] yout_r;\n  reg done_r;\n  reg [4:0] i;\n\n  always @(posedge clk or negedge rst_n) if(!rst_n) i <= 5'd0; \n  else if(start && (i < 5'd17)) i <= i + 1'b1; \n  else if(!start) i <= 5'd0; \n\n\n  always @(posedge clk or negedge rst_n) if(!rst_n) done_r <= 1'b0; \n  else if(i == 5'd16) done_r <= 1'b1; \n  else if(i == 5'd17) done_r <= 1'b0; \n\n  assign done = done_r;\n\n  always @(posedge clk or negedge rst_n) begin\n    if(!rst_n) begin\n      areg <= 16'h0000;\n      breg <= 16'h0000;\n      yout_r <= 32'h00000000;\n    end else if(start) begin\n      if(i == 5'd0) begin\n        areg <= ain;\n        breg <= bin;\n      end else if((i > 5'd0) && (i < 5'd17)) begin\n        if(areg[i - 1]) yout_r <= yout_r + ({ 16'h0000, breg } << i - 1); \n      end \n    end \n  end\n\n  assign yout = yout_r;\n\nendmodule\n\n"}
{"hash": "b877d4d060b697f5070d73aee68df06906176615f376096944c0886b93861f59", "equivalence_group": "b877d4d060b697f5070d73aee68df06906176615f376096944c0886b93861f59", "content": "\n\nmodule verified_multi_pipe #\n(\n  parameter size = 4\n)\n(\n  input clk,\n  input rst_n,\n  input [size-1:0] mul_a,\n  input [size-1:0] mul_b,\n  output reg [size*2-1:0] mul_out\n);\n\n  parameter N = 2 * size;\n  reg [N-1:0] sum_tmp1;\n  reg [N-1:0] sum_tmp2;\n  wire [N-1:0] mul_a_extend;\n  wire [N-1:0] mul_b_extend;\n  wire [N-1:0] mul_result [size-1:0];\n  genvar i;\n\n  generate for(i=0; i<size; i=i+1) begin : add\n    assign mul_result[i] = (mul_b[i])? mul_a_extend << i : 'd0;\n  end\n  endgenerate\n\n  assign mul_a_extend = { { size{ 1'b0 } }, mul_a };\n  assign mul_b_extend = { { size{ 1'b0 } }, mul_b };\n\n  always @(posedge clk or negedge rst_n) begin\n    if(!rst_n) begin\n      sum_tmp1 <= 'd0;\n      sum_tmp2 <= 'd0;\n    end else begin\n      sum_tmp1 <= mul_result[0] + mul_result[1];\n      sum_tmp2 <= mul_result[2] + mul_result[3];\n    end\n  end\n\n\n  always @(posedge clk or negedge rst_n) begin\n    if(!rst_n) begin\n      mul_out <= 'd0;\n    end else begin\n      mul_out <= sum_tmp1 + sum_tmp2;\n    end\n  end\n\n\nendmodule\n\n"}
{"hash": "45de189bab255349bc985bf3f7530edaaedc4c4d5cc0ccc0dfb8bfc420d6658c", "equivalence_group": "45de189bab255349bc985bf3f7530edaaedc4c4d5cc0ccc0dfb8bfc420d6658c", "content": "\n\nmodule verified_multi_pipe_8bit #\n(\n  parameter size = 8\n)\n(\n  clk,\n  rst_n,\n  mul_a,\n  mul_b,\n  mul_en_in,\n  mul_en_out,\n  mul_out\n);\n\n  input clk;\n  input rst_n;\n  input mul_en_in;\n  input [size-1:0] mul_a;\n  input [size-1:0] mul_b;\n  output mul_en_out;\n  reg mul_en_out;\n  output [size*2-1:0] mul_out;\n  reg [size*2-1:0] mul_out;\n  reg [2:0] mul_en_out_reg;\n\n  always @(posedge clk or negedge rst_n) if(!rst_n) begin\n    mul_en_out_reg <= 'd0;\n    mul_en_out <= 'd0;\n  end else begin\n    mul_en_out_reg <= { mul_en_out_reg[1:0], mul_en_in };\n    mul_en_out <= mul_en_out_reg[2];\n  end\n\n  reg [7:0] mul_a_reg;\n  reg [7:0] mul_b_reg;\n\n  always @(posedge clk or negedge rst_n) if(!rst_n) begin\n    mul_a_reg <= 'd0;\n    mul_a_reg <= 'd0;\n  end else begin\n    mul_a_reg <= (mul_en_in)? mul_a : 'd0;\n    mul_b_reg <= (mul_en_in)? mul_b : 'd0;\n  end\n\n  wire [15:0] temp [size-1:0];\n  assign temp[0] = (mul_b_reg[0])? { 8'b0, mul_a_reg } : 'd0;\n  assign temp[1] = (mul_b_reg[1])? { 7'b0, mul_a_reg, 1'b0 } : 'd0;\n  assign temp[2] = (mul_b_reg[2])? { 6'b0, mul_a_reg, 2'b0 } : 'd0;\n  assign temp[3] = (mul_b_reg[3])? { 5'b0, mul_a_reg, 3'b0 } : 'd0;\n  assign temp[4] = (mul_b_reg[4])? { 4'b0, mul_a_reg, 4'b0 } : 'd0;\n  assign temp[5] = (mul_b_reg[5])? { 3'b0, mul_a_reg, 5'b0 } : 'd0;\n  assign temp[6] = (mul_b_reg[6])? { 2'b0, mul_a_reg, 6'b0 } : 'd0;\n  assign temp[7] = (mul_b_reg[7])? { 1'b0, mul_a_reg, 7'b0 } : 'd0;\n  reg [15:0] sum [3:0];\n\n  always @(posedge clk or negedge rst_n) if(!rst_n) begin\n    sum[0] <= 'd0;\n    sum[1] <= 'd0;\n    sum[2] <= 'd0;\n    sum[3] <= 'd0;\n  end else begin\n    sum[0] <= temp[0] + temp[1];\n    sum[1] <= temp[2] + temp[3];\n    sum[2] <= temp[4] + temp[5];\n    sum[3] <= temp[6] + temp[7];\n  end\n\n  reg [15:0] mul_out_reg;\n\n  always @(posedge clk or negedge rst_n) if(!rst_n) mul_out_reg <= 'd0; \n  else mul_out_reg <= sum[0] + sum[1] + sum[2] + sum[3];\n\n\n  always @(posedge clk or negedge rst_n) if(!rst_n) mul_out <= 'd0; \n  else if(mul_en_out_reg[2]) mul_out <= mul_out_reg; \n  else mul_out <= 'd0;\n\n\nendmodule\n\n"}
{"hash": "d72e950fc3662e4d08e20ff8b7f6f6d524792e226ef3a33a023fc476f1e126d3", "equivalence_group": "d72e950fc3662e4d08e20ff8b7f6f6d524792e226ef3a33a023fc476f1e126d3", "content": "\n\nmodule verified_parallel2serial\n(\n  input wire clk,\n  input wire rst_n,\n  input wire [3:0] d,\n  output wire valid_out,\n  output wire dout\n);\n\n  reg [3:0] data;\n  assign data = 'd0;\n  reg [1:0] cnt;\n  reg valid;\n  assign dout = data[3];\n  assign valid_out = valid;\n\n  always @(posedge clk or negedge rst_n) begin\n    if(!rst_n) begin\n      data <= 'd0;\n      cnt <= 'd0;\n      valid <= 'd0;\n    end else begin\n      if(cnt == 'd3) begin\n        data <= d;\n        cnt <= 'd0;\n        valid <= 1;\n      end else begin\n        cnt <= cnt + 'd1;\n        valid <= 0;\n        data <= { data[2:0], data[3] };\n      end\n    end\n  end\n\n\nendmodule\n\n"}
{"hash": "6b1e2b6984dc28df3b21bfef20add72403c5840a4672ba0991e506ded312b1bd", "equivalence_group": "6b1e2b6984dc28df3b21bfef20add72403c5840a4672ba0991e506ded312b1bd", "content": "\n\nmodule verified_pe\n(\n  input clk,\n  input rst,\n  input [31:0] a,\n  input [31:0] b,\n  output [31:0] c\n);\n\n  reg [31:0] cc;\n  assign c = cc;\n\n  always @(posedge clk or posedge rst) begin\n    if(rst) begin\n      cc <= 0;\n    end else begin\n      cc <= cc + a * b;\n    end\n  end\n\n\nendmodule\n\n"}
{"hash": "673bf9146b7b1241654b9b07ee03aa06e5b5c80d1b258cffe32784d2b54d60ee", "equivalence_group": "673bf9146b7b1241654b9b07ee03aa06e5b5c80d1b258cffe32784d2b54d60ee", "content": "\n\nmodule verified_pulse_detect\n(\n  input clk,\n  input rst_n,\n  input data_in,\n  output reg data_out\n);\n\n  parameter s0 = 2'b00;\n  parameter s1 = 2'b01;\n  parameter s2 = 2'b10;\n  parameter s3 = 2'b11;\n  reg [1:0] pulse_level1;\n  reg [1:0] pulse_level2;\n\n  always @(posedge clk or negedge rst_n) begin\n    if(!rst_n) pulse_level1 <= s0; \n    else pulse_level1 <= pulse_level2;\n  end\n\n\n  always @(*) begin\n    case(pulse_level1)\n      s0: begin\n        if(data_in == 0) pulse_level2 = s1; \n        else pulse_level2 = s0;\n      end\n      s1: begin\n        if(data_in == 1) pulse_level2 = s2; \n        else pulse_level2 = s1;\n      end\n      s2: begin\n        if(data_in == 0) pulse_level2 = s3; \n        else pulse_level2 = s0;\n      end\n      s3: begin\n        if(data_in == 1) pulse_level2 = s2; \n        else pulse_level2 = s1;\n      end\n    endcase\n  end\n\n\n  always @(*) begin\n    if(~rst_n) data_out = 0; \n    else if((pulse_level1 == s2) && (data_in == 0)) data_out = 1; \n    else data_out = 0;\n  end\n\n\nendmodule\n\n"}
{"hash": "94789d33748411827847e855c59766dae4e96e8241246575816dc74d0b5fb303", "equivalence_group": "94789d33748411827847e855c59766dae4e96e8241246575816dc74d0b5fb303", "content": "\n\nmodule verified_radix2_div\n(\n  input wire clk,\n  input wire rst,\n  input wire [7:0] dividend,\n  input wire [7:0] divisor,\n  input wire sign,\n  input wire opn_valid,\n  output reg res_valid,\n  input wire res_ready,\n  output wire [15:0] result\n);\n\n  reg [7:0] dividend_save;\n  reg [7:0] divisor_save;\n  reg [15:0] SR;\n  reg [8:0] NEG_DIVISOR;\n  wire [7:0] REMAINER;\n  wire [7:0] QUOTIENT;\n  assign REMAINER = SR[15:8];\n  assign QUOTIENT = SR[7:0];\n  wire [7:0] divident_abs;\n  wire [8:0] divisor_abs;\n  wire [7:0] remainer;\n  wire [7:0] quotient;\n  assign divident_abs = (sign & dividend[7])? ~dividend + 1'b1 : dividend;\n  assign remainer = (sign & dividend_save[7])? ~REMAINER + 1'b1 : REMAINER;\n  assign quotient = (sign & (dividend_save[7] ^ divisor_save[7]))? ~QUOTIENT + 1'b1 : QUOTIENT;\n  assign result = { remainer, quotient };\n  wire CO;\n  wire [8:0] sub_result;\n  wire [8:0] mux_result;\n  assign { CO, sub_result } = { 1'b0, REMAINER } + NEG_DIVISOR;\n  assign mux_result = (CO)? sub_result : { 1'b0, REMAINER };\n  reg [3:0] cnt;\n  reg start_cnt;\n\n  always @(posedge clk) begin\n    if(rst) begin\n      SR <= 0;\n      dividend_save <= 0;\n      divisor_save <= 0;\n      cnt <= 0;\n      start_cnt <= 1'b0;\n    end else if(~start_cnt & opn_valid & ~res_valid) begin\n      cnt <= 1;\n      start_cnt <= 1'b1;\n      dividend_save <= dividend;\n      divisor_save <= divisor;\n      SR[15:0] <= { 7'b0, divident_abs, 1'b0 };\n      NEG_DIVISOR <= (sign & divisor[7])? { 1'b1, divisor } : ~{ 1'b0, divisor } + 1'b1;\n    end else if(start_cnt) begin\n      if(cnt[3]) begin\n        cnt <= 0;\n        start_cnt <= 1'b0;\n        SR[15:8] <= mux_result[7:0];\n        SR[0] <= CO;\n      end else begin\n        cnt <= cnt + 1;\n        SR[15:0] <= { mux_result[6:0], SR[7:1], CO, 1'b0 };\n      end\n    end \n  end\n\n  wire data_go;\n  assign data_go = res_valid & res_ready;\n\n  always @(posedge clk) begin\n    res_valid <= (rst)? 1'b0 : \n                 (cnt[3])? 1'b1 : \n                 (data_go)? 1'b0 : res_valid;\n  end\n\n\nendmodule\n\n"}
{"hash": "bc86e7b77e35039ef6c88d0b4349b1b1e33ad2a199d06b5dd15716b3ab562cea", "equivalence_group": "bc86e7b77e35039ef6c88d0b4349b1b1e33ad2a199d06b5dd15716b3ab562cea", "content": "\n\nmodule verified_right_shifter\n(\n  clk,\n  q,\n  d\n);\n\n  input clk;\n  input d;\n  output [7:0] q;\n  reg [7:0] q;\n\n  initial q = 0;\n\n\n  always @(posedge clk) begin\n    q <= q >> 1;\n    q[7] <= d;\n  end\n\n\nendmodule\n\n"}
{"hash": "9cf0e2fc09d54e47ce126c040f5ac72e75af56b09419e2988f61048426b8cec5", "equivalence_group": "9cf0e2fc09d54e47ce126c040f5ac72e75af56b09419e2988f61048426b8cec5", "content": "\n\nmodule ring_counter\n(\n  input wire clk,\n  input wire reset,\n  output reg [7:0] out\n);\n\n  reg [7:0] state;\n\n  always @(posedge clk or posedge reset) begin\n    if(reset) state <= 8'b0000_0001; \n    else state <= { state[6:0], state[7] };\n  end\n\n  assign out = state;\n\nendmodule\n\n"}
{"hash": "77cfe636a716d3e3f55c37193d16e331044dd1fe1d20f4e78cc313418630a71a", "equivalence_group": "77cfe636a716d3e3f55c37193d16e331044dd1fe1d20f4e78cc313418630a71a", "content": "\n\nmodule sequence_detector\n(\n  input clk,\n  input rst_n,\n  input data_in,\n  output sequence_detected\n);\n\n  parameter IDLE = 5'b00001;\n  parameter S1 = 5'b00010;\n  parameter S2 = 5'b00100;\n  parameter S3 = 5'b01000;\n  parameter S4 = 5'b10000;\n  reg [4:0] curr_state;\n  reg [4:0] next_state;\n\n  always @(posedge clk or negedge rst_n) begin\n    if(!rst_n) begin\n      curr_state <= IDLE;\n    end else begin\n      curr_state <= next_state;\n    end\n  end\n\n\n  always @(*) begin\n    if(!rst_n) begin\n      next_state <= IDLE;\n    end else begin\n      case(curr_state)\n        IDLE: next_state = (data_in)? S1 : IDLE;\n        S1: next_state = (data_in)? S1 : S2;\n        S2: next_state = (data_in)? S1 : S3;\n        S3: next_state = (data_in)? S4 : IDLE;\n        S4: next_state = (data_in)? S1 : S2;\n        default: next_state = IDLE;\n      endcase\n    end\n  end\n\n  assign sequence_detected = (curr_state == S4)? 1'b1 : 1'b0;\n\nendmodule\n\n"}
{"hash": "b33eb0a630ae458c1b503862833b30aed3c9e1d9e777ed62336c8d5b08df525c", "equivalence_group": "b33eb0a630ae458c1b503862833b30aed3c9e1d9e777ed62336c8d5b08df525c", "content": "\n\nmodule verified_serial2parallel\n(\n  input clk,\n  input rst_n,\n  input din_serial,\n  input din_valid,\n  output reg [7:0] dout_parallel,\n  output reg dout_valid\n);\n\n  reg [7:0] din_tmp;\n  reg [3:0] cnt;\n\n  always @(posedge clk or negedge rst_n) begin\n    if(!rst_n) cnt <= 0; \n    else if(din_valid) cnt <= (cnt == 4'd8)? 0 : cnt + 1'b1; \n    else cnt <= 0;\n  end\n\n\n  always @(posedge clk or negedge rst_n) begin\n    if(!rst_n) din_tmp <= 8'b0; \n    else if(din_valid && (cnt <= 4'd7)) din_tmp <= { din_tmp[6:0], din_serial }; \n  end\n\n\n  always @(posedge clk or negedge rst_n) begin\n    if(!rst_n) begin\n      dout_valid <= 1'b0;\n      dout_parallel <= 8'b0;\n    end else if(cnt == 4'd8) begin\n      dout_valid <= 1'b1;\n      dout_parallel <= din_tmp;\n    end else begin\n      dout_valid <= 1'b0;\n    end\n  end\n\n\nendmodule\n\n"}
{"hash": "4e8b4fd20d766b0fe8a9b883bb2dc7428ffe0057721ef32498c326a7969aadcd", "equivalence_group": "4e8b4fd20d766b0fe8a9b883bb2dc7428ffe0057721ef32498c326a7969aadcd", "content": "\n\nmodule verified_signal_generator\n(\n  input clk,\n  input rst_n,\n  output reg [4:0] wave\n);\n\n  reg [1:0] state;\n\n  always @(posedge clk or negedge rst_n) begin\n    if(~rst_n) begin\n      state <= 2'b0;\n      wave <= 5'b0;\n    end else begin\n      case(state)\n        2'b00: begin\n          if(wave == 5'b11111) state <= 2'b01; \n          else wave <= wave + 1;\n        end\n        2'b01: begin\n          if(wave == 5'b00000) state <= 2'b00; \n          else wave <= wave - 1;\n        end\n      endcase\n    end\n  end\n\n\nendmodule\n\n"}
{"hash": "a76f8ca841677823fec8f4b3f348a84a6e80ae626a87b95667e6e757dacce430", "equivalence_group": "a76f8ca841677823fec8f4b3f348a84a6e80ae626a87b95667e6e757dacce430", "content": "\n\nmodule square_wave\n(\n  input clk,\n  input [7:0] freq,\n  output reg wave_out\n);\n\n  reg [7:0] count;\n\n  initial begin\n    wave_out = 0;\n    count = 0;\n  end\n\n\n  always @(posedge clk) begin\n    if(count == freq - 1) begin\n      count <= 0;\n      wave_out <= ~wave_out;\n    end else begin\n      count <= count + 1;\n    end\n  end\n\n\nendmodule\n\n"}
{"hash": "d7b6d57bc47d612ed659041af8babffdf5e4a49ce75f24d2ec275cb911fbf7c7", "equivalence_group": "d7b6d57bc47d612ed659041af8babffdf5e4a49ce75f24d2ec275cb911fbf7c7", "content": "\n\nmodule sub_64bit\n(\n  input [63:0] A,\n  input [63:0] B,\n  output reg [63:0] result,\n  output reg overflow\n);\n\n\n  always @(*) begin\n    result = A - B;\n    if((A[63] != B[63]) && (result[63] != A[63])) begin\n      overflow = 1;\n    end else begin\n      overflow = 0;\n    end\n  end\n\n\nendmodule\n\n"}
{"hash": "8c424adbe5e598499e35377c5a19837dfa3ca174809a5d578d6ffc34c3ccd898", "equivalence_group": "8c424adbe5e598499e35377c5a19837dfa3ca174809a5d578d6ffc34c3ccd898", "content": "\n\nmodule verified_traffic_light\n(\n  input rst_n,\n  input clk,\n  input pass_request,\n  output wire [7:0] clock,\n  output reg red,\n  output reg yellow,\n  output reg green\n);\n\n  parameter idle = 2'd0;\n  parameter s1_red = 2'd1;\n  parameter s2_yellow = 2'd2;\n  parameter s3_green = 2'd3;\n  reg [7:0] cnt;\n  reg [1:0] state;\n  reg p_red;\n  reg p_yellow;\n  reg p_green;\n\n  always @(posedge clk or negedge rst_n) begin\n    if(!rst_n) begin\n      state <= idle;\n      p_red <= 1'b0;\n      p_green <= 1'b0;\n      p_yellow <= 1'b0;\n    end else case(state)\n      idle: begin\n        p_red <= 1'b0;\n        p_green <= 1'b0;\n        p_yellow <= 1'b0;\n        state <= s1_red;\n      end\n      s1_red: begin\n        p_red <= 1'b1;\n        p_green <= 1'b0;\n        p_yellow <= 1'b0;\n        if(cnt == 3) state <= s3_green; \n        else state <= s1_red;\n      end\n      s2_yellow: begin\n        p_red <= 1'b0;\n        p_green <= 1'b0;\n        p_yellow <= 1'b1;\n        if(cnt == 3) state <= s1_red; \n        else state <= s2_yellow;\n      end\n      s3_green: begin\n        p_red <= 1'b0;\n        p_green <= 1'b1;\n        p_yellow <= 1'b0;\n        if(cnt == 3) state <= s2_yellow; \n        else state <= s3_green;\n      end\n    endcase\n  end\n\n\n  always @(posedge clk or negedge rst_n) if(!rst_n) cnt <= 7'd10; \n  else if(pass_request && green && (cnt > 10)) cnt <= 7'd10; \n  else if(!green && p_green) cnt <= 7'd60; \n  else if(!yellow && p_yellow) cnt <= 7'd5; \n  else if(!red && p_red) cnt <= 7'd10; \n  else cnt <= cnt - 1;\n\n  assign clock = cnt;\n\n  always @(posedge clk or negedge rst_n) if(!rst_n) begin\n    yellow <= 1'd0;\n    red <= 1'd0;\n    green <= 1'd0;\n  end else begin\n    yellow <= p_yellow;\n    red <= p_red;\n    green <= p_green;\n  end\n\n\nendmodule\n\n"}
{"hash": "b4024da721d1520d7af1f24beb580cfccad63016571a079b235cccb4abbb6621", "equivalence_group": "b4024da721d1520d7af1f24beb580cfccad63016571a079b235cccb4abbb6621", "content": "\n\nmodule up_down_counter\n(\n  input wire clk,\n  input wire reset,\n  input wire up_down,\n  output reg [15:0] count\n);\n\n\n  always @(posedge clk or posedge reset) begin\n    if(reset) begin\n      count <= 16'b0;\n    end else begin\n      if(up_down) begin\n        if(count == 16'b1111_1111_1111_1111) begin\n          count <= 16'b0;\n        end else begin\n          count <= count + 1;\n        end\n      end else begin\n        if(count == 16'b0) begin\n          count <= 16'b1111_1111_1111_1111;\n        end else begin\n          count <= count - 1;\n        end\n      end\n    end\n  end\n\n\nendmodule\n\n"}
{"hash": "9eb582300ad1ee52bbad5854550a5021aabed7724beef312c0475029e4fae563", "equivalence_group": "9eb582300ad1ee52bbad5854550a5021aabed7724beef312c0475029e4fae563", "content": "\n\nmodule verified_width_8to16\n(\n  input clk,\n  input rst_n,\n  input valid_in,\n  input [7:0] data_in,\n  output reg valid_out,\n  output reg [15:0] data_out\n);\n\n  reg [7:0] data_lock;\n  reg flag;\n\n  always @(posedge clk or negedge rst_n) begin\n    if(!rst_n) data_lock <= 'd0; \n    else if(valid_in && !flag) data_lock <= data_in; \n  end\n\n\n  always @(posedge clk or negedge rst_n) begin\n    if(!rst_n) flag <= 'd0; \n    else if(valid_in) flag <= ~flag; \n  end\n\n\n  always @(posedge clk or negedge rst_n) begin\n    if(!rst_n) valid_out <= 'd0; \n    else if(valid_in && flag) valid_out <= 1'd1; \n    else valid_out <= 'd0;\n  end\n\n\n  always @(posedge clk or negedge rst_n) begin\n    if(!rst_n) data_out <= 'd0; \n    else if(valid_in && flag) data_out <= { data_lock, data_in }; \n  end\n\n\nendmodule\n\n"}
