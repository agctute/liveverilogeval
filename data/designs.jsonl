{"hash": "e216303266d9e0bc33942d76b15b61e596d1d7ca3ba5529e28816dfcefd671fb", "equivalence_group": "e216303266d9e0bc33942d76b15b61e596d1d7ca3ba5529e28816dfcefd671fb", "content": "\n\nmodule dut\n(\n  input clk,\n  input rst_n,\n  output reg [63:0] Q\n);\n\n\n  always @(posedge clk or negedge rst_n) begin\n    if(!rst_n) Q <= 'd0; \n    else if(!Q[0]) Q <= { 1'b1, Q[63:1] }; \n    else Q <= { 1'b0, Q[63:1] };\n  end\n\n\nendmodule\n\n"}
{"hash": "24204c032a2fc45c3bbe99a13e6f23de84e5501abc741cb6b46e86a08c289662", "equivalence_group": "24204c032a2fc45c3bbe99a13e6f23de84e5501abc741cb6b46e86a08c289662", "content": "\n\nmodule dut\n(\n  out,\n  clk,\n  rst\n);\n\n  input clk;\n  input rst;\n  output [3:0] out;\n  reg [3:0] out;\n  wire feedback;\n  assign feedback = ~(out[3] ^ out[2]);\n\n  always @(posedge clk or posedge rst) begin\n    if(rst) out = 4'b0; \n    else out = { out[2:0], feedback };\n  end\n\n\nendmodule\n\n"}
{"hash": "ff195929900c223f00f1dd22aed31c3bcde423fdc9877c5319c811fa2cf340c9", "equivalence_group": "ff195929900c223f00f1dd22aed31c3bcde423fdc9877c5319c811fa2cf340c9", "content": "\n\nmodule dut\n(\n  input [3:0] dataIn,\n  input RW,\n  input EN,\n  input Rst,\n  input Clk,\n  output reg EMPTY,\n  output reg FULL,\n  output reg [3:0] dataOut\n);\n\n  reg [3:0] stack_mem [0:3];\n  reg [2:0] SP;\n  integer i;\n\n  always @(posedge Clk) begin\n    if(EN == 0) begin\n    end else begin\n      if(Rst == 1) begin\n        SP = 3'd4;\n        EMPTY = SP[2];\n        dataOut = 4'h0;\n        for(i=0; i<4; i=i+1) begin\n          stack_mem[i] = 0;\n        end\n      end else if(Rst == 0) begin\n        FULL = (SP)? 0 : 1;\n        EMPTY = SP[2];\n        dataOut = 4'hx;\n        if((FULL == 1'b0) && (RW == 1'b0)) begin\n          SP = SP - 1'b1;\n          FULL = (SP)? 0 : 1;\n          EMPTY = SP[2];\n          stack_mem[SP] = dataIn;\n        end else if((EMPTY == 1'b0) && (RW == 1'b1)) begin\n          dataOut = stack_mem[SP];\n          stack_mem[SP] = 0;\n          SP = SP + 1;\n          FULL = (SP)? 0 : 1;\n          EMPTY = SP[2];\n        end else begin\n        end\n      end else begin\n      end\n    end\n  end\n\n\nendmodule\n\n"}
{"hash": "f5c2e6a28f45240e91ef15d9584cb2ece3618385d46cc90418e170124c749962", "equivalence_group": "f5c2e6a28f45240e91ef15d9584cb2ece3618385d46cc90418e170124c749962", "content": "\n\nmodule dut\n(\n  input clk,\n  input rst_n,\n  input write_en,\n  input [7:0] write_addr,\n  input [5:0] write_data,\n  input read_en,\n  input [7:0] read_addr,\n  output reg [5:0] read_data\n);\n\n  reg [7:0] RAM [11:0];\n  integer i;\n\n  always @(posedge clk or negedge rst_n) begin\n    if(!rst_n) begin\n      for(i=0; i<8; i=i+1) begin\n        RAM[i] <= 'd0;\n      end\n    end else if(write_en) RAM[write_addr] <= write_data; \n  end\n\n\n  always @(posedge clk or negedge rst_n) begin\n    if(!rst_n) read_data <= 'd0; \n    else if(read_en) read_data <= RAM[read_addr]; \n    else read_data <= 'd0;\n  end\n\n\nendmodule\n\n"}
{"hash": "94ebd81b5e954fc904abc9cd520e09c030063954c5b0719683a537d2ed777fdd", "equivalence_group": "94ebd81b5e954fc904abc9cd520e09c030063954c5b0719683a537d2ed777fdd", "content": "\n\nmodule dut\n(\n  input wire [7:0] addr,\n  output reg [15:0] dout\n);\n\n  reg [15:0] mem [0:255];\n\n  initial begin\n    mem[0] = 16'hA0A0;\n    mem[1] = 16'hB1B1;\n    mem[2] = 16'hC2C2;\n    mem[3] = 16'hD3D3;\n  end\n\n\n  always @(*) begin\n    dout = mem[addr];\n  end\n\n\nendmodule\n\n"}
{"hash": "c19f52f4c20f33749d0dc33635b1bd9eaca3c6693582dedeaf2d7774ff043ba7", "equivalence_group": "c19f52f4c20f33749d0dc33635b1bd9eaca3c6693582dedeaf2d7774ff043ba7", "content": "\n\nmodule dut\n(\n  input clk,\n  input rst_n,\n  input [7:0] data_in,\n  input valid_in,\n  output reg valid_out,\n  output reg [9:0] data_out\n);\n\n  reg [1:0] count;\n  wire add_cnt;\n  wire ready_add;\n  wire end_cnt;\n  reg [9:0] data_out_reg;\n  assign add_cnt = ready_add;\n  assign end_cnt = ready_add && (count == 'd3);\n\n  always @(posedge clk or negedge rst_n) begin\n    if(!rst_n) begin\n      count <= 0;\n    end else if(end_cnt) begin\n      count <= 0;\n    end else if(add_cnt) begin\n      count <= count + 1;\n    end \n  end\n\n\n  always @(posedge clk or negedge rst_n) begin\n    if(!rst_n) begin\n      data_out_reg <= 0;\n    end else if(add_cnt && (count == 0)) begin\n      data_out_reg <= data_in;\n    end else if(add_cnt) begin\n      data_out_reg <= data_out_reg + data_in;\n    end \n  end\n\n\n  always @(posedge clk or negedge rst_n) begin\n    if(!rst_n) begin\n      data_out <= 0;\n    end else if(add_cnt && (count == 0)) begin\n      data_out <= data_in;\n    end else if(add_cnt) begin\n      data_out <= data_out + data_in;\n    end \n  end\n\n  assign ready_add = !valid_out | valid_in;\n\n  always @(posedge clk or negedge rst_n) begin\n    if(!rst_n) begin\n      valid_out <= 0;\n    end else if(end_cnt) begin\n      valid_out <= 1;\n    end else begin\n      valid_out <= 0;\n    end\n  end\n\n\nendmodule\n\n"}
{"hash": "60c94eacb5c6b28a95e336bba26a1b59cca911bedc775784297447c3bacf0e00", "equivalence_group": "60c94eacb5c6b28a95e336bba26a1b59cca911bedc775784297447c3bacf0e00", "content": "\n\nmodule dut\n(\n  input wire [15:0] a,\n  input wire [15:0] b,\n  input wire Cin,\n  output wire [15:0] y,\n  output wire Co\n);\n\n  wire Co_temp;\n\n  dut_dependency_2\n  add8_inst1\n  (\n    .a(a[15:8]),\n    .b(b[15:8]),\n    .Cin(Co_temp),\n    .y(y[15:8]),\n    .Co(Co)\n  );\n\n\n  dut_dependency_2\n  add8_inst2\n  (\n    .a(a[7:0]),\n    .b(b[7:0]),\n    .Cin(Cin),\n    .y(y[7:0]),\n    .Co(Co_temp)\n  );\n\n\nendmodule\n\n\n\nmodule dut_dependency_2\n(\n  input wire [7:0] a,\n  input wire [7:0] b,\n  input wire Cin,\n  output wire [7:0] y,\n  output wire Co\n);\n\n  wire Co_temp;\n\n  dut_dependency_3\n  add4_inst1\n  (\n    .a(a[7:4]),\n    .b(b[7:4]),\n    .Cin(Co_temp),\n    .y(y[7:4]),\n    .Co(Co)\n  );\n\n\n  dut_dependency_3\n  add4_inst2\n  (\n    .a(a[3:0]),\n    .b(b[3:0]),\n    .Cin(Cin),\n    .y(y[3:0]),\n    .Co(Co_temp)\n  );\n\n\nendmodule\n\n\n\nmodule dut_dependency_3\n(\n  input wire [3:0] a,\n  input wire [3:0] b,\n  input wire Cin,\n  output wire [3:0] y,\n  output wire Co\n);\n\n  wire Co_temp;\n\n  dut_dependency_4\n  add2_inst1\n  (\n    .a(a[3:2]),\n    .b(b[3:2]),\n    .Cin(Co_temp),\n    .y(y[3:2]),\n    .Co(Co)\n  );\n\n\n  dut_dependency_4\n  add2_inst2\n  (\n    .a(a[1:0]),\n    .b(b[1:0]),\n    .Cin(Cin),\n    .y(y[1:0]),\n    .Co(Co_temp)\n  );\n\n\nendmodule\n\n\n\nmodule dut_dependency_4\n(\n  input wire [1:0] a,\n  input wire [1:0] b,\n  input wire Cin,\n  output wire [1:0] y,\n  output wire Co\n);\n\n  wire Co_temp;\n\n  dut_dependency_5\n  add1_inst1\n  (\n    .a(a[1]),\n    .b(b[1]),\n    .Cin(Co_temp),\n    .y(y[1]),\n    .Co(Co)\n  );\n\n\n  dut_dependency_5\n  add1_inst2\n  (\n    .a(a[0]),\n    .b(b[0]),\n    .Cin(Cin),\n    .y(y[0]),\n    .Co(Co_temp)\n  );\n\n\nendmodule\n\n\n\nmodule dut_dependency_5\n(\n  input wire a,\n  input wire b,\n  input wire Cin,\n  output wire y,\n  output wire Co\n);\n\n  assign y = ~a & ~b & Cin | ~a & b & ~Cin | a & ~b & ~Cin | a & b & Cin;\n  assign Co = ~a & b & Cin | a & ~b & Cin | a & b & ~Cin | a & b & Cin;\n\nendmodule\n\n"}
{"hash": "0adfa3bb562509732dc7878a442bd0b6be3919777d59e3046cc6a0d2ff177a52", "equivalence_group": "0adfa3bb562509732dc7878a442bd0b6be3919777d59e3046cc6a0d2ff177a52", "content": "\n\nmodule dut\n(\n  input [7:0] a,\n  input [7:0] b,\n  input cin,\n  output [7:0] sum,\n  output cout\n);\n\n  wire [8:0] c;\n\n  dut_dependency_2\n  FA0\n  (\n    .a(a[0]),\n    .b(b[0]),\n    .cin(cin),\n    .sum(sum[0]),\n    .cout(c[0])\n  );\n\n\n  dut_dependency_2\n  FA1\n  (\n    .a(a[1]),\n    .b(b[1]),\n    .cin(c[0]),\n    .sum(sum[1]),\n    .cout(c[1])\n  );\n\n\n  dut_dependency_2\n  FA2\n  (\n    .a(a[2]),\n    .b(b[2]),\n    .cin(c[1]),\n    .sum(sum[2]),\n    .cout(c[2])\n  );\n\n\n  dut_dependency_2\n  FA3\n  (\n    .a(a[3]),\n    .b(b[3]),\n    .cin(c[2]),\n    .sum(sum[3]),\n    .cout(c[3])\n  );\n\n\n  dut_dependency_2\n  FA4\n  (\n    .a(a[4]),\n    .b(b[4]),\n    .cin(c[3]),\n    .sum(sum[4]),\n    .cout(c[4])\n  );\n\n\n  dut_dependency_2\n  FA5\n  (\n    .a(a[5]),\n    .b(b[5]),\n    .cin(c[4]),\n    .sum(sum[5]),\n    .cout(c[5])\n  );\n\n\n  dut_dependency_2\n  FA6\n  (\n    .a(a[6]),\n    .b(b[6]),\n    .cin(c[5]),\n    .sum(sum[6]),\n    .cout(c[6])\n  );\n\n\n  dut_dependency_2\n  FA7\n  (\n    .a(a[7]),\n    .b(b[7]),\n    .cin(c[6]),\n    .sum(sum[7]),\n    .cout(c[7])\n  );\n\n  assign cout = c[7];\n\nendmodule\n\n\n\nmodule dut_dependency_2\n(\n  input a,\n  input b,\n  input cin,\n  output sum,\n  output cout\n);\n\n  assign { cout, sum } = a + b + cin;\n\nendmodule\n\n"}
{"hash": "7a3e67fb44afd96ae21c804789fc22e00264e3bf660a6bf810fd5c103432e3ef", "equivalence_group": "7a3e67fb44afd96ae21c804789fc22e00264e3bf660a6bf810fd5c103432e3ef", "content": "\n\nmodule dut\n(\n  input [3:0] A,\n  input [3:0] B,\n  input Cin,\n  output [3:0] Sum,\n  output Cout\n);\n\n  wire [4:0] temp_sum;\n  wire [3:0] corrected_sum;\n  wire carry_out;\n  assign temp_sum = A + B + Cin;\n  assign carry_out = (temp_sum > 9)? 1 : 0;\n  assign corrected_sum = (temp_sum > 9)? temp_sum + 4'b0110 : temp_sum;\n  assign Sum = corrected_sum[3:0];\n  assign Cout = carry_out;\n\nendmodule\n\n"}
{"hash": "72c4dbab265ac89f684ebb58f733fadbe0b96f2795079bab7513b87dfe54473d", "equivalence_group": "72c4dbab265ac89f684ebb58f733fadbe0b96f2795079bab7513b87dfe54473d", "content": "\n\nmodule dut\n(\n  input [31:0] a,\n  input [31:0] b,\n  input [5:0] aluc,\n  output [31:0] r,\n  output zero,\n  output carry,\n  output negative,\n  output overflow,\n  output flag\n);\n\n  parameter ADD = 6'b100000;\n  parameter ADDU = 6'b100001;\n  parameter SUB = 6'b100010;\n  parameter SUBU = 6'b100011;\n  parameter AND = 6'b100100;\n  parameter OR = 6'b100101;\n  parameter XOR = 6'b100110;\n  parameter NOR = 6'b100111;\n  parameter SLT = 6'b101010;\n  parameter SLTU = 6'b101011;\n  parameter SLL = 6'b000000;\n  parameter SRL = 6'b000010;\n  parameter SRA = 6'b000011;\n  parameter SLLV = 6'b000100;\n  parameter SRLV = 6'b000110;\n  parameter SRAV = 6'b000111;\n  parameter JR = 6'b001000;\n  parameter LUI = 6'b001111;\n  wire signed [31:0] a_signed;\n  wire signed [31:0] b_signed;\n  reg [32:0] res;\n  assign a_signed = a;\n  assign b_signed = b;\n  assign r = res[31:0];\n  assign flag = ((aluc == SLT) || (aluc == SLTU))? (aluc == SLT)? a_signed < b_signed : a < b : 1'bz;\n  assign zero = (res == 32'b0)? 1'b1 : 1'b0;\n\n  always @(a or b or aluc) begin\n    case(aluc)\n      ADD: begin\n        res <= a_signed + b_signed;\n      end\n      ADDU: begin\n        res <= a + b;\n      end\n      SUB: begin\n        res <= a_signed - b_signed;\n      end\n      SUBU: begin\n        res <= a - b;\n      end\n      AND: begin\n        res <= a & b;\n      end\n      OR: begin\n        res <= a | b;\n      end\n      XOR: begin\n        res <= a ^ b;\n      end\n      NOR: begin\n        res <= ~(a | b);\n      end\n      SLT: begin\n        res <= (a_signed < b_signed)? 1 : 0;\n      end\n      SLTU: begin\n        res <= (a < b)? 1 : 0;\n      end\n      SLL: begin\n        res <= b << a;\n      end\n      SRL: begin\n        res <= b >> a;\n      end\n      SRA: begin\n        res <= b_signed >>> a_signed;\n      end\n      SLLV: begin\n        res <= b << a[4:0];\n      end\n      SRLV: begin\n        res <= b >> a[4:0];\n      end\n      SRAV: begin\n        res <= b_signed >>> a_signed[4:0];\n      end\n      LUI: begin\n        res <= { a[15:0], 16'h0000 };\n      end\n      default: begin\n        res <= 32'bz;\n      end\n    endcase\n  end\n\n\nendmodule\n\n"}
{"hash": "309a00e7512d54626baeb389ebab05c39adef1d923c7de28ed4848cbcfac7ecc", "equivalence_group": "309a00e7512d54626baeb389ebab05c39adef1d923c7de28ed4848cbcfac7ecc", "content": "\n\nmodule dut #\n(\n  parameter DEPTH = 16,\n  parameter WIDTH = 8\n)\n(\n  input wclk,\n  input wenc,\n  input [$clog2(DEPTH)-1:0] waddr,\n  input [WIDTH-1:0] wdata,\n  input rclk,\n  input renc,\n  input [$clog2(DEPTH)-1:0] raddr,\n  output reg [WIDTH-1:0] rdata\n);\n\n  reg [WIDTH-1:0] RAM_MEM [0:DEPTH-1];\n\n  always @(posedge wclk) begin\n    if(wenc) RAM_MEM[waddr] <= wdata; \n  end\n\n\n  always @(posedge rclk) begin\n    if(renc) rdata <= RAM_MEM[raddr]; \n  end\n\n\nendmodule\n\n\n\nmodule dut_dependency_2 #\n(\n  parameter WIDTH = 8,\n  parameter DEPTH = 16\n)\n(\n  input wclk,\n  input rclk,\n  input wrstn,\n  input rrstn,\n  input winc,\n  input rinc,\n  input [WIDTH-1:0] wdata,\n  output wire wfull,\n  output wire rempty,\n  output wire [WIDTH-1:0] rdata\n);\n\n  parameter ADDR_WIDTH = $clog2(DEPTH);\n  reg [ADDR_WIDTH:0] waddr_bin;\n  reg [ADDR_WIDTH:0] raddr_bin;\n\n  always @(posedge wclk or negedge wrstn) begin\n    if(~wrstn) begin\n      waddr_bin <= 'd0;\n    end else if(!wfull && winc) begin\n      waddr_bin <= waddr_bin + 1'd1;\n    end \n  end\n\n\n  always @(posedge rclk or negedge rrstn) begin\n    if(~rrstn) begin\n      raddr_bin <= 'd0;\n    end else if(!rempty && rinc) begin\n      raddr_bin <= raddr_bin + 1'd1;\n    end \n  end\n\n  wire [ADDR_WIDTH:0] waddr_gray;\n  wire [ADDR_WIDTH:0] raddr_gray;\n  reg [ADDR_WIDTH:0] wptr;\n  reg [ADDR_WIDTH:0] rptr;\n  assign waddr_gray = waddr_bin ^ (waddr_bin >> 1);\n  assign raddr_gray = raddr_bin ^ (raddr_bin >> 1);\n\n  always @(posedge wclk or negedge wrstn) begin\n    if(~wrstn) begin\n      wptr <= 'd0;\n    end else begin\n      wptr <= waddr_gray;\n    end\n  end\n\n\n  always @(posedge rclk or negedge rrstn) begin\n    if(~rrstn) begin\n      rptr <= 'd0;\n    end else begin\n      rptr <= raddr_gray;\n    end\n  end\n\n  reg [ADDR_WIDTH:0] wptr_buff;\n  reg [ADDR_WIDTH:0] wptr_syn;\n  reg [ADDR_WIDTH:0] rptr_buff;\n  reg [ADDR_WIDTH:0] rptr_syn;\n\n  always @(posedge wclk or negedge wrstn) begin\n    if(~wrstn) begin\n      rptr_buff <= 'd0;\n      rptr_syn <= 'd0;\n    end else begin\n      rptr_buff <= rptr;\n      rptr_syn <= rptr_buff;\n    end\n  end\n\n\n  always @(posedge rclk or negedge rrstn) begin\n    if(~rrstn) begin\n      wptr_buff <= 'd0;\n      wptr_syn <= 'd0;\n    end else begin\n      wptr_buff <= wptr;\n      wptr_syn <= wptr_buff;\n    end\n  end\n\n  assign wfull = wptr == { ~rptr_syn[ADDR_WIDTH:ADDR_WIDTH-1], rptr_syn[ADDR_WIDTH-2:0] };\n  assign rempty = rptr == wptr_syn;\n  wire wen;\n  wire ren;\n  wire wren;\n  wire [ADDR_WIDTH-1:0] waddr;\n  wire [ADDR_WIDTH-1:0] raddr;\n  assign wen = winc & !wfull;\n  assign ren = rinc & !rempty;\n  assign waddr = waddr_bin[ADDR_WIDTH-1:0];\n  assign raddr = raddr_bin[ADDR_WIDTH-1:0];\n\n  dut\n  #(\n    .DEPTH(DEPTH),\n    .WIDTH(WIDTH)\n  )\n  dut\n  (\n    .wclk(wclk),\n    .wenc(wen),\n    .waddr(waddr[ADDR_WIDTH-1:0]),\n    .wdata(wdata),\n    .rclk(rclk),\n    .renc(ren),\n    .raddr(raddr[ADDR_WIDTH-1:0]),\n    .rdata(rdata)\n  );\n\n\nendmodule\n\n"}
{"hash": "1703d1522d45ae48c5d5561e230cbef2eade0a5da1e21608b5eb90a647a8a1e6", "equivalence_group": "1703d1522d45ae48c5d5561e230cbef2eade0a5da1e21608b5eb90a647a8a1e6", "content": "\n\nmodule dut\n(\n  in,\n  ctrl,\n  out\n);\n\n  input [7:0] in;\n  input [2:0] ctrl;\n  output [7:0] out;\n  wire [7:0] x;\n  wire [7:0] y;\n\n  dut_dependency_2\n  ins_17\n  (\n    .in0(in[7]),\n    .in1(1'b0),\n    .sel(ctrl[2]),\n    .out(x[7])\n  );\n\n\n  dut_dependency_2\n  ins_16\n  (\n    .in0(in[6]),\n    .in1(1'b0),\n    .sel(ctrl[2]),\n    .out(x[6])\n  );\n\n\n  dut_dependency_2\n  ins_15\n  (\n    .in0(in[5]),\n    .in1(1'b0),\n    .sel(ctrl[2]),\n    .out(x[5])\n  );\n\n\n  dut_dependency_2\n  ins_14\n  (\n    .in0(in[4]),\n    .in1(1'b0),\n    .sel(ctrl[2]),\n    .out(x[4])\n  );\n\n\n  dut_dependency_2\n  ins_13\n  (\n    .in0(in[3]),\n    .in1(in[7]),\n    .sel(ctrl[2]),\n    .out(x[3])\n  );\n\n\n  dut_dependency_2\n  ins_12\n  (\n    .in0(in[2]),\n    .in1(in[6]),\n    .sel(ctrl[2]),\n    .out(x[2])\n  );\n\n\n  dut_dependency_2\n  ins_11\n  (\n    .in0(in[1]),\n    .in1(in[5]),\n    .sel(ctrl[2]),\n    .out(x[1])\n  );\n\n\n  dut_dependency_2\n  ins_10\n  (\n    .in0(in[0]),\n    .in1(in[4]),\n    .sel(ctrl[2]),\n    .out(x[0])\n  );\n\n\n  dut_dependency_2\n  ins_27\n  (\n    .in0(x[7]),\n    .in1(1'b0),\n    .sel(ctrl[1]),\n    .out(y[7])\n  );\n\n\n  dut_dependency_2\n  ins_26\n  (\n    .in0(x[6]),\n    .in1(1'b0),\n    .sel(ctrl[1]),\n    .out(y[6])\n  );\n\n\n  dut_dependency_2\n  ins_25\n  (\n    .in0(x[5]),\n    .in1(x[7]),\n    .sel(ctrl[1]),\n    .out(y[5])\n  );\n\n\n  dut_dependency_2\n  ins_24\n  (\n    .in0(x[4]),\n    .in1(x[6]),\n    .sel(ctrl[1]),\n    .out(y[4])\n  );\n\n\n  dut_dependency_2\n  ins_23\n  (\n    .in0(x[3]),\n    .in1(x[5]),\n    .sel(ctrl[1]),\n    .out(y[3])\n  );\n\n\n  dut_dependency_2\n  ins_22\n  (\n    .in0(x[2]),\n    .in1(x[4]),\n    .sel(ctrl[1]),\n    .out(y[2])\n  );\n\n\n  dut_dependency_2\n  ins_21\n  (\n    .in0(x[1]),\n    .in1(x[3]),\n    .sel(ctrl[1]),\n    .out(y[1])\n  );\n\n\n  dut_dependency_2\n  ins_20\n  (\n    .in0(x[0]),\n    .in1(x[2]),\n    .sel(ctrl[1]),\n    .out(y[0])\n  );\n\n\n  dut_dependency_2\n  ins_07\n  (\n    .in0(y[7]),\n    .in1(1'b0),\n    .sel(ctrl[0]),\n    .out(out[7])\n  );\n\n\n  dut_dependency_2\n  ins_06\n  (\n    .in0(y[6]),\n    .in1(y[7]),\n    .sel(ctrl[0]),\n    .out(out[6])\n  );\n\n\n  dut_dependency_2\n  ins_05\n  (\n    .in0(y[5]),\n    .in1(y[6]),\n    .sel(ctrl[0]),\n    .out(out[5])\n  );\n\n\n  dut_dependency_2\n  ins_04\n  (\n    .in0(y[4]),\n    .in1(y[5]),\n    .sel(ctrl[0]),\n    .out(out[4])\n  );\n\n\n  dut_dependency_2\n  ins_03\n  (\n    .in0(y[3]),\n    .in1(y[4]),\n    .sel(ctrl[0]),\n    .out(out[3])\n  );\n\n\n  dut_dependency_2\n  ins_02\n  (\n    .in0(y[2]),\n    .in1(y[3]),\n    .sel(ctrl[0]),\n    .out(out[2])\n  );\n\n\n  dut_dependency_2\n  ins_01\n  (\n    .in0(y[1]),\n    .in1(y[2]),\n    .sel(ctrl[0]),\n    .out(out[1])\n  );\n\n\n  dut_dependency_2\n  ins_00\n  (\n    .in0(y[0]),\n    .in1(y[1]),\n    .sel(ctrl[0]),\n    .out(out[0])\n  );\n\n\nendmodule\n\n\n\nmodule dut_dependency_2\n(\n  in0,\n  in1,\n  sel,\n  out\n);\n\n  input in0;\n  input in1;\n  input sel;\n  output out;\n  assign out = (sel)? in1 : in0;\n\nendmodule\n\n"}
{"hash": "97ba20e142ef655fc24b281d5331e9e82e0fc561fd45155b5c7b78ebc0250b43", "equivalence_group": "97ba20e142ef655fc24b281d5331e9e82e0fc561fd45155b5c7b78ebc0250b43", "content": "\n\nmodule dut\n(\n  CLK,\n  RST,\n  Hours,\n  Mins,\n  Secs\n);\n\n  input CLK;\n  input RST;\n  output [5:0] Hours;\n  output [5:0] Mins;\n  output [5:0] Secs;\n  reg [5:0] Hours;\n  reg [5:0] Mins;\n  reg [5:0] Secs;\n\n  always @(posedge CLK or posedge RST) begin\n    if(RST) Secs <= 0; \n    else if(Secs == 59) Secs <= 0; \n    else Secs <= Secs + 1;\n  end\n\n\n  always @(posedge CLK or posedge RST) begin\n    if(RST) Mins <= 0; \n    else if((Mins == 59) && (Secs == 59)) Mins <= 0; \n    else if(Secs == 59) Mins <= Mins + 1; \n    else Mins <= Mins;\n  end\n\n\n  always @(posedge CLK or posedge RST) begin\n    if(RST) Hours <= 0; \n    else if((Hours == 23) && (Mins == 59) && (Secs == 59)) Hours <= 0; \n    else if((Mins == 59) && (Secs == 59)) Hours <= Hours + 1; \n    else Hours <= Hours;\n  end\n\n\nendmodule\n\n"}
{"hash": "a9708cae084b3ba95148741402bb9ce93feab12addae0c4c6133e44070c82a7f", "equivalence_group": "a9708cae084b3ba95148741402bb9ce93feab12addae0c4c6133e44070c82a7f", "content": "\n\nmodule dut\n(\n  output reg clk\n);\n\n  parameter PERIOD = 10;\n\n  initial begin\n    clk = 0;\n  end\n\n\n  always @(*) begin\n    #(PERIOD / 2) clk = ~clk;\n  end\n\n\nendmodule\n\n"}
{"hash": "22fd77efb78830758060bcf1570cf0b4c94fd2e9397d72826e7c9a75a49348a2", "equivalence_group": "22fd77efb78830758060bcf1570cf0b4c94fd2e9397d72826e7c9a75a49348a2", "content": "\n\nmodule dut\n(\n  input [2:0] A,\n  input [2:0] B,\n  output A_greater,\n  output A_equal,\n  output A_less\n);\n\n  assign A_greater = (A > B)? 1'b1 : 1'b0;\n  assign A_equal = (A == B)? 1'b1 : 1'b0;\n  assign A_less = (A < B)? 1'b1 : 1'b0;\n\nendmodule\n\n"}
{"hash": "84bf17ef6f16e7defed41b127844313780d62a318f5c0178096912540e5fbe8e", "equivalence_group": "84bf17ef6f16e7defed41b127844313780d62a318f5c0178096912540e5fbe8e", "content": "\n\nmodule dut\n(\n  input [3:0] A,\n  input [3:0] B,\n  output A_greater,\n  output A_equal,\n  output A_less\n);\n\n  wire [3:0] diff;\n  wire cout;\n  assign { cout, diff } = A - B;\n  assign A_greater = ~cout && (diff != 4'b0000);\n  assign A_equal = A == B;\n  assign A_less = cout;\n\nendmodule\n\n"}
{"hash": "cf6d732d914dce9950207dfbb4e70b3663489c36db6fb71446b170b37da4ec22", "equivalence_group": "cf6d732d914dce9950207dfbb4e70b3663489c36db6fb71446b170b37da4ec22", "content": "\n\nmodule dut\n(\n  input rst_n,\n  input clk,\n  input valid_count,\n  output reg [3:0] out\n);\n\n\n  always @(posedge clk or negedge rst_n) begin\n    if(!rst_n) begin\n      out <= 4'b0000;\n    end else if(valid_count) begin\n      if(out == 4'd11) begin\n        out <= 4'b0000;\n      end else begin\n        out <= out + 1;\n      end\n    end else begin\n      out <= out;\n    end\n  end\n\n\nendmodule\n\n"}
{"hash": "e533c1abeec346766bf0d979f9947ffabb64cb25a2af740d39316f8bde76ebd0", "equivalence_group": "e533c1abeec346766bf0d979f9947ffabb64cb25a2af740d39316f8bde76ebd0", "content": "\n\nmodule dut\n(\n  input wire [15:0] A,\n  input wire [7:0] B,\n  output wire [15:0] result,\n  output wire [15:0] odd\n);\n\n  reg [15:0] a_reg;\n  reg [15:0] b_reg;\n  reg [31:0] tmp_a;\n  reg [31:0] tmp_b;\n  integer i;\n\n  always @(*) begin\n    a_reg = A;\n    b_reg = B;\n  end\n\n\n  always @(*) begin\n    begin\n      tmp_a = { 16'b0, a_reg };\n      tmp_b = { b_reg, 16'b0 };\n      for(i=0; i<16; i=i+1) begin\n        tmp_a = tmp_a << 1;\n        if(tmp_a >= tmp_b) begin\n          tmp_a = tmp_a - tmp_b + 1;\n        end else begin\n          tmp_a = tmp_a;\n        end\n      end\n    end\n  end\n\n  assign odd = tmp_a[31:16];\n  assign result = tmp_a[15:0];\n\nendmodule\n\n"}
{"hash": "2bf8f0e4d1e361ef28c324970de297ab0140b07ca9ef59522902c5ffc7e361df", "equivalence_group": "2bf8f0e4d1e361ef28c324970de297ab0140b07ca9ef59522902c5ffc7e361df", "content": "\n\nmodule dut\n(\n  input clk,\n  input rst_n,\n  input a,\n  output reg rise,\n  output reg down\n);\n\n  reg a0;\n\n  always @(posedge clk or negedge rst_n) begin\n    if(~rst_n) begin\n      rise <= 1'b0;\n      down <= 1'b0;\n    end else begin\n      if(a & ~a0) begin\n        rise <= 1;\n        down <= 0;\n      end else if(~a & a0) begin\n        rise <= 0;\n        down <= 1;\n      end else begin\n        rise <= 0;\n        down <= 0;\n      end\n    end\n  end\n\n\n  always @(posedge clk or negedge rst_n) begin\n    if(~rst_n) a0 <= 0; \n    else a0 <= a;\n  end\n\n\nendmodule\n\n"}
{"hash": "6404a252500eb2a4c7f60f1069e1ab161eb9502076ac816954e84ced64b72e4c", "equivalence_group": "6404a252500eb2a4c7f60f1069e1ab161eb9502076ac816954e84ced64b72e4c", "content": "\n\nmodule dut #\n(\n  parameter Q = 15,\n  parameter N = 32\n)\n(\n  input [N-1:0] a,\n  input [N-1:0] b,\n  output [N-1:0] c\n);\n\n  reg [N-1:0] res;\n  assign c = res;\n\n  always @(a or b) begin\n    if(a[N - 1] == b[N - 1]) begin\n      res[N-2:0] = a[N-2:0] + b[N-2:0];\n      res[N - 1] = a[N - 1];\n    end else if((a[N - 1] == 0) && (b[N - 1] == 1)) begin\n      if(a[N-2:0] > b[N-2:0]) begin\n        res[N-2:0] = a[N-2:0] - b[N-2:0];\n        res[N - 1] = 0;\n      end else begin\n        res[N-2:0] = b[N-2:0] - a[N-2:0];\n        if(res[N-2:0] == 0) res[N - 1] = 0; \n        else res[N - 1] = 1;\n      end\n    end else begin\n      if(a[N-2:0] > b[N-2:0]) begin\n        res[N-2:0] = a[N-2:0] - b[N-2:0];\n        if(res[N-2:0] == 0) res[N - 1] = 0; \n        else res[N - 1] = 1;\n      end else begin\n        res[N-2:0] = b[N-2:0] - a[N-2:0];\n        res[N - 1] = 0;\n      end\n    end\n  end\n\n\nendmodule\n\n"}
{"hash": "439da280c8cdef6847cb401f027c138813a40b95dcb294592925c9fe7fc31d8d", "equivalence_group": "439da280c8cdef6847cb401f027c138813a40b95dcb294592925c9fe7fc31d8d", "content": "\n\nmodule dut #\n(\n  parameter Q = 15,\n  parameter N = 32\n)\n(\n  input [N-1:0] a,\n  input [N-1:0] b,\n  output [N-1:0] c\n);\n\n  reg [N-1:0] res;\n  assign c = res;\n\n  always @(a or b) begin\n    if(a[N - 1] == b[N - 1]) begin\n      res[N-2:0] = a[N-2:0] - b[N-2:0];\n      res[N - 1] = a[N - 1];\n    end else if((a[N - 1] == 0) && (b[N - 1] == 1)) begin\n      if(a[N-2:0] > b[N-2:0]) begin\n        res[N-2:0] = a[N-2:0] + b[N-2:0];\n        res[N - 1] = 0;\n      end else begin\n        res[N-2:0] = b[N-2:0] + a[N-2:0];\n        if(res[N-2:0] == 0) res[N - 1] = 0; \n        else res[N - 1] = 1;\n      end\n    end else begin\n      if(a[N-2:0] > b[N-2:0]) begin\n        res[N-2:0] = a[N-2:0] + b[N-2:0];\n        if(res[N-2:0] == 0) res[N - 1] = 0; \n        else res[N - 1] = 1;\n      end else begin\n        res[N-2:0] = b[N-2:0] + a[N-2:0];\n        res[N - 1] = 0;\n      end\n    end\n  end\n\n\nendmodule\n\n"}
{"hash": "6bc1cef49b5928510a344bf0fabd403cfd0fb07dfc795e993724098de0f42eb3", "equivalence_group": "6bc1cef49b5928510a344bf0fabd403cfd0fb07dfc795e993724098de0f42eb3", "content": "\n\nmodule dut\n(\n  CLK_in,\n  CLK_50,\n  CLK_10,\n  CLK_1,\n  RST\n);\n\n  input CLK_in;\n  input RST;\n  output CLK_50;\n  reg CLK_50;\n  output CLK_10;\n  reg CLK_10;\n  output CLK_1;\n  reg CLK_1;\n  reg [3:0] cnt_10;\n  reg [6:0] cnt_100;\n\n  always @(posedge CLK_in or posedge RST) begin\n    if(RST) begin\n      CLK_50 <= 1'b0;\n    end else begin\n      CLK_50 <= ~CLK_50;\n    end\n  end\n\n\n  always @(posedge CLK_in or posedge RST) begin\n    if(RST) begin\n      CLK_10 <= 1'b0;\n      cnt_10 <= 0;\n    end else if(cnt_10 == 4) begin\n      CLK_10 <= ~CLK_10;\n      cnt_10 <= 0;\n    end else begin\n      cnt_10 <= cnt_10 + 1;\n    end\n  end\n\n\n  always @(posedge CLK_in or posedge RST) begin\n    if(RST) begin\n      CLK_1 <= 1'b0;\n      cnt_100 <= 0;\n    end else if(cnt_100 == 49) begin\n      CLK_1 <= ~CLK_1;\n      cnt_100 <= 0;\n    end else begin\n      cnt_100 <= cnt_100 + 1;\n    end\n  end\n\n\nendmodule\n\n"}
{"hash": "fc8540caba6e4a290497eab08ca38f569c52f9331b4da8a7b48a0f273a94de32", "equivalence_group": "fc8540caba6e4a290497eab08ca38f569c52f9331b4da8a7b48a0f273a94de32", "content": "\n\nmodule dut\n(\n  clk,\n  rst_n,\n  clk_div\n);\n\n  input clk;\n  input rst_n;\n  output clk_div;\n  reg clk_div;\n  parameter NUM_DIV = 6;\n  reg [3:0] cnt;\n\n  always @(posedge clk or negedge rst_n) if(!rst_n) begin\n    cnt <= 4'd0;\n    clk_div <= 1'b0;\n  end else if(cnt < NUM_DIV / 2 - 1) begin\n    cnt <= cnt + 1'b1;\n    clk_div <= clk_div;\n  end else begin\n    cnt <= 4'd0;\n    clk_div <= ~clk_div;\n  end\n\n\nendmodule\n\n"}
{"hash": "984a5a7427f1fee1882c0c85cef2cc9f22f30f7d0fb1865fd557369f5a759514", "equivalence_group": "984a5a7427f1fee1882c0c85cef2cc9f22f30f7d0fb1865fd557369f5a759514", "content": "\n\nmodule dut\n(\n  input rst_n,\n  input clk,\n  output clk_div\n);\n\n  parameter MUL2_DIV_CLK = 7;\n  reg [3:0] cnt;\n\n  always @(posedge clk or negedge rst_n) begin\n    if(!rst_n) begin\n      cnt <= 'b0;\n    end else if(cnt == MUL2_DIV_CLK - 1) begin\n      cnt <= 'b0;\n    end else begin\n      cnt <= cnt + 1'b1;\n    end\n  end\n\n  reg clk_ave_r;\n\n  always @(posedge clk or negedge rst_n) begin\n    if(!rst_n) begin\n      clk_ave_r <= 1'b0;\n    end else if(cnt == 0) begin\n      clk_ave_r <= 1;\n    end else if(cnt == MUL2_DIV_CLK / 2 + 1) begin\n      clk_ave_r <= 1;\n    end else begin\n      clk_ave_r <= 0;\n    end\n  end\n\n  reg clk_adjust_r;\n\n  always @(negedge clk or negedge rst_n) begin\n    if(!rst_n) begin\n      clk_adjust_r <= 1'b0;\n    end else if(cnt == 1) begin\n      clk_adjust_r <= 1;\n    end else if(cnt == MUL2_DIV_CLK / 2 + 1) begin\n      clk_adjust_r <= 1;\n    end else begin\n      clk_adjust_r <= 0;\n    end\n  end\n\n  assign clk_div = clk_adjust_r | clk_ave_r;\n\nendmodule\n\n"}
{"hash": "0ca2f5bd1674a3b08d0091b1eaff9d5ff8270fec725b8227c7acf7d004080c75", "equivalence_group": "0ca2f5bd1674a3b08d0091b1eaff9d5ff8270fec725b8227c7acf7d004080c75", "content": "\n\nmodule dut\n(\n  clk,\n  rst_n,\n  clk_div\n);\n\n  input clk;\n  input rst_n;\n  output clk_div;\n  reg clk_div;\n  parameter NUM_DIV = 5;\n  reg [2:0] cnt1;\n  reg [2:0] cnt2;\n  reg clk_div1;\n  reg clk_div2;\n\n  always @(posedge clk or negedge rst_n) if(!rst_n) cnt1 <= 0; \n  else if(cnt1 < NUM_DIV - 1) cnt1 <= cnt1 + 1'b1; \n  else cnt1 <= 0;\n\n\n  always @(posedge clk or negedge rst_n) if(!rst_n) clk_div1 <= 1'b1; \n  else if(cnt1 < NUM_DIV / 2) clk_div1 <= 1'b1; \n  else clk_div1 <= 1'b0;\n\n\n  always @(negedge clk or negedge rst_n) if(!rst_n) cnt2 <= 0; \n  else if(cnt2 < NUM_DIV - 1) cnt2 <= cnt2 + 1'b1; \n  else cnt2 <= 0;\n\n\n  always @(negedge clk or negedge rst_n) if(!rst_n) clk_div2 <= 1'b1; \n  else if(cnt2 < NUM_DIV / 2) clk_div2 <= 1'b1; \n  else clk_div2 <= 1'b0;\n\n  assign clk_div = clk_div1 | clk_div2;\n\nendmodule\n\n"}
{"hash": "f2b185466c76bbec81847cc1522e23f31d5e0cf512da586ecc49ef8962f923e9", "equivalence_group": "f2b185466c76bbec81847cc1522e23f31d5e0cf512da586ecc49ef8962f923e9", "content": "\n\nmodule dut\n(\n  IN,\n  MATCH,\n  CLK,\n  RST\n);\n\n  input IN;\n  input CLK;\n  input RST;\n  output MATCH;\n  reg MATCH;\n  reg [2:0] ST_cr;\n  reg [2:0] ST_nt;\n  parameter s0 = 3'b000;\n  parameter s1 = 3'b001;\n  parameter s2 = 3'b010;\n  parameter s3 = 3'b011;\n  parameter s4 = 3'b100;\n  parameter s5 = 3'b101;\n\n  always @(posedge CLK or posedge RST) begin\n    if(RST) ST_cr <= s0; \n    else ST_cr <= ST_nt;\n  end\n\n\n  always @(*) begin\n    case(ST_cr)\n      s0: begin\n        if(IN == 0) ST_nt = s0; \n        else ST_nt = s1;\n      end\n      s1: begin\n        if(IN == 0) ST_nt = s2; \n        else ST_nt = s1;\n      end\n      s2: begin\n        if(IN == 0) ST_nt = s3; \n        else ST_nt = s1;\n      end\n      s3: begin\n        if(IN == 0) ST_nt = s0; \n        else ST_nt = s4;\n      end\n      s4: begin\n        if(IN == 0) ST_nt = s2; \n        else ST_nt = s5;\n      end\n      s5: begin\n        if(IN == 0) ST_nt = s2; \n        else ST_nt = s1;\n      end\n    endcase\n  end\n\n\n  always @(*) begin\n    if(RST) MATCH <= 0; \n    else if((ST_cr == s4) && (IN == 1)) MATCH <= 1; \n    else MATCH <= 0;\n  end\n\n\nendmodule\n\n"}
{"hash": "940976e243bc80d973e32cfc2260f0c5b61b8e3ffbdaa8ca6b3e8398ca88f990", "equivalence_group": "940976e243bc80d973e32cfc2260f0c5b61b8e3ffbdaa8ca6b3e8398ca88f990", "content": "\n\nmodule dut\n(\n  input clk,\n  input rst,\n  input [1:0] fetch,\n  input [7:0] data,\n  output [2:0] ins,\n  output [4:0] ad1,\n  output [7:0] ad2\n);\n\n  reg [7:0] ins_p1;\n  reg [7:0] ins_p2;\n  reg [2:0] state;\n\n  always @(posedge clk or negedge rst) begin\n    if(!rst) begin\n      ins_p1 <= 8'd0;\n      ins_p2 <= 8'd0;\n    end else begin\n      if(fetch == 2'b01) begin\n        ins_p1 <= data;\n        ins_p2 <= ins_p2;\n      end else if(fetch == 2'b10) begin\n        ins_p1 <= ins_p1;\n        ins_p2 <= data;\n      end else begin\n        ins_p1 <= ins_p1;\n        ins_p2 <= ins_p2;\n      end\n    end\n  end\n\n  assign ins = ins_p1[7:5];\n  assign ad1 = ins_p1[4:0];\n  assign ad2 = ins_p2;\n\nendmodule\n\n"}
{"hash": "eb548335c975abdfe3ce8cfbddf53988699f85e555748d52461783d4cd434fbe", "equivalence_group": "eb548335c975abdfe3ce8cfbddf53988699f85e555748d52461783d4cd434fbe", "content": "\n\nmodule dut\n(\n  input clk,\n  input rst_n,\n  input start,\n  input [15:0] ain,\n  input [15:0] bin,\n  output [31:0] yout,\n  output done\n);\n\n  reg [15:0] areg;\n  reg [15:0] breg;\n  reg [31:0] yout_r;\n  reg done_r;\n  reg [4:0] i;\n\n  always @(posedge clk or negedge rst_n) if(!rst_n) i <= 5'd0; \n  else if(start && (i < 5'd17)) i <= i + 1'b1; \n  else if(!start) i <= 5'd0; \n\n\n  always @(posedge clk or negedge rst_n) if(!rst_n) done_r <= 1'b0; \n  else if(i == 5'd16) done_r <= 1'b1; \n  else if(i == 5'd17) done_r <= 1'b0; \n\n  assign done = done_r;\n\n  always @(posedge clk or negedge rst_n) begin\n    if(!rst_n) begin\n      areg <= 16'h0000;\n      breg <= 16'h0000;\n      yout_r <= 32'h00000000;\n    end else if(start) begin\n      if(i == 5'd0) begin\n        areg <= ain;\n        breg <= bin;\n      end else if((i > 5'd0) && (i < 5'd17)) begin\n        if(areg[i - 1]) yout_r <= yout_r + ({ 16'h0000, breg } << i - 1); \n      end \n    end \n  end\n\n  assign yout = yout_r;\n\nendmodule\n\n"}
{"hash": "e3e128ab905b2a9c24eda83d81a26172f940aa650a6cd9defc0c14d24fa30a88", "equivalence_group": "e3e128ab905b2a9c24eda83d81a26172f940aa650a6cd9defc0c14d24fa30a88", "content": "\n\nmodule dut #\n(\n  parameter size = 4\n)\n(\n  input clk,\n  input rst_n,\n  input [size-1:0] mul_a,\n  input [size-1:0] mul_b,\n  output reg [size*2-1:0] mul_out\n);\n\n  parameter N = 2 * size;\n  reg [N-1:0] sum_tmp1;\n  reg [N-1:0] sum_tmp2;\n  wire [N-1:0] mul_a_extend;\n  wire [N-1:0] mul_b_extend;\n  wire [N-1:0] mul_result [size-1:0];\n  genvar i;\n\n  generate for(i=0; i<size; i=i+1) begin : add\n    assign mul_result[i] = (mul_b[i])? mul_a_extend << i : 'd0;\n  end\n  endgenerate\n\n  assign mul_a_extend = { { size{ 1'b0 } }, mul_a };\n  assign mul_b_extend = { { size{ 1'b0 } }, mul_b };\n\n  always @(posedge clk or negedge rst_n) begin\n    if(!rst_n) begin\n      sum_tmp1 <= 'd0;\n      sum_tmp2 <= 'd0;\n    end else begin\n      sum_tmp1 <= mul_result[0] + mul_result[1];\n      sum_tmp2 <= mul_result[2] + mul_result[3];\n    end\n  end\n\n\n  always @(posedge clk or negedge rst_n) begin\n    if(!rst_n) begin\n      mul_out <= 'd0;\n    end else begin\n      mul_out <= sum_tmp1 + sum_tmp2;\n    end\n  end\n\n\nendmodule\n\n"}
{"hash": "3c6d0b722d4086cb336045beea4b552d80c301a87dde4b62794b18a45abe9250", "equivalence_group": "3c6d0b722d4086cb336045beea4b552d80c301a87dde4b62794b18a45abe9250", "content": "\n\nmodule dut #\n(\n  parameter size = 8\n)\n(\n  clk,\n  rst_n,\n  mul_a,\n  mul_b,\n  mul_en_in,\n  mul_en_out,\n  mul_out\n);\n\n  input clk;\n  input rst_n;\n  input mul_en_in;\n  input [size-1:0] mul_a;\n  input [size-1:0] mul_b;\n  output mul_en_out;\n  reg mul_en_out;\n  output [size*2-1:0] mul_out;\n  reg [size*2-1:0] mul_out;\n  reg [2:0] mul_en_out_reg;\n\n  always @(posedge clk or negedge rst_n) if(!rst_n) begin\n    mul_en_out_reg <= 'd0;\n    mul_en_out <= 'd0;\n  end else begin\n    mul_en_out_reg <= { mul_en_out_reg[1:0], mul_en_in };\n    mul_en_out <= mul_en_out_reg[2];\n  end\n\n  reg [7:0] mul_a_reg;\n  reg [7:0] mul_b_reg;\n\n  always @(posedge clk or negedge rst_n) if(!rst_n) begin\n    mul_a_reg <= 'd0;\n    mul_a_reg <= 'd0;\n  end else begin\n    mul_a_reg <= (mul_en_in)? mul_a : 'd0;\n    mul_b_reg <= (mul_en_in)? mul_b : 'd0;\n  end\n\n  wire [15:0] temp [size-1:0];\n  assign temp[0] = (mul_b_reg[0])? { 8'b0, mul_a_reg } : 'd0;\n  assign temp[1] = (mul_b_reg[1])? { 7'b0, mul_a_reg, 1'b0 } : 'd0;\n  assign temp[2] = (mul_b_reg[2])? { 6'b0, mul_a_reg, 2'b0 } : 'd0;\n  assign temp[3] = (mul_b_reg[3])? { 5'b0, mul_a_reg, 3'b0 } : 'd0;\n  assign temp[4] = (mul_b_reg[4])? { 4'b0, mul_a_reg, 4'b0 } : 'd0;\n  assign temp[5] = (mul_b_reg[5])? { 3'b0, mul_a_reg, 5'b0 } : 'd0;\n  assign temp[6] = (mul_b_reg[6])? { 2'b0, mul_a_reg, 6'b0 } : 'd0;\n  assign temp[7] = (mul_b_reg[7])? { 1'b0, mul_a_reg, 7'b0 } : 'd0;\n  reg [15:0] sum [3:0];\n\n  always @(posedge clk or negedge rst_n) if(!rst_n) begin\n    sum[0] <= 'd0;\n    sum[1] <= 'd0;\n    sum[2] <= 'd0;\n    sum[3] <= 'd0;\n  end else begin\n    sum[0] <= temp[0] + temp[1];\n    sum[1] <= temp[2] + temp[3];\n    sum[2] <= temp[4] + temp[5];\n    sum[3] <= temp[6] + temp[7];\n  end\n\n  reg [15:0] mul_out_reg;\n\n  always @(posedge clk or negedge rst_n) if(!rst_n) mul_out_reg <= 'd0; \n  else mul_out_reg <= sum[0] + sum[1] + sum[2] + sum[3];\n\n\n  always @(posedge clk or negedge rst_n) if(!rst_n) mul_out <= 'd0; \n  else if(mul_en_out_reg[2]) mul_out <= mul_out_reg; \n  else mul_out <= 'd0;\n\n\nendmodule\n\n"}
{"hash": "785442bec9509c26c8694beb0c028109aaaf5e5b54d60b99cf4f7a685f31e5cf", "equivalence_group": "785442bec9509c26c8694beb0c028109aaaf5e5b54d60b99cf4f7a685f31e5cf", "content": "\n\nmodule dut\n(\n  input wire clk,\n  input wire rst_n,\n  input wire [3:0] d,\n  output wire valid_out,\n  output wire dout\n);\n\n  reg [3:0] data;\n  assign data = 'd0;\n  reg [1:0] cnt;\n  reg valid;\n  assign dout = data[3];\n  assign valid_out = valid;\n\n  always @(posedge clk or negedge rst_n) begin\n    if(!rst_n) begin\n      data <= 'd0;\n      cnt <= 'd0;\n      valid <= 'd0;\n    end else begin\n      if(cnt == 'd3) begin\n        data <= d;\n        cnt <= 'd0;\n        valid <= 1;\n      end else begin\n        cnt <= cnt + 'd1;\n        valid <= 0;\n        data <= { data[2:0], data[3] };\n      end\n    end\n  end\n\n\nendmodule\n\n"}
{"hash": "fbc4d04391496e2b8249af0510de45511a1ab2117306a9b58904b262e7fccd8e", "equivalence_group": "fbc4d04391496e2b8249af0510de45511a1ab2117306a9b58904b262e7fccd8e", "content": "\n\nmodule dut\n(\n  input clk,\n  input rst,\n  input [31:0] a,\n  input [31:0] b,\n  output [31:0] c\n);\n\n  reg [31:0] cc;\n  assign c = cc;\n\n  always @(posedge clk or posedge rst) begin\n    if(rst) begin\n      cc <= 0;\n    end else begin\n      cc <= cc + a * b;\n    end\n  end\n\n\nendmodule\n\n"}
{"hash": "2dc60e1f13cbfe4afc0defe92c133162b821fb8d70aa6f6f8cf18f9f53c26d96", "equivalence_group": "2dc60e1f13cbfe4afc0defe92c133162b821fb8d70aa6f6f8cf18f9f53c26d96", "content": "\n\nmodule dut\n(\n  input clk,\n  input rst_n,\n  input data_in,\n  output reg data_out\n);\n\n  parameter s0 = 2'b00;\n  parameter s1 = 2'b01;\n  parameter s2 = 2'b10;\n  parameter s3 = 2'b11;\n  reg [1:0] pulse_level1;\n  reg [1:0] pulse_level2;\n\n  always @(posedge clk or negedge rst_n) begin\n    if(!rst_n) pulse_level1 <= s0; \n    else pulse_level1 <= pulse_level2;\n  end\n\n\n  always @(*) begin\n    case(pulse_level1)\n      s0: begin\n        if(data_in == 0) pulse_level2 = s1; \n        else pulse_level2 = s0;\n      end\n      s1: begin\n        if(data_in == 1) pulse_level2 = s2; \n        else pulse_level2 = s1;\n      end\n      s2: begin\n        if(data_in == 0) pulse_level2 = s3; \n        else pulse_level2 = s0;\n      end\n      s3: begin\n        if(data_in == 1) pulse_level2 = s2; \n        else pulse_level2 = s1;\n      end\n    endcase\n  end\n\n\n  always @(*) begin\n    if(~rst_n) data_out = 0; \n    else if((pulse_level1 == s2) && (data_in == 0)) data_out = 1; \n    else data_out = 0;\n  end\n\n\nendmodule\n\n"}
{"hash": "da59bc08c36b91c9ad06cdca5b0648fec119e200c2858795035bb01c0e0dc36d", "equivalence_group": "da59bc08c36b91c9ad06cdca5b0648fec119e200c2858795035bb01c0e0dc36d", "content": "\n\nmodule dut\n(\n  input wire clk,\n  input wire rst,\n  input wire [7:0] dividend,\n  input wire [7:0] divisor,\n  input wire sign,\n  input wire opn_valid,\n  output reg res_valid,\n  input wire res_ready,\n  output wire [15:0] result\n);\n\n  reg [7:0] dividend_save;\n  reg [7:0] divisor_save;\n  reg [15:0] SR;\n  reg [8:0] NEG_DIVISOR;\n  wire [7:0] REMAINER;\n  wire [7:0] QUOTIENT;\n  assign REMAINER = SR[15:8];\n  assign QUOTIENT = SR[7:0];\n  wire [7:0] divident_abs;\n  wire [8:0] divisor_abs;\n  wire [7:0] remainer;\n  wire [7:0] quotient;\n  assign divident_abs = (sign & dividend[7])? ~dividend + 1'b1 : dividend;\n  assign remainer = (sign & dividend_save[7])? ~REMAINER + 1'b1 : REMAINER;\n  assign quotient = (sign & (dividend_save[7] ^ divisor_save[7]))? ~QUOTIENT + 1'b1 : QUOTIENT;\n  assign result = { remainer, quotient };\n  wire CO;\n  wire [8:0] sub_result;\n  wire [8:0] mux_result;\n  assign { CO, sub_result } = { 1'b0, REMAINER } + NEG_DIVISOR;\n  assign mux_result = (CO)? sub_result : { 1'b0, REMAINER };\n  reg [3:0] cnt;\n  reg start_cnt;\n\n  always @(posedge clk) begin\n    if(rst) begin\n      SR <= 0;\n      dividend_save <= 0;\n      divisor_save <= 0;\n      cnt <= 0;\n      start_cnt <= 1'b0;\n    end else if(~start_cnt & opn_valid & ~res_valid) begin\n      cnt <= 1;\n      start_cnt <= 1'b1;\n      dividend_save <= dividend;\n      divisor_save <= divisor;\n      SR[15:0] <= { 7'b0, divident_abs, 1'b0 };\n      NEG_DIVISOR <= (sign & divisor[7])? { 1'b1, divisor } : ~{ 1'b0, divisor } + 1'b1;\n    end else if(start_cnt) begin\n      if(cnt[3]) begin\n        cnt <= 0;\n        start_cnt <= 1'b0;\n        SR[15:8] <= mux_result[7:0];\n        SR[0] <= CO;\n      end else begin\n        cnt <= cnt + 1;\n        SR[15:0] <= { mux_result[6:0], SR[7:1], CO, 1'b0 };\n      end\n    end \n  end\n\n  wire data_go;\n  assign data_go = res_valid & res_ready;\n\n  always @(posedge clk) begin\n    res_valid <= (rst)? 1'b0 : \n                 (cnt[3])? 1'b1 : \n                 (data_go)? 1'b0 : res_valid;\n  end\n\n\nendmodule\n\n"}
{"hash": "dd002bdc34e468f54afa5900bb21fc669513105f9cab95162fa2bd05f4e8058e", "equivalence_group": "dd002bdc34e468f54afa5900bb21fc669513105f9cab95162fa2bd05f4e8058e", "content": "\n\nmodule dut\n(\n  clk,\n  q,\n  d\n);\n\n  input clk;\n  input d;\n  output [7:0] q;\n  reg [7:0] q;\n\n  initial q = 0;\n\n\n  always @(posedge clk) begin\n    q <= q >> 1;\n    q[7] <= d;\n  end\n\n\nendmodule\n\n"}
{"hash": "833522d5a4eb40b6fd03492d9115007e90f246b936bc2820a5dfff40865fcf65", "equivalence_group": "833522d5a4eb40b6fd03492d9115007e90f246b936bc2820a5dfff40865fcf65", "content": "\n\nmodule dut\n(\n  input wire clk,\n  input wire reset,\n  output reg [7:0] out\n);\n\n  reg [7:0] state;\n\n  always @(posedge clk or posedge reset) begin\n    if(reset) state <= 8'b0000_0001; \n    else state <= { state[6:0], state[7] };\n  end\n\n  assign out = state;\n\nendmodule\n\n"}
{"hash": "73ac6ac6d4ae504b46730b7503a39a5a21e8a487dbe5c72cbf41daccdc7452dc", "equivalence_group": "73ac6ac6d4ae504b46730b7503a39a5a21e8a487dbe5c72cbf41daccdc7452dc", "content": "\n\nmodule dut\n(\n  input clk,\n  input rst_n,\n  input data_in,\n  output sequence_detected\n);\n\n  parameter IDLE = 5'b00001;\n  parameter S1 = 5'b00010;\n  parameter S2 = 5'b00100;\n  parameter S3 = 5'b01000;\n  parameter S4 = 5'b10000;\n  reg [4:0] curr_state;\n  reg [4:0] next_state;\n\n  always @(posedge clk or negedge rst_n) begin\n    if(!rst_n) begin\n      curr_state <= IDLE;\n    end else begin\n      curr_state <= next_state;\n    end\n  end\n\n\n  always @(*) begin\n    if(!rst_n) begin\n      next_state <= IDLE;\n    end else begin\n      case(curr_state)\n        IDLE: next_state = (data_in)? S1 : IDLE;\n        S1: next_state = (data_in)? S1 : S2;\n        S2: next_state = (data_in)? S1 : S3;\n        S3: next_state = (data_in)? S4 : IDLE;\n        S4: next_state = (data_in)? S1 : S2;\n        default: next_state = IDLE;\n      endcase\n    end\n  end\n\n  assign sequence_detected = (curr_state == S4)? 1'b1 : 1'b0;\n\nendmodule\n\n"}
{"hash": "b4ddd4567ca9a5979c0b31418341b3d3d72adaa86d875ee2c80a1535086ea659", "equivalence_group": "b4ddd4567ca9a5979c0b31418341b3d3d72adaa86d875ee2c80a1535086ea659", "content": "\n\nmodule dut\n(\n  input clk,\n  input rst_n,\n  input din_serial,\n  input din_valid,\n  output reg [7:0] dout_parallel,\n  output reg dout_valid\n);\n\n  reg [7:0] din_tmp;\n  reg [3:0] cnt;\n\n  always @(posedge clk or negedge rst_n) begin\n    if(!rst_n) cnt <= 0; \n    else if(din_valid) cnt <= (cnt == 4'd8)? 0 : cnt + 1'b1; \n    else cnt <= 0;\n  end\n\n\n  always @(posedge clk or negedge rst_n) begin\n    if(!rst_n) din_tmp <= 8'b0; \n    else if(din_valid && (cnt <= 4'd7)) din_tmp <= { din_tmp[6:0], din_serial }; \n  end\n\n\n  always @(posedge clk or negedge rst_n) begin\n    if(!rst_n) begin\n      dout_valid <= 1'b0;\n      dout_parallel <= 8'b0;\n    end else if(cnt == 4'd8) begin\n      dout_valid <= 1'b1;\n      dout_parallel <= din_tmp;\n    end else begin\n      dout_valid <= 1'b0;\n    end\n  end\n\n\nendmodule\n\n"}
{"hash": "7b6c5486ccffe746cb3db9d363c5af96eb7e9492c15f6cdd0eb639a71922d959", "equivalence_group": "7b6c5486ccffe746cb3db9d363c5af96eb7e9492c15f6cdd0eb639a71922d959", "content": "\n\nmodule dut\n(\n  input clk,\n  input rst_n,\n  output reg [4:0] wave\n);\n\n  reg [1:0] state;\n\n  always @(posedge clk or negedge rst_n) begin\n    if(~rst_n) begin\n      state <= 2'b0;\n      wave <= 5'b0;\n    end else begin\n      case(state)\n        2'b00: begin\n          if(wave == 5'b11111) state <= 2'b01; \n          else wave <= wave + 1;\n        end\n        2'b01: begin\n          if(wave == 5'b00000) state <= 2'b00; \n          else wave <= wave - 1;\n        end\n      endcase\n    end\n  end\n\n\nendmodule\n\n"}
{"hash": "e22e8505cb77f17d2f3a9493ec1a616a33eff1cd29d701305d5070e50b4e7ddd", "equivalence_group": "e22e8505cb77f17d2f3a9493ec1a616a33eff1cd29d701305d5070e50b4e7ddd", "content": "\n\nmodule dut\n(\n  input clk,\n  input [7:0] freq,\n  output reg wave_out\n);\n\n  reg [7:0] count;\n\n  initial begin\n    wave_out = 0;\n    count = 0;\n  end\n\n\n  always @(posedge clk) begin\n    if(count == freq - 1) begin\n      count <= 0;\n      wave_out <= ~wave_out;\n    end else begin\n      count <= count + 1;\n    end\n  end\n\n\nendmodule\n\n"}
{"hash": "cc8ca11e0ea0003757004d4caa8544ba9c85fe9cb170137a5bb90e368f697fbf", "equivalence_group": "cc8ca11e0ea0003757004d4caa8544ba9c85fe9cb170137a5bb90e368f697fbf", "content": "\n\nmodule dut\n(\n  input [63:0] A,\n  input [63:0] B,\n  output reg [63:0] result,\n  output reg overflow\n);\n\n\n  always @(*) begin\n    result = A - B;\n    if((A[63] != B[63]) && (result[63] != A[63])) begin\n      overflow = 1;\n    end else begin\n      overflow = 0;\n    end\n  end\n\n\nendmodule\n\n"}
{"hash": "0b82a388a7bb3d308ba17274d2358e068ada6cfca2e60201d5a9d231bc4163f4", "equivalence_group": "0b82a388a7bb3d308ba17274d2358e068ada6cfca2e60201d5a9d231bc4163f4", "content": "\n\nmodule dut\n(\n  input clk_a,\n  input clk_b,\n  input arstn,\n  input brstn,\n  input [3:0] data_in,\n  input data_en,\n  output reg [3:0] dataout\n);\n\n  reg [3:0] data_reg;\n\n  always @(posedge clk_a or negedge arstn) begin\n    if(!arstn) data_reg <= 0; \n    else data_reg <= data_in;\n  end\n\n  reg en_data_reg;\n\n  always @(posedge clk_a or negedge arstn) begin\n    if(!brstn) en_data_reg <= 0; \n    else en_data_reg <= data_en;\n  end\n\n  reg en_clap_one;\n  reg en_clap_two;\n\n  always @(posedge clk_b or negedge brstn) begin\n    if(!brstn) en_clap_one <= 0; \n    else en_clap_one <= en_data_reg;\n  end\n\n\n  always @(posedge clk_b or negedge brstn) begin\n    if(!brstn) en_clap_two <= 0; \n    else en_clap_two <= en_clap_one;\n  end\n\n\n  always @(posedge clk_b or negedge brstn) begin\n    if(!brstn) dataout <= 0; \n    else dataout <= (en_clap_two)? data_reg : dataout;\n  end\n\n\nendmodule\n\n"}
{"hash": "4d15445159124642f84ae50e29898a25e3e228d7a47240d44be65403ecbf8d0c", "equivalence_group": "4d15445159124642f84ae50e29898a25e3e228d7a47240d44be65403ecbf8d0c", "content": "\n\nmodule dut\n(\n  input rst_n,\n  input clk,\n  input pass_request,\n  output wire [7:0] clock,\n  output reg red,\n  output reg yellow,\n  output reg green\n);\n\n  parameter idle = 2'd0;\n  parameter s1_red = 2'd1;\n  parameter s2_yellow = 2'd2;\n  parameter s3_green = 2'd3;\n  reg [7:0] cnt;\n  reg [1:0] state;\n  reg p_red;\n  reg p_yellow;\n  reg p_green;\n\n  always @(posedge clk or negedge rst_n) begin\n    if(!rst_n) begin\n      state <= idle;\n      p_red <= 1'b0;\n      p_green <= 1'b0;\n      p_yellow <= 1'b0;\n    end else case(state)\n      idle: begin\n        p_red <= 1'b0;\n        p_green <= 1'b0;\n        p_yellow <= 1'b0;\n        state <= s1_red;\n      end\n      s1_red: begin\n        p_red <= 1'b1;\n        p_green <= 1'b0;\n        p_yellow <= 1'b0;\n        if(cnt == 3) state <= s3_green; \n        else state <= s1_red;\n      end\n      s2_yellow: begin\n        p_red <= 1'b0;\n        p_green <= 1'b0;\n        p_yellow <= 1'b1;\n        if(cnt == 3) state <= s1_red; \n        else state <= s2_yellow;\n      end\n      s3_green: begin\n        p_red <= 1'b0;\n        p_green <= 1'b1;\n        p_yellow <= 1'b0;\n        if(cnt == 3) state <= s2_yellow; \n        else state <= s3_green;\n      end\n    endcase\n  end\n\n\n  always @(posedge clk or negedge rst_n) if(!rst_n) cnt <= 7'd10; \n  else if(pass_request && green && (cnt > 10)) cnt <= 7'd10; \n  else if(!green && p_green) cnt <= 7'd60; \n  else if(!yellow && p_yellow) cnt <= 7'd5; \n  else if(!red && p_red) cnt <= 7'd10; \n  else cnt <= cnt - 1;\n\n  assign clock = cnt;\n\n  always @(posedge clk or negedge rst_n) if(!rst_n) begin\n    yellow <= 1'd0;\n    red <= 1'd0;\n    green <= 1'd0;\n  end else begin\n    yellow <= p_yellow;\n    red <= p_red;\n    green <= p_green;\n  end\n\n\nendmodule\n\n"}
{"hash": "3dea2c96204c7d12b4ca5744afc8cf25674f2556d2f67c2ce54914013dcd2650", "equivalence_group": "3dea2c96204c7d12b4ca5744afc8cf25674f2556d2f67c2ce54914013dcd2650", "content": "\n\nmodule dut\n(\n  input wire clk,\n  input wire reset,\n  input wire up_down,\n  output reg [15:0] count\n);\n\n\n  always @(posedge clk or posedge reset) begin\n    if(reset) begin\n      count <= 16'b0;\n    end else begin\n      if(up_down) begin\n        if(count == 16'b1111_1111_1111_1111) begin\n          count <= 16'b0;\n        end else begin\n          count <= count + 1;\n        end\n      end else begin\n        if(count == 16'b0) begin\n          count <= 16'b1111_1111_1111_1111;\n        end else begin\n          count <= count - 1;\n        end\n      end\n    end\n  end\n\n\nendmodule\n\n"}
{"hash": "da869943790b1987ce205048ce5e1113f9d878ab9cec434cf9273e24be48a747", "equivalence_group": "da869943790b1987ce205048ce5e1113f9d878ab9cec434cf9273e24be48a747", "content": "\n\nmodule dut\n(\n  input clk,\n  input rst_n,\n  input valid_in,\n  input [7:0] data_in,\n  output reg valid_out,\n  output reg [15:0] data_out\n);\n\n  reg [7:0] data_lock;\n  reg flag;\n\n  always @(posedge clk or negedge rst_n) begin\n    if(!rst_n) data_lock <= 'd0; \n    else if(valid_in && !flag) data_lock <= data_in; \n  end\n\n\n  always @(posedge clk or negedge rst_n) begin\n    if(!rst_n) flag <= 'd0; \n    else if(valid_in) flag <= ~flag; \n  end\n\n\n  always @(posedge clk or negedge rst_n) begin\n    if(!rst_n) valid_out <= 'd0; \n    else if(valid_in && flag) valid_out <= 1'd1; \n    else valid_out <= 'd0;\n  end\n\n\n  always @(posedge clk or negedge rst_n) begin\n    if(!rst_n) data_out <= 'd0; \n    else if(valid_in && flag) data_out <= { data_lock, data_in }; \n  end\n\n\nendmodule\n\n"}
