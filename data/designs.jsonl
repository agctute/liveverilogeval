{"hash": "e8caaf0c11a7692198b9e17448386a889238f7144d2e786e516c6412c8cac646", "equivalence_group": 1, "content": "\n\nmodule JC_counter\n(\n  input clk,\n  input rst_n,\n  output reg [63:0] Q\n);\n\n\n  always @(posedge clk or negedge rst_n) begin\n    if(!rst_n) Q <= 'd0; \n    else if(!Q[0]) Q <= { 1'b1, Q[63:1] }; \n    else Q <= { 1'b0, Q[63:1] };\n  end\n\n\nendmodule\n\n"}
{"hash": "144538f424d2374ae92cf675f55f7a8fc5a04c71fbb9e0c005182125a617c949", "equivalence_group": 2, "content": "\n\nmodule LFSR\n(\n  out,\n  clk,\n  rst\n);\n\n  input clk;input rst;\n  output [3:0] out;reg [3:0] out;\n  wire feedback;\n  assign feedback = ~(out[3] ^ out[2]);\n\n  always @(posedge clk or posedge rst) begin\n    if(rst) out = 4'b0; \n    else out = { out[2:0], feedback };\n  end\n\n\nendmodule\n\n"}
{"hash": "f28c7bfe03f711259ded0284c60afb91d687773de7e2d6656ed417c3823e94f1", "equivalence_group": 3, "content": "\n\nmodule LIFObuffer\n(\n  input [3:0] dataIn,\n  input RW,\n  input EN,\n  input Rst,\n  input Clk,\n  output reg EMPTY,\n  output reg FULL,\n  output reg [3:0] dataOut\n);\n\n  reg [3:0] stack_mem [0:3];\n  reg [2:0] SP;\n  integer i;\n\n  always @(posedge Clk) begin\n    if(EN == 0) begin\n    end else begin\n      if(Rst == 1) begin\n        SP = 3'd4;\n        EMPTY = SP[2];\n        dataOut = 4'h0;\n        for(i=0; i<4; i=i+1) begin\n          stack_mem[i] = 0;\n        end\n      end else if(Rst == 0) begin\n        FULL = (SP)? 0 : 1;\n        EMPTY = SP[2];\n        dataOut = 4'hx;\n        if((FULL == 1'b0) && (RW == 1'b0)) begin\n          SP = SP - 1'b1;\n          FULL = (SP)? 0 : 1;\n          EMPTY = SP[2];\n          stack_mem[SP] = dataIn;\n        end else if((EMPTY == 1'b0) && (RW == 1'b1)) begin\n          dataOut = stack_mem[SP];\n          stack_mem[SP] = 0;\n          SP = SP + 1;\n          FULL = (SP)? 0 : 1;\n          EMPTY = SP[2];\n        end else begin\n        end\n      end else begin\n      end\n    end\n  end\n\n\nendmodule\n\n"}
{"hash": "b2ea94d15359cbb85a04f9b31ab517de7f48c777ab76bb8bf89613892a175764", "equivalence_group": 4, "content": "\n\nmodule verified_RAM\n(\n  input clk,\n  input rst_n,\n  input write_en,\n  input [7:0] write_addr,\n  input [5:0] write_data,\n  input read_en,\n  input [7:0] read_addr,\n  output reg [5:0] read_data\n);\n\n  reg [7:0] RAM [11:0];\n  integer i;\n\n  always @(posedge clk or negedge rst_n) begin\n    if(!rst_n) begin\n      for(i=0; i<8; i=i+1) begin\n        RAM[i] <= 'd0;\n      end\n    end else if(write_en) RAM[write_addr] <= write_data; \n  end\n\n\n  always @(posedge clk or negedge rst_n) begin\n    if(!rst_n) read_data <= 'd0; \n    else if(read_en) read_data <= RAM[read_addr]; \n    else read_data <= 'd0;\n  end\n\n\nendmodule\n\n"}
{"hash": "d4b68ad09d71e754b062527c961a3ee5194220a960c03550df9b752912eda418", "equivalence_group": 5, "content": "\n\nmodule ROM\n(\n  input wire [7:0] addr,\n  output reg [15:0] dout\n);\n\n  reg [15:0] mem [0:255];\n\n  initial begin\n    mem[0] = 16'hA0A0;\n    mem[1] = 16'hB1B1;\n    mem[2] = 16'hC2C2;\n    mem[3] = 16'hD3D3;\n  end\n\n\n  always @(*) begin\n    dout = mem[addr];\n  end\n\n\nendmodule\n\n"}
{"hash": "e2ab4b3e61f197faae3140b32affd031974e27056b1308e99057d8cbc541d6b9", "equivalence_group": 6, "content": "\n\nmodule verified_accu\n(\n  input clk,\n  input rst_n,\n  input [7:0] data_in,\n  input valid_in,\n  output reg valid_out,\n  output reg [9:0] data_out\n);\n\n  reg [1:0] count;\n  wire add_cnt;\n  wire ready_add;\n  wire end_cnt;\n  reg [9:0] data_out_reg;\n  assign add_cnt = ready_add;\n  assign end_cnt = ready_add && (count == 'd3);\n\n  always @(posedge clk or negedge rst_n) begin\n    if(!rst_n) begin\n      count <= 0;\n    end else if(end_cnt) begin\n      count <= 0;\n    end else if(add_cnt) begin\n      count <= count + 1;\n    end \n  end\n\n\n  always @(posedge clk or negedge rst_n) begin\n    if(!rst_n) begin\n      data_out_reg <= 0;\n    end else if(add_cnt && (count == 0)) begin\n      data_out_reg <= data_in;\n    end else if(add_cnt) begin\n      data_out_reg <= data_out_reg + data_in;\n    end \n  end\n\n\n  always @(posedge clk or negedge rst_n) begin\n    if(!rst_n) begin\n      data_out <= 0;\n    end else if(add_cnt && (count == 0)) begin\n      data_out <= data_in;\n    end else if(add_cnt) begin\n      data_out <= data_out + data_in;\n    end \n  end\n\n  assign ready_add = !valid_out | valid_in;\n\n  always @(posedge clk or negedge rst_n) begin\n    if(!rst_n) begin\n      valid_out <= 0;\n    end else if(end_cnt) begin\n      valid_out <= 1;\n    end else begin\n      valid_out <= 0;\n    end\n  end\n\n\nendmodule\n\n"}
{"hash": "2b10d1482de9bddc941d2829446e421591c8df16b7ffd11a6036559eef1a11f5", "equivalence_group": 7, "content": "\n\nmodule verified_adder_16bit\n(\n  input wire [15:0] a,\n  input wire [15:0] b,\n  input wire Cin,\n  output wire [15:0] y,\n  output wire Co\n);\n\n  wire Co_temp;\n\n  add8\n  add8_inst1\n  (\n    .a(a[15:8]),\n    .b(b[15:8]),\n    .Cin(Co_temp),\n    .y(y[15:8]),\n    .Co(Co)\n  );\n\n\n  add8\n  add8_inst2\n  (\n    .a(a[7:0]),\n    .b(b[7:0]),\n    .Cin(Cin),\n    .y(y[7:0]),\n    .Co(Co_temp)\n  );\n\n\nendmodule\n\n\n\nmodule add8\n(\n  input wire [7:0] a,\n  input wire [7:0] b,\n  input wire Cin,\n  output wire [7:0] y,\n  output wire Co\n);\n\n  wire Co_temp;\n\n  add4\n  add4_inst1\n  (\n    .a(a[7:4]),\n    .b(b[7:4]),\n    .Cin(Co_temp),\n    .y(y[7:4]),\n    .Co(Co)\n  );\n\n\n  add4\n  add4_inst2\n  (\n    .a(a[3:0]),\n    .b(b[3:0]),\n    .Cin(Cin),\n    .y(y[3:0]),\n    .Co(Co_temp)\n  );\n\n\nendmodule\n\n\n\nmodule add4\n(\n  input wire [3:0] a,\n  input wire [3:0] b,\n  input wire Cin,\n  output wire [3:0] y,\n  output wire Co\n);\n\n  wire Co_temp;\n\n  add2\n  add2_inst1\n  (\n    .a(a[3:2]),\n    .b(b[3:2]),\n    .Cin(Co_temp),\n    .y(y[3:2]),\n    .Co(Co)\n  );\n\n\n  add2\n  add2_inst2\n  (\n    .a(a[1:0]),\n    .b(b[1:0]),\n    .Cin(Cin),\n    .y(y[1:0]),\n    .Co(Co_temp)\n  );\n\n\nendmodule\n\n\n\nmodule add2\n(\n  input wire [1:0] a,\n  input wire [1:0] b,\n  input wire Cin,\n  output wire [1:0] y,\n  output wire Co\n);\n\n  wire Co_temp;\n\n  add1\n  add1_inst1\n  (\n    .a(a[1]),\n    .b(b[1]),\n    .Cin(Co_temp),\n    .y(y[1]),\n    .Co(Co)\n  );\n\n\n  add1\n  add1_inst2\n  (\n    .a(a[0]),\n    .b(b[0]),\n    .Cin(Cin),\n    .y(y[0]),\n    .Co(Co_temp)\n  );\n\n\nendmodule\n\n\n\nmodule add1\n(\n  input wire a,\n  input wire b,\n  input wire Cin,\n  output wire y,\n  output wire Co\n);\n\n  assign y = ~a & ~b & Cin | ~a & b & ~Cin | a & ~b & ~Cin | a & b & Cin;\n  assign Co = ~a & b & Cin | a & ~b & Cin | a & b & ~Cin | a & b & Cin;\n\nendmodule\n\n"}
{"hash": "5d92a345bc8a0008b365c883094fdf17f393fad345ed35b5804e6d4ead1137b6", "equivalence_group": 8, "content": "\n\nmodule verified_adder_8bit\n(\n  input [7:0] a,\n  input [7:0] b,\n  input cin,\n  output [7:0] sum,\n  output cout\n);\n\n  wire [8:0] c;\n\n  full_adder\n  FA0\n  (\n    .a(a[0]),\n    .b(b[0]),\n    .cin(cin),\n    .sum(sum[0]),\n    .cout(c[0])\n  );\n\n\n  full_adder\n  FA1\n  (\n    .a(a[1]),\n    .b(b[1]),\n    .cin(c[0]),\n    .sum(sum[1]),\n    .cout(c[1])\n  );\n\n\n  full_adder\n  FA2\n  (\n    .a(a[2]),\n    .b(b[2]),\n    .cin(c[1]),\n    .sum(sum[2]),\n    .cout(c[2])\n  );\n\n\n  full_adder\n  FA3\n  (\n    .a(a[3]),\n    .b(b[3]),\n    .cin(c[2]),\n    .sum(sum[3]),\n    .cout(c[3])\n  );\n\n\n  full_adder\n  FA4\n  (\n    .a(a[4]),\n    .b(b[4]),\n    .cin(c[3]),\n    .sum(sum[4]),\n    .cout(c[4])\n  );\n\n\n  full_adder\n  FA5\n  (\n    .a(a[5]),\n    .b(b[5]),\n    .cin(c[4]),\n    .sum(sum[5]),\n    .cout(c[5])\n  );\n\n\n  full_adder\n  FA6\n  (\n    .a(a[6]),\n    .b(b[6]),\n    .cin(c[5]),\n    .sum(sum[6]),\n    .cout(c[6])\n  );\n\n\n  full_adder\n  FA7\n  (\n    .a(a[7]),\n    .b(b[7]),\n    .cin(c[6]),\n    .sum(sum[7]),\n    .cout(c[7])\n  );\n\n  assign cout = c[7];\n\nendmodule\n\n\n\nmodule full_adder\n(\n  input a,\n  input b,\n  input cin,\n  output sum,\n  output cout\n);\n\n  assign { cout, sum } = a + b + cin;\n\nendmodule\n\n"}
{"hash": "1a51a4a6479280138287b25dec5fd7fe2d592e77f0b8b035ef1f4fb80c28aa78", "equivalence_group": 9, "content": "\n\nmodule adder_bcd\n(\n  input [3:0] A,\n  input [3:0] B,\n  input Cin,\n  output [3:0] Sum,\n  output Cout\n);\n\n  wire [4:0] temp_sum;\n  wire [3:0] corrected_sum;\n  wire carry_out;\n  assign temp_sum = A + B + Cin;\n  assign carry_out = (temp_sum > 9)? 1 : 0;\n  assign corrected_sum = (temp_sum > 9)? temp_sum + 4'b0110 : temp_sum;\n  assign Sum = corrected_sum[3:0];\n  assign Cout = carry_out;\n\nendmodule\n\n"}
{"hash": "08e1a07a3727a595fe4c5f47561ad19e468ed2573d20d06f1e110772e8e57067", "equivalence_group": 10, "content": "\n\nmodule verified_alu\n(\n  input [31:0] a,\n  input [31:0] b,\n  input [5:0] aluc,\n  output [31:0] r,\n  output zero,\n  output carry,\n  output negative,\n  output overflow,\n  output flag\n);\n\n  parameter ADD = 6'b100000;\n  parameter ADDU = 6'b100001;\n  parameter SUB = 6'b100010;\n  parameter SUBU = 6'b100011;\n  parameter AND = 6'b100100;\n  parameter OR = 6'b100101;\n  parameter XOR = 6'b100110;\n  parameter NOR = 6'b100111;\n  parameter SLT = 6'b101010;\n  parameter SLTU = 6'b101011;\n  parameter SLL = 6'b000000;\n  parameter SRL = 6'b000010;\n  parameter SRA = 6'b000011;\n  parameter SLLV = 6'b000100;\n  parameter SRLV = 6'b000110;\n  parameter SRAV = 6'b000111;\n  parameter JR = 6'b001000;\n  parameter LUI = 6'b001111;\n  wire signed [31:0] a_signed;\n  wire signed [31:0] b_signed;\n  reg [32:0] res;\n  assign a_signed = a;\n  assign b_signed = b;\n  assign r = res[31:0];\n  assign flag = ((aluc == SLT) || (aluc == SLTU))? (aluc == SLT)? a_signed < b_signed : a < b : 1'bz;\n  assign zero = (res == 32'b0)? 1'b1 : 1'b0;\n\n  always @(a or b or aluc) begin\n    case(aluc)\n      ADD: begin\n        res <= a_signed + b_signed;\n      end\n      ADDU: begin\n        res <= a + b;\n      end\n      SUB: begin\n        res <= a_signed - b_signed;\n      end\n      SUBU: begin\n        res <= a - b;\n      end\n      AND: begin\n        res <= a & b;\n      end\n      OR: begin\n        res <= a | b;\n      end\n      XOR: begin\n        res <= a ^ b;\n      end\n      NOR: begin\n        res <= ~(a | b);\n      end\n      SLT: begin\n        res <= (a_signed < b_signed)? 1 : 0;\n      end\n      SLTU: begin\n        res <= (a < b)? 1 : 0;\n      end\n      SLL: begin\n        res <= b << a;\n      end\n      SRL: begin\n        res <= b >> a;\n      end\n      SRA: begin\n        res <= b_signed >>> a_signed;\n      end\n      SLLV: begin\n        res <= b << a[4:0];\n      end\n      SRLV: begin\n        res <= b >> a[4:0];\n      end\n      SRAV: begin\n        res <= b_signed >>> a_signed[4:0];\n      end\n      LUI: begin\n        res <= { a[15:0], 16'h0000 };\n      end\n      default: begin\n        res <= 32'bz;\n      end\n    endcase\n  end\n\n\nendmodule\n\n"}
{"hash": "9c5c31e801f6f37ff94590af596e30387bae8e7f6a128dd8a0e54bb5089b6af5", "equivalence_group": 11, "content": "\n\nmodule barrel_shifter\n(\n  in,\n  ctrl,\n  out\n);\n\n  input [7:0] in;\n  input [2:0] ctrl;\n  output [7:0] out;\n  wire [7:0] x;wire [7:0] y;\n\n  mux2X1\n  ins_17\n  (\n    .in0(in[7]),\n    .in1(1'b0),\n    .sel(ctrl[2]),\n    .out(x[7])\n  );\n\n\n  mux2X1\n  ins_16\n  (\n    .in0(in[6]),\n    .in1(1'b0),\n    .sel(ctrl[2]),\n    .out(x[6])\n  );\n\n\n  mux2X1\n  ins_15\n  (\n    .in0(in[5]),\n    .in1(1'b0),\n    .sel(ctrl[2]),\n    .out(x[5])\n  );\n\n\n  mux2X1\n  ins_14\n  (\n    .in0(in[4]),\n    .in1(1'b0),\n    .sel(ctrl[2]),\n    .out(x[4])\n  );\n\n\n  mux2X1\n  ins_13\n  (\n    .in0(in[3]),\n    .in1(in[7]),\n    .sel(ctrl[2]),\n    .out(x[3])\n  );\n\n\n  mux2X1\n  ins_12\n  (\n    .in0(in[2]),\n    .in1(in[6]),\n    .sel(ctrl[2]),\n    .out(x[2])\n  );\n\n\n  mux2X1\n  ins_11\n  (\n    .in0(in[1]),\n    .in1(in[5]),\n    .sel(ctrl[2]),\n    .out(x[1])\n  );\n\n\n  mux2X1\n  ins_10\n  (\n    .in0(in[0]),\n    .in1(in[4]),\n    .sel(ctrl[2]),\n    .out(x[0])\n  );\n\n\n  mux2X1\n  ins_27\n  (\n    .in0(x[7]),\n    .in1(1'b0),\n    .sel(ctrl[1]),\n    .out(y[7])\n  );\n\n\n  mux2X1\n  ins_26\n  (\n    .in0(x[6]),\n    .in1(1'b0),\n    .sel(ctrl[1]),\n    .out(y[6])\n  );\n\n\n  mux2X1\n  ins_25\n  (\n    .in0(x[5]),\n    .in1(x[7]),\n    .sel(ctrl[1]),\n    .out(y[5])\n  );\n\n\n  mux2X1\n  ins_24\n  (\n    .in0(x[4]),\n    .in1(x[6]),\n    .sel(ctrl[1]),\n    .out(y[4])\n  );\n\n\n  mux2X1\n  ins_23\n  (\n    .in0(x[3]),\n    .in1(x[5]),\n    .sel(ctrl[1]),\n    .out(y[3])\n  );\n\n\n  mux2X1\n  ins_22\n  (\n    .in0(x[2]),\n    .in1(x[4]),\n    .sel(ctrl[1]),\n    .out(y[2])\n  );\n\n\n  mux2X1\n  ins_21\n  (\n    .in0(x[1]),\n    .in1(x[3]),\n    .sel(ctrl[1]),\n    .out(y[1])\n  );\n\n\n  mux2X1\n  ins_20\n  (\n    .in0(x[0]),\n    .in1(x[2]),\n    .sel(ctrl[1]),\n    .out(y[0])\n  );\n\n\n  mux2X1\n  ins_07\n  (\n    .in0(y[7]),\n    .in1(1'b0),\n    .sel(ctrl[0]),\n    .out(out[7])\n  );\n\n\n  mux2X1\n  ins_06\n  (\n    .in0(y[6]),\n    .in1(y[7]),\n    .sel(ctrl[0]),\n    .out(out[6])\n  );\n\n\n  mux2X1\n  ins_05\n  (\n    .in0(y[5]),\n    .in1(y[6]),\n    .sel(ctrl[0]),\n    .out(out[5])\n  );\n\n\n  mux2X1\n  ins_04\n  (\n    .in0(y[4]),\n    .in1(y[5]),\n    .sel(ctrl[0]),\n    .out(out[4])\n  );\n\n\n  mux2X1\n  ins_03\n  (\n    .in0(y[3]),\n    .in1(y[4]),\n    .sel(ctrl[0]),\n    .out(out[3])\n  );\n\n\n  mux2X1\n  ins_02\n  (\n    .in0(y[2]),\n    .in1(y[3]),\n    .sel(ctrl[0]),\n    .out(out[2])\n  );\n\n\n  mux2X1\n  ins_01\n  (\n    .in0(y[1]),\n    .in1(y[2]),\n    .sel(ctrl[0]),\n    .out(out[1])\n  );\n\n\n  mux2X1\n  ins_00\n  (\n    .in0(y[0]),\n    .in1(y[1]),\n    .sel(ctrl[0]),\n    .out(out[0])\n  );\n\n\nendmodule\n\n\n\nmodule mux2X1\n(\n  in0,\n  in1,\n  sel,\n  out\n);\n\n  input in0;input in1;\n  input sel;\n  output out;\n  assign out = (sel)? in1 : in0;\n\nendmodule\n\n"}
{"hash": "3c59149fb272d0485080d840a8c70b65664f6b9ca1df868e2b03d8c7c045b2bb", "equivalence_group": 12, "content": "\n\nmodule verified_calendar\n(\n  CLK,\n  RST,\n  Hours,\n  Mins,\n  Secs\n);\n\n  input CLK;input RST;\n  output [5:0] Hours;output [5:0] Mins;output [5:0] Secs;\n  reg [5:0] Hours;reg [5:0] Mins;reg [5:0] Secs;\n\n  always @(posedge CLK or posedge RST) begin\n    if(RST) Secs <= 0; \n    else if(Secs == 59) Secs <= 0; \n    else Secs <= Secs + 1;\n  end\n\n\n  always @(posedge CLK or posedge RST) begin\n    if(RST) Mins <= 0; \n    else if((Mins == 59) && (Secs == 59)) Mins <= 0; \n    else if(Secs == 59) Mins <= Mins + 1; \n    else Mins <= Mins;\n  end\n\n\n  always @(posedge CLK or posedge RST) begin\n    if(RST) Hours <= 0; \n    else if((Hours == 23) && (Mins == 59) && (Secs == 59)) Hours <= 0; \n    else if((Mins == 59) && (Secs == 59)) Hours <= Hours + 1; \n    else Hours <= Hours;\n  end\n\n\nendmodule\n\n"}
{"hash": "4d6c07b66ea432b714ca9ff1d44e190ea0aabb4e438effa1e28b68f47c437770", "equivalence_group": 13, "content": "\n\nmodule clkgenerator\n(\n  output reg clk\n);\n\n  parameter PERIOD = 10;\n\n  initial begin\n    clk = 0;\n  end\n\n\n  always @(*) begin\n    #(PERIOD / 2) clk = ~clk;\n  end\n\n\nendmodule\n\n"}
{"hash": "d7c6e49b1f7b7b06856e2a6fad60eded05c933a0a626ee859e1491309f5b1640", "equivalence_group": 14, "content": "\n\nmodule comparator_3bit\n(\n  input [2:0] A,\n  input [2:0] B,\n  output A_greater,\n  output A_equal,\n  output A_less\n);\n\n  assign A_greater = (A > B)? 1'b1 : 1'b0;\n  assign A_equal = (A == B)? 1'b1 : 1'b0;\n  assign A_less = (A < B)? 1'b1 : 1'b0;\n\nendmodule\n\n"}
{"hash": "6cc5297b099a2212835f95fc152fe6f28d951184417acc3665ea007e5b0aa7f8", "equivalence_group": 15, "content": "\n\nmodule comparator_4bit\n(\n  input [3:0] A,\n  input [3:0] B,\n  output A_greater,\n  output A_equal,\n  output A_less\n);\n\n  wire [3:0] diff;\n  wire cout;\n  assign { cout, diff } = A - B;\n  assign A_greater = ~cout && (diff != 4'b0000);\n  assign A_equal = A == B;\n  assign A_less = cout;\n\nendmodule\n\n"}
{"hash": "c6e96c865e7d4ff7370851a8855d60ca36c45b81fbd063ea57eb1a8555e73e9b", "equivalence_group": 16, "content": "\n\nmodule verified_counter_12\n(\n  input rst_n,\n  input clk,\n  input valid_count,\n  output reg [3:0] out\n);\n\n\n  always @(posedge clk or negedge rst_n) begin\n    if(!rst_n) begin\n      out <= 4'b0000;\n    end else if(valid_count) begin\n      if(out == 4'd11) begin\n        out <= 4'b0000;\n      end else begin\n        out <= out + 1;\n      end\n    end else begin\n      out <= out;\n    end\n  end\n\n\nendmodule\n\n"}
{"hash": "d234b4a23f71b056b47c2ce6fd45a76c4787e080701d4ab2f056e5d806eaee95", "equivalence_group": 17, "content": "\n\nmodule verified_edge_detect\n(\n  input clk,\n  input rst_n,\n  input a,\n  output reg rise,\n  output reg down\n);\n\n  reg a0;\n\n  always @(posedge clk or negedge rst_n) begin\n    if(~rst_n) begin\n      rise <= 1'b0;\n      down <= 1'b0;\n    end else begin\n      if(a & ~a0) begin\n        rise <= 1;\n        down <= 0;\n      end else if(~a & a0) begin\n        rise <= 0;\n        down <= 1;\n      end else begin\n        rise <= 0;\n        down <= 0;\n      end\n    end\n  end\n\n\n  always @(posedge clk or negedge rst_n) begin\n    if(~rst_n) a0 <= 0; \n    else a0 <= a;\n  end\n\n\nendmodule\n\n"}
{"hash": "af86473888900f20ec5ad5a1390b3549b51babb280cd11ac52b72267496308ea", "equivalence_group": 18, "content": "\n\nmodule fixed_point_adder #\n(\n  parameter Q = 15,\n  parameter N = 32\n)\n(\n  input [N-1:0] a,\n  input [N-1:0] b,\n  output [N-1:0] c\n);\n\n  reg [N-1:0] res;\n  assign c = res;\n\n  always @(a or b) begin\n    if(a[N - 1] == b[N - 1]) begin\n      res[N-2:0] = a[N-2:0] + b[N-2:0];\n      res[N - 1] = a[N - 1];\n    end else if((a[N - 1] == 0) && (b[N - 1] == 1)) begin\n      if(a[N-2:0] > b[N-2:0]) begin\n        res[N-2:0] = a[N-2:0] - b[N-2:0];\n        res[N - 1] = 0;\n      end else begin\n        res[N-2:0] = b[N-2:0] - a[N-2:0];\n        if(res[N-2:0] == 0) res[N - 1] = 0; \n        else res[N - 1] = 1;\n      end\n    end else begin\n      if(a[N-2:0] > b[N-2:0]) begin\n        res[N-2:0] = a[N-2:0] - b[N-2:0];\n        if(res[N-2:0] == 0) res[N - 1] = 0; \n        else res[N - 1] = 1;\n      end else begin\n        res[N-2:0] = b[N-2:0] - a[N-2:0];\n        res[N - 1] = 0;\n      end\n    end\n  end\n\n\nendmodule\n\n"}
{"hash": "ec805fa127b134fd8d41660bbd07c3b4350d602555eeafe6bc01c75d4fdd3487", "equivalence_group": 19, "content": "\n\nmodule fixed_point_subtractor #\n(\n  parameter Q = 15,\n  parameter N = 32\n)\n(\n  input [N-1:0] a,\n  input [N-1:0] b,\n  output [N-1:0] c\n);\n\n  reg [N-1:0] res;\n  assign c = res;\n\n  always @(a or b) begin\n    if(a[N - 1] == b[N - 1]) begin\n      res[N-2:0] = a[N-2:0] - b[N-2:0];\n      res[N - 1] = a[N - 1];\n    end else if((a[N - 1] == 0) && (b[N - 1] == 1)) begin\n      if(a[N-2:0] > b[N-2:0]) begin\n        res[N-2:0] = a[N-2:0] + b[N-2:0];\n        res[N - 1] = 0;\n      end else begin\n        res[N-2:0] = b[N-2:0] + a[N-2:0];\n        if(res[N-2:0] == 0) res[N - 1] = 0; \n        else res[N - 1] = 1;\n      end\n    end else begin\n      if(a[N-2:0] > b[N-2:0]) begin\n        res[N-2:0] = a[N-2:0] + b[N-2:0];\n        if(res[N-2:0] == 0) res[N - 1] = 0; \n        else res[N - 1] = 1;\n      end else begin\n        res[N-2:0] = b[N-2:0] + a[N-2:0];\n        res[N - 1] = 0;\n      end\n    end\n  end\n\n\nendmodule\n\n"}
{"hash": "66a76ffe701f9b1c73827b378301745ab70713a6a46ddb5ed5bb7a7dad94004e", "equivalence_group": 20, "content": "\n\nmodule freq_div\n(\n  CLK_in,\n  CLK_50,\n  CLK_10,\n  CLK_1,\n  RST\n);\n\n  input CLK_in;input RST;\n  output CLK_50;reg CLK_50;output CLK_10;reg CLK_10;output CLK_1;reg CLK_1;\n  reg [3:0] cnt_10;\n  reg [6:0] cnt_100;\n\n  always @(posedge CLK_in or posedge RST) begin\n    if(RST) begin\n      CLK_50 <= 1'b0;\n    end else begin\n      CLK_50 <= ~CLK_50;\n    end\n  end\n\n\n  always @(posedge CLK_in or posedge RST) begin\n    if(RST) begin\n      CLK_10 <= 1'b0;\n      cnt_10 <= 0;\n    end else if(cnt_10 == 4) begin\n      CLK_10 <= ~CLK_10;\n      cnt_10 <= 0;\n    end else begin\n      cnt_10 <= cnt_10 + 1;\n    end\n  end\n\n\n  always @(posedge CLK_in or posedge RST) begin\n    if(RST) begin\n      CLK_1 <= 1'b0;\n      cnt_100 <= 0;\n    end else if(cnt_100 == 49) begin\n      CLK_1 <= ~CLK_1;\n      cnt_100 <= 0;\n    end else begin\n      cnt_100 <= cnt_100 + 1;\n    end\n  end\n\n\nendmodule\n\n"}
{"hash": "530d77b4fb1623350259a280468174f4798b5ba44769fcb0b25698fa066285e9", "equivalence_group": 21, "content": "\n\nmodule freq_divbyeven\n(\n  clk,\n  rst_n,\n  clk_div\n);\n\n  input clk;\n  input rst_n;\n  output clk_div;\n  reg clk_div;\n  parameter NUM_DIV = 6;\n  reg [3:0] cnt;\n\n  always @(posedge clk or negedge rst_n) if(!rst_n) begin\n    cnt <= 4'd0;\n    clk_div <= 1'b0;\n  end else if(cnt < NUM_DIV / 2 - 1) begin\n    cnt <= cnt + 1'b1;\n    clk_div <= clk_div;\n  end else begin\n    cnt <= 4'd0;\n    clk_div <= ~clk_div;\n  end\n\n\nendmodule\n\n"}
{"hash": "2b9268f33d665fc76383c9364930301901d7777f02c53fd5863f3ef9b3b4a72e", "equivalence_group": 22, "content": "\n\nmodule freq_divbyfrac\n(\n  input rst_n,\n  input clk,\n  output clk_div\n);\n\n  parameter MUL2_DIV_CLK = 7;\n  reg [3:0] cnt;\n\n  always @(posedge clk or negedge rst_n) begin\n    if(!rst_n) begin\n      cnt <= 'b0;\n    end else if(cnt == MUL2_DIV_CLK - 1) begin\n      cnt <= 'b0;\n    end else begin\n      cnt <= cnt + 1'b1;\n    end\n  end\n\n  reg clk_ave_r;\n\n  always @(posedge clk or negedge rst_n) begin\n    if(!rst_n) begin\n      clk_ave_r <= 1'b0;\n    end else if(cnt == 0) begin\n      clk_ave_r <= 1;\n    end else if(cnt == MUL2_DIV_CLK / 2 + 1) begin\n      clk_ave_r <= 1;\n    end else begin\n      clk_ave_r <= 0;\n    end\n  end\n\n  reg clk_adjust_r;\n\n  always @(negedge clk or negedge rst_n) begin\n    if(!rst_n) begin\n      clk_adjust_r <= 1'b0;\n    end else if(cnt == 1) begin\n      clk_adjust_r <= 1;\n    end else if(cnt == MUL2_DIV_CLK / 2 + 1) begin\n      clk_adjust_r <= 1;\n    end else begin\n      clk_adjust_r <= 0;\n    end\n  end\n\n  assign clk_div = clk_adjust_r | clk_ave_r;\n\nendmodule\n\n"}
{"hash": "89e5019c53f68c0b62f35f42284af4222a3f14f36ed84c73ccf0dfe19c0dcba7", "equivalence_group": 23, "content": "\n\nmodule freq_divbyodd\n(\n  clk,\n  rst_n,\n  clk_div\n);\n\n  input clk;\n  input rst_n;\n  output clk_div;\n  reg clk_div;\n  parameter NUM_DIV = 5;\n  reg [2:0] cnt1;\n  reg [2:0] cnt2;\n  reg clk_div1;reg clk_div2;\n\n  always @(posedge clk or negedge rst_n) if(!rst_n) cnt1 <= 0; \n  else if(cnt1 < NUM_DIV - 1) cnt1 <= cnt1 + 1'b1; \n  else cnt1 <= 0;\n\n\n  always @(posedge clk or negedge rst_n) if(!rst_n) clk_div1 <= 1'b1; \n  else if(cnt1 < NUM_DIV / 2) clk_div1 <= 1'b1; \n  else clk_div1 <= 1'b0;\n\n\n  always @(negedge clk or negedge rst_n) if(!rst_n) cnt2 <= 0; \n  else if(cnt2 < NUM_DIV - 1) cnt2 <= cnt2 + 1'b1; \n  else cnt2 <= 0;\n\n\n  always @(negedge clk or negedge rst_n) if(!rst_n) clk_div2 <= 1'b1; \n  else if(cnt2 < NUM_DIV / 2) clk_div2 <= 1'b1; \n  else clk_div2 <= 1'b0;\n\n  assign clk_div = clk_div1 | clk_div2;\n\nendmodule\n\n"}
{"hash": "d8e022af1c30b01d6d55b0019046def79cc18399596f8d3d2985ed7cb011ddf3", "equivalence_group": 24, "content": "\n\nmodule verified_fsm\n(\n  IN,\n  MATCH,\n  CLK,\n  RST\n);\n\n  input IN;input CLK;input RST;\n  output MATCH;reg MATCH;\n  reg [2:0] ST_cr;reg [2:0] ST_nt;\n  parameter s0 = 3'b000;\n  parameter s1 = 3'b001;\n  parameter s2 = 3'b010;\n  parameter s3 = 3'b011;\n  parameter s4 = 3'b100;\n  parameter s5 = 3'b101;\n\n  always @(posedge CLK or posedge RST) begin\n    if(RST) ST_cr <= s0; \n    else ST_cr <= ST_nt;\n  end\n\n\n  always @(*) begin\n    case(ST_cr)\n      s0: begin\n        if(IN == 0) ST_nt = s0; \n        else ST_nt = s1;\n      end\n      s1: begin\n        if(IN == 0) ST_nt = s2; \n        else ST_nt = s1;\n      end\n      s2: begin\n        if(IN == 0) ST_nt = s3; \n        else ST_nt = s1;\n      end\n      s3: begin\n        if(IN == 0) ST_nt = s0; \n        else ST_nt = s4;\n      end\n      s4: begin\n        if(IN == 0) ST_nt = s2; \n        else ST_nt = s5;\n      end\n      s5: begin\n        if(IN == 0) ST_nt = s2; \n        else ST_nt = s1;\n      end\n    endcase\n  end\n\n\n  always @(*) begin\n    if(RST) MATCH <= 0; \n    else if((ST_cr == s4) && (IN == 1)) MATCH <= 1; \n    else MATCH <= 0;\n  end\n\n\nendmodule\n\n"}
{"hash": "b7dde7d08942f42080e2cd5d101006447ed8cd8cb49e66106ba7d688e944e62e", "equivalence_group": 25, "content": "\n\nmodule instr_reg\n(\n  input clk,\n  input rst,\n  input [1:0] fetch,\n  input [7:0] data,\n  output [2:0] ins,\n  output [4:0] ad1,\n  output [7:0] ad2\n);\n\n  reg [7:0] ins_p1;reg [7:0] ins_p2;\n  reg [2:0] state;\n\n  always @(posedge clk or negedge rst) begin\n    if(!rst) begin\n      ins_p1 <= 8'd0;\n      ins_p2 <= 8'd0;\n    end else begin\n      if(fetch == 2'b01) begin\n        ins_p1 <= data;\n        ins_p2 <= ins_p2;\n      end else if(fetch == 2'b10) begin\n        ins_p1 <= ins_p1;\n        ins_p2 <= data;\n      end else begin\n        ins_p1 <= ins_p1;\n        ins_p2 <= ins_p2;\n      end\n    end\n  end\n\n  assign ins = ins_p1[7:5];\n  assign ad1 = ins_p1[4:0];\n  assign ad2 = ins_p2;\n\nendmodule\n\n"}
{"hash": "b877d4d060b697f5070d73aee68df06906176615f376096944c0886b93861f59", "equivalence_group": 26, "content": "\n\nmodule verified_multi_pipe #\n(\n  parameter size = 4\n)\n(\n  input clk,\n  input rst_n,\n  input [size-1:0] mul_a,\n  input [size-1:0] mul_b,\n  output reg [size*2-1:0] mul_out\n);\n\n  parameter N = 2 * size;\n  reg [N-1:0] sum_tmp1;\n  reg [N-1:0] sum_tmp2;\n  wire [N-1:0] mul_a_extend;\n  wire [N-1:0] mul_b_extend;\n  wire [N-1:0] mul_result [size-1:0];\n  genvar i;\n\n  generate for(i=0; i<size; i=i+1) begin : add\n    assign mul_result[i] = (mul_b[i])? mul_a_extend << i : 'd0;\n  end\n  endgenerate\n\n  assign mul_a_extend = { { size{ 1'b0 } }, mul_a };\n  assign mul_b_extend = { { size{ 1'b0 } }, mul_b };\n\n  always @(posedge clk or negedge rst_n) begin\n    if(!rst_n) begin\n      sum_tmp1 <= 'd0;\n      sum_tmp2 <= 'd0;\n    end else begin\n      sum_tmp1 <= mul_result[0] + mul_result[1];\n      sum_tmp2 <= mul_result[2] + mul_result[3];\n    end\n  end\n\n\n  always @(posedge clk or negedge rst_n) begin\n    if(!rst_n) begin\n      mul_out <= 'd0;\n    end else begin\n      mul_out <= sum_tmp1 + sum_tmp2;\n    end\n  end\n\n\nendmodule\n\n"}
{"hash": "404ee5d7ca9fc69aec9d18f45741ffe273b958c4d84803a2e5ea4e50eb6ce28e", "equivalence_group": 27, "content": "\n\nmodule verified_parallel2serial\n(\n  input wire clk,\n  input wire rst_n,\n  input wire [3:0] d,\n  output wire valid_out,\n  output wire dout\n);\n\n  reg [3:0] data;assign data = 'd0;\n  reg [1:0] cnt;\n  reg valid;\n  assign dout = data[3];\n  assign valid_out = valid;\n\n  always @(posedge clk or negedge rst_n) begin\n    if(!rst_n) begin\n      data <= 'd0;\n      cnt <= 'd0;\n      valid <= 'd0;\n    end else begin\n      if(cnt == 'd3) begin\n        data <= d;\n        cnt <= 'd0;\n        valid <= 1;\n      end else begin\n        cnt <= cnt + 'd1;\n        valid <= 0;\n        data <= { data[2:0], data[3] };\n      end\n    end\n  end\n\n\nendmodule\n\n"}
{"hash": "6b1e2b6984dc28df3b21bfef20add72403c5840a4672ba0991e506ded312b1bd", "equivalence_group": 28, "content": "\n\nmodule verified_pe\n(\n  input clk,\n  input rst,\n  input [31:0] a,\n  input [31:0] b,\n  output [31:0] c\n);\n\n  reg [31:0] cc;\n  assign c = cc;\n\n  always @(posedge clk or posedge rst) begin\n    if(rst) begin\n      cc <= 0;\n    end else begin\n      cc <= cc + a * b;\n    end\n  end\n\n\nendmodule\n\n"}
{"hash": "c7a8f8b9b08610bdd051af382b7eb7f022a519c82aed1e21318ae69f39c1cd57", "equivalence_group": 29, "content": "\n\nmodule verified_pulse_detect\n(\n  input clk,\n  input rst_n,\n  input data_in,\n  output reg data_out\n);\n\n  parameter s0 = 2'b00;\n  parameter s1 = 2'b01;\n  parameter s2 = 2'b10;\n  parameter s3 = 2'b11;\n  reg [1:0] pulse_level1;reg [1:0] pulse_level2;\n\n  always @(posedge clk or negedge rst_n) begin\n    if(!rst_n) pulse_level1 <= s0; \n    else pulse_level1 <= pulse_level2;\n  end\n\n\n  always @(*) begin\n    case(pulse_level1)\n      s0: begin\n        if(data_in == 0) pulse_level2 = s1; \n        else pulse_level2 = s0;\n      end\n      s1: begin\n        if(data_in == 1) pulse_level2 = s2; \n        else pulse_level2 = s1;\n      end\n      s2: begin\n        if(data_in == 0) pulse_level2 = s3; \n        else pulse_level2 = s0;\n      end\n      s3: begin\n        if(data_in == 1) pulse_level2 = s2; \n        else pulse_level2 = s1;\n      end\n    endcase\n  end\n\n\n  always @(*) begin\n    if(~rst_n) data_out = 0; \n    else if((pulse_level1 == s2) && (data_in == 0)) data_out = 1; \n    else data_out = 0;\n  end\n\n\nendmodule\n\n"}
{"hash": "bc86e7b77e35039ef6c88d0b4349b1b1e33ad2a199d06b5dd15716b3ab562cea", "equivalence_group": 30, "content": "\n\nmodule verified_right_shifter\n(\n  clk,\n  q,\n  d\n);\n\n  input clk;\n  input d;\n  output [7:0] q;\n  reg [7:0] q;\n\n  initial q = 0;\n\n\n  always @(posedge clk) begin\n    q <= q >> 1;\n    q[7] <= d;\n  end\n\n\nendmodule\n\n"}
{"hash": "9cf0e2fc09d54e47ce126c040f5ac72e75af56b09419e2988f61048426b8cec5", "equivalence_group": 31, "content": "\n\nmodule ring_counter\n(\n  input wire clk,\n  input wire reset,\n  output reg [7:0] out\n);\n\n  reg [7:0] state;\n\n  always @(posedge clk or posedge reset) begin\n    if(reset) state <= 8'b0000_0001; \n    else state <= { state[6:0], state[7] };\n  end\n\n  assign out = state;\n\nendmodule\n\n"}
{"hash": "77cfe636a716d3e3f55c37193d16e331044dd1fe1d20f4e78cc313418630a71a", "equivalence_group": 32, "content": "\n\nmodule sequence_detector\n(\n  input clk,\n  input rst_n,\n  input data_in,\n  output sequence_detected\n);\n\n  parameter IDLE = 5'b00001;\n  parameter S1 = 5'b00010;\n  parameter S2 = 5'b00100;\n  parameter S3 = 5'b01000;\n  parameter S4 = 5'b10000;\n  reg [4:0] curr_state;\n  reg [4:0] next_state;\n\n  always @(posedge clk or negedge rst_n) begin\n    if(!rst_n) begin\n      curr_state <= IDLE;\n    end else begin\n      curr_state <= next_state;\n    end\n  end\n\n\n  always @(*) begin\n    if(!rst_n) begin\n      next_state <= IDLE;\n    end else begin\n      case(curr_state)\n        IDLE: next_state = (data_in)? S1 : IDLE;\n        S1: next_state = (data_in)? S1 : S2;\n        S2: next_state = (data_in)? S1 : S3;\n        S3: next_state = (data_in)? S4 : IDLE;\n        S4: next_state = (data_in)? S1 : S2;\n        default: next_state = IDLE;\n      endcase\n    end\n  end\n\n  assign sequence_detected = (curr_state == S4)? 1'b1 : 1'b0;\n\nendmodule\n\n"}
{"hash": "b33eb0a630ae458c1b503862833b30aed3c9e1d9e777ed62336c8d5b08df525c", "equivalence_group": 33, "content": "\n\nmodule verified_serial2parallel\n(\n  input clk,\n  input rst_n,\n  input din_serial,\n  input din_valid,\n  output reg [7:0] dout_parallel,\n  output reg dout_valid\n);\n\n  reg [7:0] din_tmp;\n  reg [3:0] cnt;\n\n  always @(posedge clk or negedge rst_n) begin\n    if(!rst_n) cnt <= 0; \n    else if(din_valid) cnt <= (cnt == 4'd8)? 0 : cnt + 1'b1; \n    else cnt <= 0;\n  end\n\n\n  always @(posedge clk or negedge rst_n) begin\n    if(!rst_n) din_tmp <= 8'b0; \n    else if(din_valid && (cnt <= 4'd7)) din_tmp <= { din_tmp[6:0], din_serial }; \n  end\n\n\n  always @(posedge clk or negedge rst_n) begin\n    if(!rst_n) begin\n      dout_valid <= 1'b0;\n      dout_parallel <= 8'b0;\n    end else if(cnt == 4'd8) begin\n      dout_valid <= 1'b1;\n      dout_parallel <= din_tmp;\n    end else begin\n      dout_valid <= 1'b0;\n    end\n  end\n\n\nendmodule\n\n"}
{"hash": "4e8b4fd20d766b0fe8a9b883bb2dc7428ffe0057721ef32498c326a7969aadcd", "equivalence_group": 34, "content": "\n\nmodule verified_signal_generator\n(\n  input clk,\n  input rst_n,\n  output reg [4:0] wave\n);\n\n  reg [1:0] state;\n\n  always @(posedge clk or negedge rst_n) begin\n    if(~rst_n) begin\n      state <= 2'b0;\n      wave <= 5'b0;\n    end else begin\n      case(state)\n        2'b00: begin\n          if(wave == 5'b11111) state <= 2'b01; \n          else wave <= wave + 1;\n        end\n        2'b01: begin\n          if(wave == 5'b00000) state <= 2'b00; \n          else wave <= wave - 1;\n        end\n      endcase\n    end\n  end\n\n\nendmodule\n\n"}
{"hash": "a76f8ca841677823fec8f4b3f348a84a6e80ae626a87b95667e6e757dacce430", "equivalence_group": 35, "content": "\n\nmodule square_wave\n(\n  input clk,\n  input [7:0] freq,\n  output reg wave_out\n);\n\n  reg [7:0] count;\n\n  initial begin\n    wave_out = 0;\n    count = 0;\n  end\n\n\n  always @(posedge clk) begin\n    if(count == freq - 1) begin\n      count <= 0;\n      wave_out <= ~wave_out;\n    end else begin\n      count <= count + 1;\n    end\n  end\n\n\nendmodule\n\n"}
{"hash": "d7b6d57bc47d612ed659041af8babffdf5e4a49ce75f24d2ec275cb911fbf7c7", "equivalence_group": 36, "content": "\n\nmodule sub_64bit\n(\n  input [63:0] A,\n  input [63:0] B,\n  output reg [63:0] result,\n  output reg overflow\n);\n\n\n  always @(*) begin\n    result = A - B;\n    if((A[63] != B[63]) && (result[63] != A[63])) begin\n      overflow = 1;\n    end else begin\n      overflow = 0;\n    end\n  end\n\n\nendmodule\n\n"}
{"hash": "b7fa8f175c9d69eac58e83db8832d3879a7d4c13220885488992f5bf5d5ccb4e", "equivalence_group": 37, "content": "\n\nmodule verified_traffic_light\n(\n  input rst_n,\n  input clk,\n  input pass_request,\n  output wire [7:0] clock,\n  output reg red,\n  output reg yellow,\n  output reg green\n);\n\n  parameter idle = 2'd0;parameter s1_red = 2'd1;parameter s2_yellow = 2'd2;parameter s3_green = 2'd3;\n  reg [7:0] cnt;\n  reg [1:0] state;\n  reg p_red;reg p_yellow;reg p_green;\n\n  always @(posedge clk or negedge rst_n) begin\n    if(!rst_n) begin\n      state <= idle;\n      p_red <= 1'b0;\n      p_green <= 1'b0;\n      p_yellow <= 1'b0;\n    end else case(state)\n      idle: begin\n        p_red <= 1'b0;\n        p_green <= 1'b0;\n        p_yellow <= 1'b0;\n        state <= s1_red;\n      end\n      s1_red: begin\n        p_red <= 1'b1;\n        p_green <= 1'b0;\n        p_yellow <= 1'b0;\n        if(cnt == 3) state <= s3_green; \n        else state <= s1_red;\n      end\n      s2_yellow: begin\n        p_red <= 1'b0;\n        p_green <= 1'b0;\n        p_yellow <= 1'b1;\n        if(cnt == 3) state <= s1_red; \n        else state <= s2_yellow;\n      end\n      s3_green: begin\n        p_red <= 1'b0;\n        p_green <= 1'b1;\n        p_yellow <= 1'b0;\n        if(cnt == 3) state <= s2_yellow; \n        else state <= s3_green;\n      end\n    endcase\n  end\n\n\n  always @(posedge clk or negedge rst_n) if(!rst_n) cnt <= 7'd10; \n  else if(pass_request && green && (cnt > 10)) cnt <= 7'd10; \n  else if(!green && p_green) cnt <= 7'd60; \n  else if(!yellow && p_yellow) cnt <= 7'd5; \n  else if(!red && p_red) cnt <= 7'd10; \n  else cnt <= cnt - 1;\n\n  assign clock = cnt;\n\n  always @(posedge clk or negedge rst_n) if(!rst_n) begin\n    yellow <= 1'd0;\n    red <= 1'd0;\n    green <= 1'd0;\n  end else begin\n    yellow <= p_yellow;\n    red <= p_red;\n    green <= p_green;\n  end\n\n\nendmodule\n\n"}
{"hash": "b4024da721d1520d7af1f24beb580cfccad63016571a079b235cccb4abbb6621", "equivalence_group": 38, "content": "\n\nmodule up_down_counter\n(\n  input wire clk,\n  input wire reset,\n  input wire up_down,\n  output reg [15:0] count\n);\n\n\n  always @(posedge clk or posedge reset) begin\n    if(reset) begin\n      count <= 16'b0;\n    end else begin\n      if(up_down) begin\n        if(count == 16'b1111_1111_1111_1111) begin\n          count <= 16'b0;\n        end else begin\n          count <= count + 1;\n        end\n      end else begin\n        if(count == 16'b0) begin\n          count <= 16'b1111_1111_1111_1111;\n        end else begin\n          count <= count - 1;\n        end\n      end\n    end\n  end\n\n\nendmodule\n\n"}
{"hash": "9eb582300ad1ee52bbad5854550a5021aabed7724beef312c0475029e4fae563", "equivalence_group": 39, "content": "\n\nmodule verified_width_8to16\n(\n  input clk,\n  input rst_n,\n  input valid_in,\n  input [7:0] data_in,\n  output reg valid_out,\n  output reg [15:0] data_out\n);\n\n  reg [7:0] data_lock;\n  reg flag;\n\n  always @(posedge clk or negedge rst_n) begin\n    if(!rst_n) data_lock <= 'd0; \n    else if(valid_in && !flag) data_lock <= data_in; \n  end\n\n\n  always @(posedge clk or negedge rst_n) begin\n    if(!rst_n) flag <= 'd0; \n    else if(valid_in) flag <= ~flag; \n  end\n\n\n  always @(posedge clk or negedge rst_n) begin\n    if(!rst_n) valid_out <= 'd0; \n    else if(valid_in && flag) valid_out <= 1'd1; \n    else valid_out <= 'd0;\n  end\n\n\n  always @(posedge clk or negedge rst_n) begin\n    if(!rst_n) data_out <= 'd0; \n    else if(valid_in && flag) data_out <= { data_lock, data_in }; \n  end\n\n\nendmodule\n\n"}
