{"is_valid": false, "question": "Design a 64-bit linear feedback shift register (LFSR) module with synchronous reset. The module should implement the following behavior:\n\n1. On the negative edge of reset (active-low), the register should clear to all zeros.\n2. On each positive clock edge when reset is not active:\n   - If the least significant bit (LSQ[0]) is 0, perform a right shift and insert a 1 at the MSB\n   - If the least significant bit is 1, perform a right shift and insert a 0 at the MSB\n\nThe module should have:\n- Clock input (clk)\n- Active-low synchronous reset input (rst_n)\n- 64-bit register output (Q)\n\nAssume all inputs are glitch-free and meet setup/hold times. The implementation must be purely synchronous with no combinatorial paths on the output.\n\nNote: This is a modified LFSR that doesn't use XOR feedback, but instead toggles the inserted bit based on the shifted-out value."}
{"is_valid": false, "question": "Design a 4-bit linear feedback shift register (LFSR) with synchronous reset. The module should have the following specifications:\n\nInputs:\n- clk: clock signal (positive edge triggered)\n- rst: synchronous reset signal (active high)\n\nOutput:\n- out: 4-bit register output\n\nBehavior:\n1. On reset (rst=1), the output should be cleared to 0 on the next positive clock edge.\n2. When not in reset, the register should shift left by 1 bit each clock cycle.\n3. The new least significant bit (LSB) should be calculated as the XNOR of bits 3 and 2 of the current output (feedback taps at positions 3 and 2).\n4. The initial state after reset should be 0000, and subsequent states should follow the LFSR sequence.\n\nNote: The LFSR should implement the standard maximal-length sequence for a 4-bit register with taps at positions 3 and 2.\n\nExample sequence starting from 0000:\n0000 \u2192 0001 \u2192 0011 \u2192 0111 \u2192 1111 \u2192 1110 \u2192 1101 \u2192 1010 \u2192 0101 \u2192 1011 \u2192 0110 \u2192 1100 \u2192 1001 \u2192 0010 \u2192 0100 \u2192 1000 \u2192 0001..."}
{"is_valid": false, "question": "Design a 4-level deep, 4-bit wide stack memory module in Verilog with the following specifications:\n\nInputs:\n- dataIn[3:0]: 4-bit input data\n- RW: Read/Write control (0 = write, 1 = read)\n- EN: Enable signal (active high)\n- Rst: Synchronous reset (active high)\n- Clk: Clock input (positive edge triggered)\n\nOutputs:\n- EMPTY: Flag indicating stack is empty (active high)\n- FULL: Flag indicating stack is full (active high)\n- dataOut[3:0]: 4-bit output data (valid only during read operations)\n\nBehavior:\n1. The stack should operate synchronously on the positive clock edge when EN is high\n2. Reset (when high) should:\n   - Clear all stack locations\n   - Set the stack pointer to empty state\n   - Clear dataOut\n3. Write operations (RW=0) should:\n   - Push dataIn onto stack if not FULL\n   - Update stack pointer and flags\n4. Read operations (RW=1) should:\n   - Pop data from stack if not EMPTY\n   - Output the popped value on dataOut\n   - Update stack pointer and flags\n5. Flags should update immediately after each operation:\n   - EMPTY high when stack is empty\n   - FULL high when stack is full\n6. dataOut should be undefined (x) when not performing a valid read\n\nHandle all edge cases including attempts to read from empty or write to full stacks."}
{"is_valid": false, "question": "Design a synchronous RAM module with the following specifications:\n\nInputs:\n- clk: system clock (posedge triggered)\n- rst_n: active-low synchronous reset\n- write_en: write enable signal\n- write_addr[7:0]: 8-bit write address\n- write_data[5:0]: 6-bit data to write\n- read_en: read enable signal\n- read_addr[7:0]: 8-bit read address\n\nOutput:\n- read_data[5:0]: 6-bit read data\n\nBehavior:\n1. The module should implement a RAM with 12 locations (addresses 0-11)\n2. On reset (rst_n=0), all RAM locations should be cleared to 0\n3. When write_en=1 at clock posedge, write_data should be stored at write_addr\n4. When read_en=1 at clock posedge, read_data should output the value at read_addr\n5. When read_en=0, read_data should output 0\n6. Read and write operations should be synchronous to clock posedge\n7. Unused addresses (12-255) should not be written to or read from\n\nAssume all inputs change synchronously with respect to the clock edge."}
{"is_valid": false, "question": "Design a Verilog module that implements a read-only memory (ROM) with the following specifications:\n\n1. The module should have:\n   - An 8-bit input 'addr' for memory addressing\n   - A 16-bit output 'dout' for data output\n\n2. Memory initialization requirements:\n   - The ROM should contain 256 memory locations (0-255)\n   - Preload the first 4 memory locations with these values:\n     * Address 0: 0xA0A0\n     * Address 1: 0xB1B1\n     * Address 2: 0xC2C2\n     * Address 3: 0xD3D3\n   - All other locations can contain undefined values (don't care)\n\n3. Functional behavior:\n   - The output 'dout' should continuously reflect the content of the memory location specified by 'addr'\n   - The read operation should be combinational (no clock required)\n   - The output should update immediately when 'addr' changes\n\nDo not implement any write functionality - this should be a pure read-only memory."}
{"is_valid": false, "question": "Design a Verilog module that accumulates input values over 4 clock cycles and outputs the sum. The module should have the following specifications:\n\nInputs:\n- clk: system clock\n- rst_n: active-low asynchronous reset\n- data_in: 8-bit input data\n- valid_in: input valid signal (1 when data_in is valid)\n\nOutputs:\n- valid_out: output valid signal (1 when data_out is valid)\n- data_out: 10-bit accumulated output (must accommodate sum of four 8-bit values)\n\nBehavior:\n1. On each valid_in pulse, accumulate the data_in value into an internal sum\n2. After exactly 4 valid inputs, output the accumulated sum on data_out and assert valid_out for one cycle\n3. The accumulation window should restart immediately after each 4-input cycle\n4. If rst_n is asserted, all registers should reset to 0\n5. The module should ignore data_in when valid_in is low\n6. The output sum should be available in the same cycle as the 4th valid input\n\nTiming:\n- All operations should be synchronous to the rising edge of clk\n- Reset should be asynchronous and active-low\n\nAssume no overflow will occur in the 10-bit output."}
{"is_valid": true, "question": "Design a 16-bit carry-propagate adder module in Verilog that computes the sum of two 16-bit inputs with carry-in and produces a 16-bit output with carry-out. The adder must be implemented using a hierarchical structure of smaller adders, following these requirements:\n\n1. The top-level module must use two 8-bit adders\n2. Each 8-bit adder must use two 4-bit adders\n3. Each 4-bit adder must use two 2-bit adders\n4. Each 2-bit adder must use two 1-bit full adders\n5. The 1-bit full adder must implement both sum and carry-out logic using basic gates\n\nInputs:\n- a[15:0]: First 16-bit operand\n- b[15:0]: Second 16-bit operand\n- Cin: Carry-in bit\n\nOutputs:\n- y[15:0]: 16-bit sum result\n- Co: Carry-out bit\n\nThe module must propagate carries correctly between all hierarchical levels. All operations should be combinational (no clock or reset signals). Name the top-level module 'dut' and use the exact interface specified above."}
{"is_valid": false, "question": "Design an 8-bit ripple carry adder module in Verilog with the following specifications:\n\nInputs:\n- Two 8-bit unsigned numbers: a[7:0] and b[7:0]\n- A single-bit carry-in: cin\n\nOutputs:\n- An 8-bit sum output: sum[7:0]\n- A single-bit carry-out: cout\n\nBehavior:\nThe module should compute the sum of a, b, and cin using a ripple carry structure. Each bit position should be processed sequentially, with the carry-out from one stage becoming the carry-in to the next. The final carry-out (cout) should reflect any overflow from the most significant bit addition.\n\nImplementation Constraints:\n- You must use a pre-defined full adder module (dut_dependency_2) for each bit position\n- The full adder module has ports (a, b, cin, sum, cout) and computes {cout, sum} = a + b + cin\n- Do not use arithmetic operators directly in your top module\n- All connections between full adders must be explicit\n\nThe module should be purely combinational with no clock inputs or sequential elements."}
{"is_valid": true, "question": "Design a 4-bit BCD (Binary Coded Decimal) adder module that correctly handles decimal digit addition with carry. The module should take two 4-bit BCD digits (A and B) and a carry-in bit (Cin), and produce a 4-bit BCD sum (Sum) and a carry-out bit (Cout).\n\nInputs:\n- A[3:0]: First 4-bit BCD digit (0-9)\n- B[3:0]: Second 4-bit BCD digit (0-9)\n- Cin: Carry-in bit (0 or 1)\n\nOutputs:\n- Sum[3:0]: Corrected 4-bit BCD sum digit (0-9)\n- Cout: Carry-out bit (1 if sum exceeds 9, 0 otherwise)\n\nBehavior:\n1. The module must first compute the raw binary sum of A + B + Cin\n2. If this raw sum exceeds 9 (decimal), the module must:\n   - Set Cout to 1\n   - Add 6 (binary 0110) to the raw sum to correct it to valid BCD\n3. If the raw sum is \u22649, output it unchanged with Cout=0\n4. All operations should be combinational (no clock required)\n\nNote: The inputs A and B are guaranteed to be valid BCD digits (0000-1001). The output Sum must always be a valid BCD digit (0000-1001) when Cout=0, or (0000-0100) when Cout=1.\n\nExample cases:\n- A=4, B=5, Cin=0 \u2192 Sum=9, Cout=0\n- A=9, B=1, Cin=0 \u2192 Sum=0, Cout=1\n- A=8, B=8, Cin=1 \u2192 Sum=7, Cout=1"}
{"is_valid": false, "question": "Design a 32-bit Arithmetic Logic Unit (ALU) that performs various arithmetic and logical operations based on a 6-bit control signal. The ALU should support both signed and unsigned operations with appropriate flag generation.\n\nInputs:\n- a, b: 32-bit operands\n- aluc: 6-bit operation code specifying the ALU operation\n\nOutputs:\n- r: 32-bit result of the operation\n- zero: 1 when result equals zero\n- carry: Carry-out from arithmetic operations (reserved for future use)\n- negative: 1 when result is negative (MSB is 1)\n- overflow: Overflow flag for signed arithmetic (reserved for future use)\n- flag: Comparison result for SLT/SLTU operations, high-Z otherwise\n\nSupported Operations:\n- Arithmetic: ADD (signed), ADDU (unsigned), SUB (signed), SUBU (unsigned)\n- Logical: AND, OR, XOR, NOR\n- Comparisons: SLT (signed), SLTU (unsigned)\n- Shifts: SLL, SRL, SRA (arithmetic), SLLV, SRLV, SRAV (variable)\n- Special: LUI (load upper immediate)\n\nBehavior:\n1. The ALU should compute the result combinationally whenever inputs change\n2. For SLT/SLTU operations, set flag=1 if a<b, 0 otherwise (output high-Z for other ops)\n3. Set zero=1 when the result equals zero\n4. All outputs except flag should be valid for all operations\n5. Default output should be high-Z for unsupported opcodes\n\nNote: The carry and overflow outputs are reserved for future use but must be included in the interface."}
{"is_valid": false, "question": "Design a synchronous FIFO (First-In-First-Out) buffer with the following specifications:\n\n1. The FIFO must support independent read and write clocks (asynchronous operation)\n2. Interface:\n   - Write side:\n     - wclk: write clock\n     - wrstn: active-low write reset\n     - winc: write increment (assert to write when not full)\n     - wdata: input data (WIDTH bits)\n     - wfull: full status flag\n   - Read side:\n     - rclk: read clock\n     - rrstn: active-low read reset\n     - rinc: read increment (assert to read when not empty)\n     - rdata: output data (WIDTH bits)\n     - rempty: empty status flag\n\n3. Behavior:\n   - Write operation occurs on wclk posedge when winc is high and FIFO is not full\n   - Read operation occurs on rclk posedge when rinc is high and FIFO is not empty\n   - Status flags (wfull/rempty) must be properly synchronized across clock domains\n   - The FIFO should be parameterizable with WIDTH (data width) and DEPTH (number of entries)\n\n4. Implementation Constraints:\n   - Use Gray code for cross-clock domain synchronization\n   - The FIFO must correctly handle all edge cases (full/empty conditions)\n   - Do not use any external IP or vendor-specific primitives\n\nThe FIFO should maintain correct operation during concurrent reads and writes, and properly handle reset conditions for both clock domains."}
{"is_valid": false, "question": "Design an 8-bit data processing module that performs conditional bit manipulation based on a 3-bit control signal. The module should have the following interface:\n- Input: 8-bit data `in[7:0]`\n- Input: 3-bit control signal `ctrl[2:0]`\n- Output: 8-bit result `out[7:0]`\n\nThe module must process the input data in three stages, with each stage controlled by one bit of `ctrl` (MSB to LSB):\n\nStage 1 (ctrl[2]):\n- For bits [7:4]: Select between input bit or 0\n- For bits [3:0]: Select between input bit or corresponding upper nibble bit (bit 3\u21907, 2\u21906, 1\u21905, 0\u21904)\n\nStage 2 (ctrl[1]):\n- For bits [7:6]: Select between Stage 1 result or 0\n- For bits [5:0]: Select between Stage 1 result or corresponding bit shifted left by 2 (bit 5\u21907, 4\u21906, etc.)\n\nStage 3 (ctrl[0]):\n- For bit 7: Select between Stage 2 result or 0\n- For bits [6:0]: Select between Stage 2 result or corresponding next higher bit (bit 6\u21907, 5\u21906, etc.)\n\nEach selection should be implemented using a 2:1 multiplexer primitive (provided as `dut_dependency_2`). The module should be purely combinational with no clock input."}
{"is_valid": true, "question": "Design a digital clock module that tracks hours, minutes, and seconds. The module should have the following specifications:\n\nInputs:\n- CLK: Clock signal (positive edge triggered)\n- RST: Asynchronous reset (active high)\n\nOutputs (all 6-bit unsigned):\n- Hours (0-23)\n- Mins (0-59)\n- Secs (0-59)\n\nBehavior:\n1. On reset (RST=1), all outputs should be cleared to 0\n2. On each positive clock edge when not in reset:\n   - Seconds should increment by 1, rolling over to 0 after 59\n   - Minutes should increment by 1 when seconds roll over from 59 to 0, rolling over to 0 after 59\n   - Hours should increment by 1 when both minutes and seconds roll over, rolling over to 0 after 23\n\nAll outputs should maintain their values until the next relevant clock edge. The module should properly handle all rollover conditions between time units.\n\nAssume all outputs are registered (updated only on clock edges). Do not implement any additional features like time setting or alarms."}
{"is_valid": true, "question": "# Clock Generator Module\n\nDesign a Verilog module that generates a continuous clock signal with a configurable period. The module should meet the following specifications:\n\n## Interface\n- Output: `clk` (1-bit reg) - The generated clock signal\n\n## Parameters\n- `PERIOD` (default 10 time units) - The total period of the clock signal (high + low time)\n\n## Requirements\n1. The clock should start low (0) when simulation begins\n2. The clock should toggle every half period (PERIOD/2)\n3. The toggling should continue indefinitely throughout simulation\n4. The clock transitions should be precise with respect to the specified period\n\n## Notes\n- Use time units consistently (don't mix different time scales)\n- The solution should be synthesizable for simulation purposes\n- Do not use any initial blocks for the clock generation logic (except for initialization)\n- The module should not have any inputs\n\nThe module should be named `dut` and use exactly the interface specified above."}
{"is_valid": true, "question": "Design a 3-bit magnitude comparator module that compares two unsigned 3-bit numbers and outputs three status signals indicating their relative magnitudes. \n\nThe module should have:\n- Two 3-bit unsigned input ports A and B\n- Three 1-bit output ports:\n  * A_greater: high when A > B\n  * A_equal: high when A == B\n  * A_less: high when A < B\n\nAll outputs should be combinational (continuously assigned) and update immediately when either input changes. Only one output should be high at any given time. The comparison should be performed as unsigned arithmetic.\n\nFor example:\n- If A = 3'b101 (5) and B = 3'b011 (3), outputs should be:\n  A_greater = 1, A_equal = 0, A_less = 0\n- If A = 3'b010 (2) and B = 3'b010 (2), outputs should be:\n  A_greater = 0, A_equal = 1, A_less = 0\n- If A = 3'b000 (0) and B = 3'b001 (1), outputs should be:\n  A_greater = 0, A_equal = 0, A_less = 1\n\nThe module should be purely combinational with no clock or reset inputs."}
{"is_valid": true, "question": "Design a 4-bit magnitude comparator module that compares two unsigned 4-bit numbers and outputs three status signals indicating their relative magnitude. \n\nThe module should have:\n- Two 4-bit unsigned inputs: A and B\n- Three 1-bit outputs:\n  * A_greater: high when A > B\n  * A_equal: high when A == B\n  * A_less: high when A < B\n\nAll outputs should be purely combinational (no clock or reset required). The outputs must be mutually exclusive - exactly one output should be high at any time. The comparison should be performed using unsigned arithmetic.\n\nFor example:\n- If A=5 (0101) and B=3 (0011), outputs should be A_greater=1, A_equal=0, A_less=0\n- If A=4 (0100) and B=4 (0100), outputs should be A_greater=0, A_equal=1, A_less=0\n- If A=2 (0010) and B=7 (0111), outputs should be A_greater=0, A_equal=0, A_less=1\n\nThe implementation should use minimal logic gates while meeting the specified behavior."}
{"is_valid": false, "question": "Design a synchronous 4-bit counter module with the following specifications:\n\nInputs:\n- clk: System clock (positive edge triggered)\n- rst_n: Active-low synchronous reset (resets counter to 0 when low)\n- valid_count: When high, enables counting on the next clock edge\n\nOutput:\n- out: 4-bit counter value (0 to 11)\n\nBehavior:\n1. The counter should increment by 1 on each positive clock edge when valid_count is high\n2. When the counter reaches 11 (4'b1011), it should wrap around to 0 on the next valid increment\n3. When valid_count is low, the counter should maintain its current value\n4. The counter should reset to 0 when rst_n is low (synchronous reset)\n\nAll operations must be synchronous to the positive clock edge. The counter should never exceed 11 (4'b1011) or go below 0.\n\nExample:\n- Reset sequence: rst_n=0 \u2192 out=0\n- Counting sequence (with valid_count=1): 0\u21921\u21922...\u219211\u21920\u21921...\n- Hold sequence (valid_count=0): out maintains current value"}
{"is_valid": true, "question": "Design a Verilog module that performs division and remainder operations on two unsigned numbers. The module should have the following interface:\n\nInputs:\n- A: 16-bit unsigned dividend\n- B: 8-bit unsigned divisor\n\nOutputs:\n- result: 16-bit quotient (A divided by B)\n- odd: 16-bit remainder (A modulo B)\n\nRequirements:\n1. The module must compute both quotient and remainder simultaneously.\n2. The division should be implemented using a non-restoring division algorithm.\n3. All operations must be purely combinational (no clock required).\n4. The outputs should be ready within one combinational delay after inputs change.\n5. Handle all possible input combinations where B \u2260 0 (behavior when B=0 is undefined).\n\nExample:\nIf A = 1000 (0x03E8) and B = 3 (0x03), then:\n- result should be 333 (0x014D)\n- odd should be 1 (0x0001)\n\nThe module should be optimized for area rather than speed, as it's meant for low-frequency applications."}
{"is_valid": false, "question": "**Edge Detector Module**\n\nDesign a synchronous edge detector module that identifies rising and falling edges of an input signal. The module should operate on the positive edge of the clock and have an active-low asynchronous reset.\n\n**Interface:**\n- `clk`: System clock (positive edge triggered)\n- `rst_n`: Active-low asynchronous reset\n- `a`: Input signal to monitor\n- `rise`: Output pulse (1 clock cycle) when rising edge detected on `a`\n- `down`: Output pulse (1 clock cycle) when falling edge detected on `a`\n\n**Requirements:**\n1. On reset (`rst_n=0`), all outputs should be cleared immediately.\n2. When `a` transitions from 0 to 1, assert `rise` for exactly one clock cycle.\n3. When `a` transitions from 1 to 0, assert `down` for exactly one clock cycle.\n4. If no edge is detected, both outputs should remain 0.\n5. The outputs (`rise` and `down`) should never be asserted simultaneously.\n6. All operations must be synchronous to the positive clock edge except reset.\n\n**Note:** The module should properly handle cases where `a` changes multiple times between clock edges, only detecting the final state transition.\n\n**Example Waveform:**\n```\nClock:  _|\u203e|_|\u203e|_|\u203e|_|\u203e|_|\u203e|_|\u203e|_|\u203e\na:      _____|\u203e\u203e\u203e|_____|\u203e\u203e|_____\nrise:   ________|_____|_________\ndown:   _____________|_____|____\n```"}
{"is_valid": true, "question": "Design a signed magnitude adder module that operates on N-bit numbers in signed magnitude representation. The module should add two inputs and produce the correct signed magnitude output according to the following rules:\n\n1. The most significant bit (MSB) represents the sign (0 for positive, 1 for negative)\n2. The remaining N-1 bits represent the magnitude (absolute value)\n3. When signs are equal, add magnitudes and keep the same sign\n4. When signs differ:\n   - Subtract smaller magnitude from larger magnitude\n   - Result sign matches the input with larger magnitude\n   - If magnitudes are equal, result should be positive zero (all bits 0)\n\nInputs:\n- a, b: Two N-bit signed magnitude numbers (default N=32)\n- Q parameter is unused in this implementation\n\nOutput:\n- c: N-bit signed magnitude result of a + b\n\nThe module should update the output combinationally whenever either input changes. Handle all edge cases including zero results and magnitude overflow (you may assume magnitudes won't overflow).\n\nExample cases:\n- 0x80000001 + 0x00000001 = 0x80000002 (-1 + 1 = -2)\n- 0x80000005 + 0x00000003 = 0x80000002 (-5 + 3 = -2)\n- 0x00000005 + 0x80000003 = 0x00000002 (5 + -3 = 2)\n- 0x00000003 + 0x80000003 = 0x00000000 (3 + -3 = 0)"}
{"is_valid": false, "question": "Design a signed number arithmetic module that performs specialized addition/subtraction on two N-bit signed numbers in Q-format fixed-point representation. The module should have the following behavior:\n\nInputs:\n- a, b: Two N-bit signed numbers where the most significant bit (MSB) is the sign bit (0 for positive, 1 for negative) and the remaining N-1 bits represent the magnitude in Q-format.\n\nOutput:\n- c: An N-bit result with the same format as inputs.\n\nBehavior:\n1. When both inputs have the same sign (both positive or both negative), subtract the smaller magnitude from the larger one and keep the original sign.\n2. When signs differ:\n   - If the positive number's magnitude is larger, add the magnitudes and set the result as positive.\n   - If the negative number's magnitude is larger, add the magnitudes and set the result as negative.\n   - If magnitudes are equal, the result should be positive zero (all bits 0).\n   \nThe output should update combinationally whenever either input changes. The module should be parameterizable with Q (fractional bits) and N (total bits), defaulting to Q=15 and N=32.\n\nAssume no overflow will occur in the magnitude calculations."}
{"is_valid": false, "question": "Design a clock divider module that generates three output clocks with different frequencies from a single input clock. The module should have the following specifications:\n\nInputs:\n- CLK_in: The input clock signal\n- RST: Active-high synchronous reset\n\nOutputs:\n- CLK_50: A clock signal with exactly half the frequency of CLK_in (50% duty cycle)\n- CLK_10: A clock signal with exactly 1/10th the frequency of CLK_in (50% duty cycle)\n- CLK_1: A clock signal with exactly 1/100th the frequency of CLK_in (50% duty cycle)\n\nRequirements:\n1. All output clocks must be synchronous to the positive edge of CLK_in\n2. All output clocks must reset to 0 when RST is asserted\n3. The frequency division must be exact (no skipped or extra cycles)\n4. All output clocks must maintain a 50% duty cycle\n5. The module should use minimal hardware resources\n\nAssume all signals are 1-bit unless otherwise specified. The module should be purely synchronous (no asynchronous logic except for reset)."}
{"is_valid": true, "question": "Design a clock divider module that generates a divided clock signal with a configurable division ratio. The module should have the following specifications:\n\nInputs:\n- clk: The input clock signal (positive edge triggered)\n- rst_n: Active-low asynchronous reset signal\n\nOutput:\n- clk_div: Divided clock output signal\n\nBehavior:\n1. When reset is active (rst_n = 0), the output clock (clk_div) should be 0 and the internal counter should reset to 0.\n2. When reset is inactive, the module should divide the input clock frequency by NUM_DIV (a parameter with value 6 in this case).\n3. The divided clock should have a 50% duty cycle (equal high and low times).\n4. The counter and output should update synchronously on positive edges of the input clock.\n\nAssume NUM_DIV is always an even number greater than 0. The division should be implemented using a counter that counts input clock cycles and toggles the output clock when appropriate to achieve the specified division ratio and duty cycle.\n\nDo not use any initial blocks or behavioral modeling beyond what's necessary for the described functionality."}
{"is_valid": false, "question": "Design a clock divider module that generates a divided clock signal with a specific duty cycle. The module should have the following specifications:\n\nInputs:\n- clk: The input clock signal\n- rst_n: Active-low reset signal (asynchronous)\n\nOutput:\n- clk_div: Divided clock output\n\nBehavior:\n1. The output clock frequency should be exactly 1/7th of the input clock frequency (MUL2_DIV_CLK = 7)\n2. The output clock should have a 50% duty cycle (high for exactly half the period)\n3. The reset should asynchronously clear all internal state and force clk_div low\n4. All output transitions must be synchronized to either the positive or negative edge of the input clock\n\nTiming Requirements:\n- The output clock edges should be precisely aligned with input clock edges\n- The first rising edge after reset should occur on the first positive clock edge where the internal counter equals 0\n- The falling edge should occur when the internal counter reaches MUL2_DIV_CLK/2 + 1\n\nDo not use any clock gating or combinational logic that could create glitches on the output clock."}
{"is_valid": false, "question": "Design a clock divider module that generates a symmetric output clock with a frequency equal to 1/5th of the input clock frequency. The module should meet the following specifications:\n\nInputs:\n- clk: The input clock signal\n- rst_n: Active-low asynchronous reset\n\nOutput:\n- clk_div: The divided output clock signal (must be symmetric with 50% duty cycle)\n\nBehavior:\n1. On reset (rst_n=0), the output clock should be initialized to high (1'b1)\n2. The output frequency must be exactly 1/5th of the input frequency\n3. The output clock must maintain a perfect 50% duty cycle (high for 2.5 input clock cycles, low for 2.5 input clock cycles)\n4. The output transitions should be aligned with both rising and falling edges of the input clock to achieve the symmetric waveform\n5. All state changes should occur synchronously with respect to the input clock edges\n\nAssume the division ratio is fixed at 5 (do not make it configurable). The implementation must use only the provided I/O signals without any additional ports."}
{"is_valid": false, "question": "Design a finite state machine (FSM) that detects a specific pattern in a serial input stream. The FSM should have the following specifications:\n\nInputs:\n- IN: 1-bit serial input (synchronized to clock)\n- CLK: Clock signal (positive edge triggered)\n- RST: Asynchronous active-high reset\n\nOutput:\n- MATCH: 1-bit output that goes high for one clock cycle when the pattern is detected\n\nBehavior:\n1. The FSM should detect the pattern \"0001\" followed by \"1\" (i.e., \"00011\" in total)\n2. The detection should be overlapping - new patterns can start before previous ones complete\n3. MATCH should pulse high (for one cycle) immediately when the final \"1\" in the pattern is received\n4. The FSM should reset to its initial state when RST is high\n5. All state transitions and outputs should be synchronous to the positive clock edge, except for reset which is asynchronous\n\nExample:\nInput:  0 1 0 0 0 1 1 0 1 0 0 0 1 1 0\nOutput: 0 0 0 0 0 0 1 0 0 0 0 0 0 1 0\n(Output pulses occur at the 6th and 13th cycles)\n\nNote: Implement the FSM using a Moore or Mealy machine approach as appropriate."}
{"is_valid": true, "question": "Design a Verilog module that implements a two-stage instruction fetch and decode unit. The module should have the following interface:\n\nInputs:\n- clk: System clock (positive edge triggered)\n- rst: Active-low asynchronous reset\n- fetch[1:0]: Control signal indicating fetch operation:\n  * 2'b01: Fetch first instruction part\n  * 2'b10: Fetch second instruction part\n  * Other values: No fetch operation\n- data[7:0]: Input data bus for instruction parts\n\nOutputs:\n- ins[2:0]: Decoded 3-bit instruction opcode (from first part)\n- ad1[4:0]: 5-bit address field (from first part)\n- ad2[7:0]: 8-bit address field (from second part)\n\nBehavior:\n1. On reset (rst=0), clear all internal registers\n2. When fetch=01 on clock edge, store data in the first instruction part register\n3. When fetch=10 on clock edge, store data in the second instruction part register\n4. The outputs should be continuously assigned as:\n   - ins = upper 3 bits of first instruction part\n   - ad1 = lower 5 bits of first instruction part\n   - ad2 = full 8 bits of second instruction part\n5. When no fetch operation is requested, maintain current register values\n\nThe module should properly handle all edge cases including back-to-back fetch operations and reset conditions."}
{"is_valid": false, "question": "Design a sequential multiplier module that computes the product of two 16-bit unsigned integers using a shift-and-add algorithm. The module should meet the following specifications:\n\nInputs:\n- clk: system clock\n- rst_n: active-low synchronous reset\n- start: pulse to begin multiplication (asserted for at least 1 cycle)\n- ain[15:0]: first operand (16-bit unsigned)\n- bin[15:0]: second operand (16-bit unsigned)\n\nOutputs:\n- yout[31:0]: 32-bit product result\n- done: status flag (high when result is valid)\n\nBehavior:\n1. On reset, all internal state should be cleared (outputs zero, done=0)\n2. When start is asserted, the module should:\n   - Capture the input operands\n   - Begin multiplication using a shift-and-add approach\n   - Take exactly 16 clock cycles to complete\n3. The done flag should:\n   - Go high for exactly 1 cycle when the result is valid\n   - Remain low at all other times\n4. The module should ignore new start pulses while busy (during the 16-cycle computation)\n5. The result should appear on yout when done is high and remain stable until the next operation\n\nAssume:\n- Inputs will be stable during the start cycle\n- Start pulses will be spaced at least 17 cycles apart"}
{"is_valid": false, "question": "Design a parameterized 4-bit multiplier module that calculates the product of two unsigned numbers using a shift-and-add approach. The module should meet the following specifications:\n\nInputs:\n- clk: System clock (positive edge triggered)\n- rst_n: Active-low synchronous reset\n- mul_a: First 4-bit multiplicand (parameterized width)\n- mul_b: Second 4-bit multiplicand (parameterized width)\n\nOutput:\n- mul_out: 8-bit product (parameterized width = 2\u00d7input width)\n\nBehavior:\n1. The module must implement multiplication by generating partial products for each bit of mul_b, shifting mul_a appropriately, and accumulating the results.\n2. The multiplication should complete in 2 clock cycles:\n   - First cycle: Compute intermediate sums of partial products (0+1 and 2+3)\n   - Second cycle: Sum the intermediate results to produce the final product\n3. All operations must be registered and synchronous to the positive clock edge.\n4. The output should reset to 0 when rst_n is asserted.\n\nThe module should be parameterized with 'size' (default 4) to support different input widths, with the output width automatically scaling to 2\u00d7size. Assume all inputs are valid when the clock rises."}
{"is_valid": false, "question": "Design a parameterized pipelined multiplier module with the following specifications:\n\nInputs:\n- clk: System clock (positive edge triggered)\n- rst_n: Active-low synchronous reset\n- mul_a, mul_b: Two size-bit input operands (default size=8)\n- mul_en_in: Input enable signal (active high)\n\nOutputs:\n- mul_out: 2*size-bit multiplication result (valid only when mul_en_out is high)\n- mul_en_out: Output enable signal (active high)\n\nBehavior:\n1. The module should implement a 3-cycle pipelined multiplication of mul_a \u00d7 mul_b\n2. The input operands should be captured on the clock cycle when mul_en_in is high\n3. The output should be valid exactly 3 cycles after the input enable (mul_en_out high)\n4. When mul_en_out is low, mul_out should be zero\n5. All registers should reset to zero when rst_n is low\n\nTiming Requirements:\n- Cycle 1: Capture inputs when mul_en_in is high\n- Cycle 2: Compute partial products\n- Cycle 3: Sum partial products\n- Cycle 4: Output final result (with mul_en_out high)\n\nThe module should maintain proper pipeline synchronization such that the output enable signal correctly tracks the computation pipeline stages."}
{"is_valid": false, "question": "Design a serial output module that processes 4-bit parallel input data and outputs it serially. The module should have the following specifications:\n\nInputs:\n- clk: System clock (positive edge triggered)\n- rst_n: Active-low asynchronous reset\n- d[3:0]: 4-bit parallel input data\n\nOutputs:\n- valid_out: Asserted high when new data is being output\n- dout: Serial output bit\n\nBehavior:\n1. On reset, all internal state should be cleared and outputs set to 0\n2. The module should sample new 4-bit parallel data every 4 clock cycles\n3. When new data is sampled (every 4th cycle):\n   - valid_out should be asserted high for one cycle\n   - The data should be loaded into an internal shift register\n4. For the next 3 cycles after loading:\n   - valid_out should remain low\n   - The shift register should rotate left by 1 bit each cycle\n5. The serial output (dout) should always present the MSB of the shift register\n\nNote: The module should maintain this behavior continuously after reset, processing new data every 4 cycles."}
{"is_valid": false, "question": "Design a Verilog module that implements an accumulating multiplier with synchronous reset. The module should have the following interface:\n\nInputs:\n- clk: clock signal (positive edge triggered)\n- rst: synchronous reset (active high)\n- a: 32-bit multiplicand\n- b: 32-bit multiplier\n\nOutput:\n- c: 32-bit accumulated result\n\nBehavior:\n1. On every positive clock edge when rst is low, the module should multiply inputs a and b and add the product to the current accumulated value of c.\n2. When rst is high on the clock edge, the accumulated value c should be cleared to 0.\n3. The output c should always reflect the current accumulated value.\n\nTiming Requirements:\n- All operations must be synchronous to the positive edge of clk\n- The reset operation takes precedence over accumulation when both conditions occur on the same clock edge\n\nAssume all arithmetic operations wrap around on overflow (standard Verilog behavior).\n\nThe module should be purely synchronous with no combinational paths from inputs to outputs except for the direct connection to c."}
{"is_valid": false, "question": "Design a synchronous finite state machine (FSM) that detects a specific pulse pattern in an input stream and generates a single-cycle output pulse when detected. The module should have the following specifications:\n\nInputs:\n- clk: System clock (positive edge triggered)\n- rst_n: Active-low synchronous reset\n- data_in: Serial input bit stream (1-bit)\n\nOutput:\n- data_out: Detection pulse (1-bit, high for one clock cycle when pattern is detected)\n\nBehavior:\n1. The FSM should detect the pattern \"010\" in the input stream (three consecutive bits where the first is 0, second is 1, and third is 0)\n2. The output pulse (data_out) should be high for exactly one clock cycle when the third bit (0) of the pattern is received\n3. The detection should be non-overlapping (after detecting a complete pattern, the FSM should start looking for a new pattern from scratch)\n4. All state transitions and outputs should be synchronous to the positive clock edge\n5. The FSM should reset to its initial state when rst_n is low\n\nAdditional Requirements:\n- The output should only depend on the current state and current input\n- The FSM should be implemented using a Moore machine approach\n- Use exactly 4 states in your implementation\n\nAssume all inputs are glitch-free and meet setup/hold times relative to the clock."}
{"is_valid": false, "question": "Design a signed/unsigned division module that computes both quotient and remainder for 8-bit inputs. The module should:\n\n1. Interface:\n   - Clock (clk) and active-high reset (rst)\n   - Inputs: \n     * dividend[7:0] and divisor[7:0] (8-bit operands)\n     * sign (1-bit control: 1 for signed, 0 for unsigned division)\n     * opn_valid (1-bit input valid signal)\n     * res_ready (1-bit output ready signal)\n   - Outputs:\n     * result[15:0] (16-bit result with remainder[15:8] and quotient[7:0])\n     * res_valid (1-bit output valid signal)\n\n2. Behavior:\n   - When opn_valid is high and res_valid is low, latch inputs and begin computation\n   - Perform signed division when sign=1 (using two's complement)\n   - Compute both quotient and remainder in 8 clock cycles after input latching\n   - Assert res_valid when result is ready\n   - Deassert res_valid when res_ready is high (handshake protocol)\n   - Result should maintain correct sign relationships for signed operations\n\n3. Timing:\n   - All operations occur on rising clock edges\n   - Inputs are sampled only when opn_valid is high and res_valid is low\n   - Output remains valid until acknowledged by res_ready\n\n4. Edge Cases:\n   - Handle reset properly (clear all internal state)\n   - Maintain outputs until handshake completes\n   - Correctly process negative numbers in signed mode\n\nThe module should implement a non-restoring division algorithm. Do not use division operators."}
{"is_valid": true, "question": "Design a Verilog module that implements an 8-bit shift register with serial input and parallel output. The module should have the following specifications:\n\nInputs:\n- clk: A clock signal (positive edge triggered)\n- d: A 1-bit serial data input\n\nOutputs:\n- q: An 8-bit parallel output representing the current state of the shift register\n\nBehavior:\n1. On every positive edge of the clock:\n   - Each bit in q should shift right by one position (q[6] moves to q[5], q[5] to q[4], etc.)\n   - The input bit d should be loaded into the most significant bit (q[7])\n   - The least significant bit (q[0]) should be discarded\n2. The initial state of q should be all zeros (8'b00000000)\n\nAdditional Requirements:\n- The module should be synchronous to the clock\n- All state changes must occur only on the positive clock edge\n- The output q should be registered (not combinational)\n\nAssume all inputs are glitch-free and meet setup/hold times relative to the clock."}
{"is_valid": false, "question": "Design a Verilog module that implements an 8-bit rotating shift register with synchronous reset. The module should have the following specifications:\n\nInputs:\n- clk: Clock signal (positive edge triggered)\n- reset: Synchronous reset signal (active high)\n\nOutput:\n- out: 8-bit register output\n\nBehavior:\n1. On reset (reset=1), the register should initialize to 8'b00000001 (LSB set to 1, all others 0)\n2. On each positive clock edge when reset=0, the register should perform a left rotation (MSB moves to LSB position)\n3. The output should always reflect the current state of the register\n\nTiming Requirements:\n- All state changes must occur synchronously on the positive clock edge\n- Reset should take precedence over the rotation operation\n\nExample Behavior:\nInitial state after reset: 00000001\nAfter 1 clock: 00000010\nAfter 2 clocks: 00000100\n...\nAfter 7 clocks: 10000000\nAfter 8 clocks: 00000001 (wraps around)\n\nDo not use any asynchronous logic or behavioral constructs beyond what's necessary to implement the specified functionality."}
{"is_valid": false, "question": "Design a finite state machine (FSM) that detects the sequence \"1001\" on a serial input stream. The module should have the following specifications:\n\nInputs:\n- clk: System clock (positive edge triggered)\n- rst_n: Active-low synchronous reset\n- data_in: Serial input bit (1-bit wide)\n\nOutput:\n- sequence_detected: Asserted high for one clock cycle when the complete sequence \"1001\" is detected\n\nBehavior:\n1. The FSM should start in IDLE state after reset\n2. The sequence detector must recognize non-overlapping sequences (each new detection starts from the beginning of the pattern)\n3. The output should be asserted in the same cycle when the complete sequence is detected\n4. The FSM should properly handle back-to-back sequences (e.g., \"10011001\" should trigger two detections)\n\nTiming Requirements:\n- All state transitions must occur on the rising edge of the clock\n- The output should be synchronous with the clock\n- The FSM should immediately reset to IDLE when rst_n is asserted low\n\nAssume the input stream can change only on clock edges. Do not implement any error checking beyond the specified behavior."}
{"is_valid": false, "question": "Design a serial-to-parallel converter module with the following specifications:\n\nInputs:\n- clk: system clock (posedge triggered)\n- rst_n: active-low synchronous reset\n- din_serial: 1-bit serial data input\n- din_valid: indicates when din_serial contains valid data (active high)\n\nOutputs:\n- dout_parallel: 8-bit parallel output\n- dout_valid: indicates when dout_parallel contains valid data (active high, single cycle)\n\nBehavior:\n1. The module should collect 8 consecutive valid serial bits (LSB first) when din_valid is high\n2. After receiving 8 valid bits, the module should output the collected byte on dout_parallel and assert dout_valid for exactly one clock cycle\n3. The counter should reset to 0 if din_valid goes low before collecting 8 bits\n4. All operations should be synchronous to the rising edge of clk\n5. The module should properly handle reset conditions (all outputs and internal state should reset when rst_n is low)\n\nAssume:\n- din_valid will remain high continuously while transmitting a byte (no gaps between bits)\n- The module doesn't need to handle backpressure or flow control"}
{"is_valid": true, "question": "Design a synchronous digital module that generates a triangular wave pattern on a 5-bit output. The module should have the following behavior:\n\n1. On active-low reset (rst_n=0), initialize the output to 0.\n2. On each positive clock edge when reset is inactive:\n   - In the \"count up\" state: increment the output by 1 until reaching maximum value (5'b11111)\n   - When maximum is reached, transition to \"count down\" state\n   - In the \"count down\" state: decrement the output by 1 until reaching minimum value (5'b00000)\n   - When minimum is reached, transition back to \"count up\" state\n\nThe module should have:\n- Clock input (clk)\n- Active-low asynchronous reset (rst_n)\n- 5-bit output (wave) that follows the described pattern\n\nAssume the state transitions happen immediately when boundary values are reached (same clock cycle). The output should wrap around between 0 and 31 (inclusive) in a continuous triangular pattern."}
{"is_valid": false, "question": "Design a digital waveform generator module that produces a square wave with programmable frequency. The module should have the following interface:\n\nInputs:\n- clk: System clock (positive edge triggered)\n- freq[7:0]: 8-bit frequency control word (unsigned integer)\n\nOutput:\n- wave_out: Generated square wave output\n\nBehavior:\n1. The output wave_out should toggle (0\u21921 or 1\u21920) every N clock cycles, where N is the value of freq.\n2. When freq is 0, the output should remain constant (either 0 or 1).\n3. The frequency control is synchronous - changes to freq take effect immediately on the next clock edge.\n4. All operations must be synchronous to the positive edge of clk.\n\nExample:\n- If freq = 2, wave_out should toggle every 2 clock cycles (50% duty cycle)\n- If freq = 4, wave_out should toggle every 4 clock cycles (50% duty cycle)\n- If freq = 0, wave_out should never toggle\n\nAssume all inputs are glitch-free and meet setup/hold times. The module should initialize wave_out to 0 on power-up."}
{"is_valid": true, "question": "Design a 64-bit subtractor module that detects overflow conditions. The module should take two 64-bit inputs (A and B) and produce two outputs: the 64-bit subtraction result and a 1-bit overflow flag.\n\nThe module must:\n1. Compute the result of A - B using two's complement arithmetic\n2. Set the overflow flag to 1 when:\n   - The inputs have opposite sign bits (A[63] \u2260 B[63])\n   - The result's sign bit doesn't match A's sign bit (result[63] \u2260 A[63])\n3. Otherwise, the overflow flag should be 0\n\nThe module should be purely combinational (no clock input) and compute outputs whenever inputs change. All operations should follow standard two's complement arithmetic rules for signed 64-bit numbers.\n\nInputs:\n- A: 64-bit signed input (two's complement)\n- B: 64-bit signed input (two's complement)\n\nOutputs:\n- result: 64-bit subtraction result (A - B)\n- overflow: 1-bit flag indicating arithmetic overflow (1 when overflow occurs, 0 otherwise)\n\nNote: The overflow condition should only occur when the mathematical result of A - B cannot be correctly represented in 64-bit two's complement form."}
{"is_valid": false, "question": "Design a Verilog module that synchronizes data between two clock domains (clk_a and clk_b) with independent asynchronous resets. The module should:\n\n1. Inputs:\n   - clk_a: First clock domain\n   - clk_b: Second clock domain\n   - arstn: Asynchronous active-low reset for clk_a domain\n   - brstn: Asynchronous active-low reset for clk_b domain\n   - data_in[3:0]: 4-bit input data sampled on clk_a\n   - data_en: Enable signal for data transfer (clk_a domain)\n\n2. Outputs:\n   - dataout[3:0]: 4-bit output data in clk_b domain\n\n3. Behavior:\n   - When arstn is low, all clk_a domain registers should reset to 0\n   - When brstn is low, all clk_b domain registers should reset to 0\n   - On clk_a rising edges, sample data_in into a register when not reset\n   - On clk_a rising edges, sample data_en into a register when not reset\n   - The data_en signal should be synchronized to clk_b using a 2-stage synchronizer\n   - The output dataout should only update in clk_b domain when the synchronized enable is active\n   - When not enabled, dataout should hold its previous value\n\n4. Timing:\n   - All resets should be asynchronous and active-low\n   - All sampling should occur on rising clock edges\n   - The enable signal must be properly synchronized between clock domains\n\nThe module should correctly handle metastability and ensure reliable data transfer between the asynchronous clock domains."}
{"is_valid": false, "question": "Design a traffic light controller module with the following specifications:\n\nInputs:\n- rst_n: Active-low asynchronous reset\n- clk: System clock\n- pass_request: Signal to request extending green light duration\n\nOutputs:\n- clock[7:0]: Current countdown value (visible timer)\n- red: Red light status\n- yellow: Yellow light status\n- green: Green light status\n\nBehavior:\n1. The controller should cycle through 3 states: red (10s), green (60s), and yellow (5s)\n2. The countdown timer (clock) should decrement every clock cycle\n3. When pass_request is asserted during green light with remaining time >10s, reset timer to 10s\n4. State transitions should occur when timer reaches 3 (allowing 3s overlap between states)\n5. Outputs should be registered and change synchronously with clock\n6. All outputs should reset to 0 when rst_n is low\n\nAssume:\n- Clock frequency is 1Hz (1 second per cycle)\n- Input signals are synchronous to clk\n- State transitions have priority over pass_request\n\nThe module should implement this behavior exactly as described."}
{"is_valid": true, "question": "Design a 16-bit synchronous counter module with the following specifications:\n\nInputs:\n- clk: Clock signal (positive edge triggered)\n- reset: Asynchronous active-high reset (resets counter to 0)\n- up_down: Direction control (1 = count up, 0 = count down)\n\nOutput:\n- count: 16-bit counter value\n\nBehavior:\n1. On reset (reset=1), the counter should immediately reset to 0\n2. On each positive clock edge when reset=0:\n   - If up_down=1, increment count by 1 (wrapping around to 0 when reaching maximum value)\n   - If up_down=0, decrement count by 1 (wrapping around to maximum value when reaching 0)\n3. The counter should handle wrap-around in both directions:\n   - When counting up: 0xFFFF \u2192 0x0000\n   - When counting down: 0x0000 \u2192 0xFFFF\n\nThe module should be purely synchronous except for the asynchronous reset. All state changes must occur only on clock edges (except reset).\n\nAssume all inputs are glitch-free and meet setup/hold times relative to the clock."}
{"is_valid": false, "question": "Design a Verilog module that processes 8-bit input data in pairs and outputs their concatenated 16-bit values. The module should meet the following specifications:\n\nInputs:\n- clk: System clock\n- rst_n: Active-low synchronous reset\n- valid_in: Input valid signal (1 cycle pulse)\n- data_in[7:0]: 8-bit input data\n\nOutputs:\n- valid_out: Output valid signal (1 cycle pulse)\n- data_out[15:0]: 16-bit output data\n\nBehavior:\n1. On each valid_in pulse, the module should alternately store and process input bytes:\n   - First valid_in: Store data_in in an internal register (no output)\n   - Second valid_in: Concatenate the stored byte with current data_in and output\n   - Repeat this pattern for subsequent inputs\n2. valid_out should pulse high for exactly one cycle when outputting a complete 16-bit pair\n3. All operations should be synchronous to the rising clock edge\n4. Reset (rst_n=0) should clear all internal state and outputs\n\nTiming:\n- Output should occur on the same cycle as the second valid_in of each pair\n- The module should maintain its state between reset cycles\n\nAssume all inputs change synchronously with the clock edge."}
