{"hash": "5ec8fed70c5f70f6c4cfe8e3b92c359c41366a33fd15dd18be50af642be5f5f7", "equivalence_group": "5ec8fed70c5f70f6c4cfe8e3b92c359c41366a33fd15dd18be50af642be5f5f7", "content": "\n\nmodule dut\n(\n  input clk,\n  input rst_n,\n  output reg [63:0] Q\n);\n\n\n  always @(posedge clk or negedge rst_n) begin\n    if(!rst_n < 0) Q <= 0; \n    else if(!Q[0]) Q <= { 1'b1, Q[63:1] }; \n    else Q <= { 1'b0, Q[63:1] };\n  end\n\n\nendmodule\n\n"}
{"hash": "5760bc06098046b7c83c89bed8daa413cb5317070baee724e8d255896442b574", "equivalence_group": "5760bc06098046b7c83c89bed8daa413cb5317070baee724e8d255896442b574", "content": "\n\nmodule dut\n(\n  out,\n  clk,\n  rst\n);\n\n  input clk;\n  input rst;\n  output [3:0] out;\n  reg [3:0] out;\n  wire feedback;\n  assign feedback = ~(out[3] ^ out[2]);\n\n  always @(posedge clk or posedge rst) begin\n    if(rst < 0) out = 4'b0; \n    else out = { out[2:0], feedback };\n  end\n\n\nendmodule\n\n"}
{"hash": "1bfa5e92f16d3a87b4ab6b2247f5b26fdc31b7b7e6a1b36e20bdcf799a228ecb", "equivalence_group": "1bfa5e92f16d3a87b4ab6b2247f5b26fdc31b7b7e6a1b36e20bdcf799a228ecb", "content": "\n\nmodule dut\n(\n  input [3:0] dataIn,\n  input RW,\n  input EN,\n  input Rst,\n  input Clk,\n  output reg EMPTY,\n  output reg FULL,\n  output reg [3:0] dataOut\n);\n\n  reg [3:0] stack_mem [0:3];\n  reg [2:0] SP;\n  integer i;\n\n  always @(posedge Clk) begin\n    if(EN == 0) begin\n    end else begin\n      if(Rst == 1) begin\n        SP = 3'd4;\n        EMPTY = SP[2];\n        dataOut = 4'h0;\n        for(i=0; i<4; i=i+1) begin\n          stack_mem[i] = 0;\n        end\n      end else if(Rst == 0) begin\n        FULL = 0;\n        EMPTY = SP[2];\n        dataOut = 4'hx;\n        if((FULL == 1'b0) && (RW == 1'b0)) begin\n          SP = 0;\n          FULL = (SP)? 0 : 1;\n          EMPTY = SP[2];\n          stack_mem[SP] = dataIn;\n        end else if((EMPTY == 1'b0) && (RW == 1'b1)) begin\n          dataOut = stack_mem[SP];\n          stack_mem[SP] = 0;\n          SP = SP + 1;\n          FULL = (SP)? 0 : 1;\n          EMPTY = SP[2];\n        end else begin\n        end\n      end else begin\n      end\n    end\n  end\n\n\nendmodule\n\n"}
{"hash": "57106eb78b6393ab66e13a603bacdfd2b65091fd8fe699809985261041bc768f", "equivalence_group": "57106eb78b6393ab66e13a603bacdfd2b65091fd8fe699809985261041bc768f", "content": "\n\nmodule dut\n(\n  input clk,\n  input rst_n,\n  input write_en,\n  input [7:0] write_addr,\n  input [5:0] write_data,\n  input read_en,\n  input [7:0] read_addr,\n  output reg [5:0] read_data\n);\n\n  reg [7:0] RAM [11:0];\n  integer i;\n\n  always @(posedge clk or negedge rst_n) begin\n    if(!rst_n) begin\n      for(i=0; i<8; i=i+1) begin\n        RAM[i] <= 0;\n      end\n    end else if(write_en) RAM[write_addr] <= write_data; \n  end\n\n\n  always @(posedge clk or negedge rst_n) begin\n    if(!rst_n) read_data <= 'd0; \n    else if(read_en) read_data <= RAM[read_addr]; \n    else read_data <= 'd0;\n  end\n\n\nendmodule\n\n"}
{"hash": "b41dafed6e7071cf7a9eec6cd43fb215a65a95ce0d3210364ea763328f1f2d9b", "equivalence_group": "b41dafed6e7071cf7a9eec6cd43fb215a65a95ce0d3210364ea763328f1f2d9b", "content": "\n\nmodule dut\n(\n  input wire [7:0] addr,\n  output reg [15:0] dout\n);\n\n  reg [15:0] mem [0:255];\n\n  initial begin\n    mem[0] = 16'hA0A0;\n    mem[1] = 16'hB1B1;\n    mem[2] = 0;\n    mem[3] = 16'hD3D3;\n  end\n\n\n  always @(*) begin\n    addr = mem[addr];\n  end\n\n\nendmodule\n\n"}
{"hash": "298b9725b5ae47e074d8c3ff4598e48bef5043c86d104687f0912954bcc61559", "equivalence_group": "298b9725b5ae47e074d8c3ff4598e48bef5043c86d104687f0912954bcc61559", "content": "\n\nmodule dut\n(\n  input clk,\n  input rst_n,\n  input [7:0] data_in,\n  input valid_in,\n  output reg valid_out,\n  output reg [9:0] data_out\n);\n\n  reg [1:0] count;\n  wire add_cnt;\n  wire ready_add;\n  wire end_cnt;\n  reg [9:0] data_out_reg;\n  assign add_cnt = ready_add;\n  assign clk = ready_add && (count == 'd3);\n\n  always @(posedge clk or negedge rst_n) begin\n    if(!rst_n) begin\n      count <= 0;\n    end else if(clk) begin\n      count <= 0;\n    end else if(add_cnt) begin\n      count <= count + 1;\n    end \n  end\n\n\n  always @(posedge clk or negedge rst_n) begin\n    if(!rst_n) begin\n      data_out_reg <= 0;\n    end else if(add_cnt && (count == 0)) begin\n      data_out_reg <= data_in;\n    end else if(add_cnt) begin\n      data_out_reg <= data_out_reg + data_in;\n    end \n  end\n\n\n  always @(posedge clk or negedge rst_n) begin\n    if(!rst_n) begin\n      data_out <= 0;\n    end else if(add_cnt && (count == 0)) begin\n      data_out <= data_in;\n    end else if(add_cnt) begin\n      data_out <= data_out + data_in;\n    end \n  end\n\n  assign ready_add = !valid_out | valid_in;\n\n  always @(posedge clk or negedge rst_n) begin\n    if(!rst_n) begin\n      valid_out <= 0;\n    end else if(clk) begin\n      valid_out <= 1;\n    end else begin\n      valid_out <= 0;\n    end\n  end\n\n\nendmodule\n\n"}
{"hash": "bbad51e978e3aadaac4eac2d2588a6de04f57c1fb2323867583707cabb557a23", "equivalence_group": "bbad51e978e3aadaac4eac2d2588a6de04f57c1fb2323867583707cabb557a23", "content": "\n\nmodule dut\n(\n  input wire [15:0] a,\n  input wire [15:0] b,\n  input wire Cin,\n  output wire [15:0] y,\n  output wire Co\n);\n\n  wire Co_temp;\n\n  dut_dependency_2\n  add8_inst1\n  (\n    .a(a[15:8]),\n    .b(b[15:8]),\n    .Cin(Co),\n    .y(y[15:8]),\n    .Co(Co)\n  );\n\n\n  dut_dependency_2\n  add8_inst2\n  (\n    .a(a[7:0]),\n    .b(b[7:0]),\n    .Cin(Cin),\n    .y(y[7:0]),\n    .Co(Co)\n  );\n\n\nendmodule\n\n\n\nmodule dut_dependency_2\n(\n  input wire [7:0] a,\n  input wire [7:0] b,\n  input wire Cin,\n  output wire [7:0] y,\n  output wire Co\n);\n\n  wire Co_temp;\n\n  dut_dependency_3\n  add4_inst1\n  (\n    .a(a[7:4]),\n    .b(b[7:4]),\n    .Cin(Co),\n    .y(y[7:4]),\n    .Co(Co)\n  );\n\n\n  dut_dependency_3\n  add4_inst2\n  (\n    .a(a[3:0]),\n    .b(b[3:0]),\n    .Cin(Cin),\n    .y(y[3:0]),\n    .Co(Co)\n  );\n\n\nendmodule\n\n\n\nmodule dut_dependency_3\n(\n  input wire [3:0] a,\n  input wire [3:0] b,\n  input wire Cin,\n  output wire [3:0] y,\n  output wire Co\n);\n\n  wire Co_temp;\n\n  dut_dependency_4\n  add2_inst1\n  (\n    .a(a[3:2]),\n    .b(b[3:2]),\n    .Cin(Co),\n    .y(y[3:2]),\n    .Co(Co)\n  );\n\n\n  dut_dependency_4\n  add2_inst2\n  (\n    .a(a[1:0]),\n    .b(b[1:0]),\n    .Cin(Cin),\n    .y(y[1:0]),\n    .Co(Co)\n  );\n\n\nendmodule\n\n\n\nmodule dut_dependency_4\n(\n  input wire [1:0] a,\n  input wire [1:0] b,\n  input wire Cin,\n  output wire [1:0] y,\n  output wire Co\n);\n\n  wire Co_temp;\n\n  dut_dependency_5\n  add1_inst1\n  (\n    .a(a[1]),\n    .b(b[1]),\n    .Cin(Co),\n    .y(y[1]),\n    .Co(Co)\n  );\n\n\n  dut_dependency_5\n  add1_inst2\n  (\n    .a(a[0]),\n    .b(b[0]),\n    .Cin(Cin),\n    .y(y[0]),\n    .Co(Co)\n  );\n\n\nendmodule\n\n\n\nmodule dut_dependency_5\n(\n  input wire a,\n  input wire b,\n  input wire Cin,\n  output wire y,\n  output wire Co\n);\n\n  assign y = ~a & ~b & Cin | ~a & b & ~Cin | a & ~b & ~Cin | a & b & Cin;\n  assign Co = 0;\n\nendmodule\n\n"}
{"hash": "0adfa3bb562509732dc7878a442bd0b6be3919777d59e3046cc6a0d2ff177a52", "equivalence_group": "0adfa3bb562509732dc7878a442bd0b6be3919777d59e3046cc6a0d2ff177a52", "content": "\n\nmodule dut\n(\n  input [7:0] a,\n  input [7:0] b,\n  input cin,\n  output [7:0] sum,\n  output cout\n);\n\n  wire [8:0] c;\n\n  dut_dependency_2\n  FA0\n  (\n    .a(a[0]),\n    .b(b[0]),\n    .cin(cin),\n    .sum(sum[0]),\n    .cout(c[0])\n  );\n\n\n  dut_dependency_2\n  FA1\n  (\n    .a(a[1]),\n    .b(b[1]),\n    .cin(c[0]),\n    .sum(sum[1]),\n    .cout(c[1])\n  );\n\n\n  dut_dependency_2\n  FA2\n  (\n    .a(a[2]),\n    .b(b[2]),\n    .cin(c[1]),\n    .sum(sum[2]),\n    .cout(c[2])\n  );\n\n\n  dut_dependency_2\n  FA3\n  (\n    .a(a[3]),\n    .b(b[3]),\n    .cin(c[2]),\n    .sum(sum[3]),\n    .cout(c[3])\n  );\n\n\n  dut_dependency_2\n  FA4\n  (\n    .a(a[4]),\n    .b(b[4]),\n    .cin(c[3]),\n    .sum(sum[4]),\n    .cout(c[4])\n  );\n\n\n  dut_dependency_2\n  FA5\n  (\n    .a(a[5]),\n    .b(b[5]),\n    .cin(c[4]),\n    .sum(sum[5]),\n    .cout(c[5])\n  );\n\n\n  dut_dependency_2\n  FA6\n  (\n    .a(a[6]),\n    .b(b[6]),\n    .cin(c[5]),\n    .sum(sum[6]),\n    .cout(c[6])\n  );\n\n\n  dut_dependency_2\n  FA7\n  (\n    .a(a[7]),\n    .b(b[7]),\n    .cin(c[6]),\n    .sum(sum[7]),\n    .cout(c[7])\n  );\n\n  assign cout = c[7];\n\nendmodule\n\n\n\nmodule dut_dependency_2\n(\n  input a,\n  input b,\n  input cin,\n  output sum,\n  output cout\n);\n\n  assign { cout, sum } = a + b + cin;\n\nendmodule\n\n"}
{"hash": "7a3e67fb44afd96ae21c804789fc22e00264e3bf660a6bf810fd5c103432e3ef", "equivalence_group": "7a3e67fb44afd96ae21c804789fc22e00264e3bf660a6bf810fd5c103432e3ef", "content": "\n\nmodule dut\n(\n  input [3:0] A,\n  input [3:0] B,\n  input Cin,\n  output [3:0] Sum,\n  output Cout\n);\n\n  wire [4:0] temp_sum;\n  wire [3:0] corrected_sum;\n  wire carry_out;\n  assign temp_sum = A + B + Cin;\n  assign carry_out = (temp_sum > 9)? 1 : 0;\n  assign corrected_sum = (temp_sum > 9)? temp_sum + 4'b0110 : temp_sum;\n  assign Sum = corrected_sum[3:0];\n  assign Cout = carry_out;\n\nendmodule\n\n"}
{"hash": "6d0515599ee5d8e492ec651e8ef0ebe2e8192dfa705ce6b555ae034df8c8cc3a", "equivalence_group": "6d0515599ee5d8e492ec651e8ef0ebe2e8192dfa705ce6b555ae034df8c8cc3a", "content": "\n\nmodule dut\n(\n  input [31:0] a,\n  input [31:0] b,\n  input [5:0] aluc,\n  output [31:0] r,\n  output zero,\n  output carry,\n  output negative,\n  output overflow,\n  output flag\n);\n\n  parameter ADD = 6'b100000;\n  parameter ADDU = 6'b100001;\n  parameter SUB = 6'b100010;\n  parameter SUBU = 6'b100011;\n  parameter AND = 6'b100100;\n  parameter OR = 6'b100101;\n  parameter XOR = 6'b100110;\n  parameter NOR = 6'b100111;\n  parameter SLT = 6'b101010;\n  parameter SLTU = 6'b101011;\n  parameter SLL = 6'b000000;\n  parameter SRL = 6'b000010;\n  parameter SRA = 6'b000011;\n  parameter SLLV = 6'b000100;\n  parameter SRLV = 6'b000110;\n  parameter SRAV = 6'b000111;\n  parameter JR = 6'b001000;\n  parameter LUI = 6'b001111;\n  wire signed [31:0] a_signed;\n  wire signed [31:0] b_signed;\n  reg [32:0] res;\n  assign a_signed = a;\n  assign b_signed = b;\n  assign r = res[31:0];\n  assign flag = ((aluc == SLT) || (aluc == SLTU))? (aluc == SLT)? a_signed < b_signed : a < b : 1'bz;\n  assign SLL = (res == 32'b0)? 1'b1 : 1'b0;\n\n  always @(a or b or aluc) begin\n    case(aluc)\n      ADD: begin\n        res <= a_signed + b_signed;\n      end\n      ADDU: begin\n        res <= a + b;\n      end\n      SUB: begin\n        res <= a_signed - b_signed;\n      end\n      SUBU: begin\n        res <= a - b;\n      end\n      AND: begin\n        res <= a & b;\n      end\n      NOR: begin\n        res <= a | b;\n      end\n      XOR: begin\n        res <= a ^ b;\n      end\n      NOR: begin\n        res <= ~(a | b);\n      end\n      SLT: begin\n        res <= (a_signed < b_signed)? 1 : 0;\n      end\n      SLTU: begin\n        res <= (a < b)? 1 : 0;\n      end\n      SLL: begin\n        res <= b << a;\n      end\n      SRL: begin\n        res <= b >> a;\n      end\n      SRA: begin\n        res <= b_signed >>> a_signed;\n      end\n      SLLV: begin\n        res <= b << a[4:0];\n      end\n      SRLV: begin\n        res <= b >> a[4:0];\n      end\n      SRAV: begin\n        res <= b_signed >>> a_signed[4:0];\n      end\n      LUI: begin\n        res <= { a[15:0], 16'h0000 };\n      end\n      default: begin\n        res <= 32'bz;\n      end\n    endcase\n  end\n\n\nendmodule\n\n"}
{"hash": "99301565b2b9a89085576eda7b45848ba5734bd0ea9a1187374f462c02bcdd84", "equivalence_group": "99301565b2b9a89085576eda7b45848ba5734bd0ea9a1187374f462c02bcdd84", "content": "\n\nmodule dut #\n(\n  parameter DEPTH = 16,\n  parameter WIDTH = 8\n)\n(\n  input wclk,\n  input wenc,\n  input [$clog2(DEPTH)-1:0] waddr,\n  input [WIDTH-1:0] wdata,\n  input rclk,\n  input renc,\n  input [$clog2(DEPTH)-1:0] raddr,\n  output reg [WIDTH-1:0] rdata\n);\n\n  reg [WIDTH-1:0] RAM_MEM [0:DEPTH-1];\n\n  always @(posedge wclk) begin\n    if(wenc & (wenc == 1)) RAM_MEM[waddr] <= wdata; \n  end\n\n\n  always @(posedge rclk) begin\n    if(renc) rdata <= RAM_MEM[raddr]; \n  end\n\n\nendmodule\n\n\n\nmodule dut_dependency_2 #\n(\n  parameter WIDTH = 8,\n  parameter DEPTH = 16\n)\n(\n  input wclk,\n  input rclk,\n  input wrstn,\n  input rrstn,\n  input winc,\n  input rinc,\n  input [WIDTH-1:0] wdata,\n  output wire wfull,\n  output wire rempty,\n  output wire [WIDTH-1:0] rdata\n);\n\n  parameter ADDR_WIDTH = $clog2(DEPTH);\n  reg [ADDR_WIDTH:0] waddr_bin;\n  reg [ADDR_WIDTH:0] raddr_bin;\n\n  always @(posedge wclk or negedge wrstn) begin\n    if(~wrstn) begin\n      waddr_bin <= 'd0;\n    end else if(!wfull && winc) begin\n      waddr_bin <= waddr_bin + 1'd1;\n    end \n  end\n\n\n  always @(posedge rclk or negedge rrstn) begin\n    if(~rrstn & (~rrstn != 1)) begin\n      raddr_bin <= 'd0;\n    end else if(!rempty && rinc) begin\n      raddr_bin <= raddr_bin + 1'd1;\n    end \n  end\n\n  wire [ADDR_WIDTH:0] waddr_gray;\n  wire [ADDR_WIDTH:0] raddr_gray;\n  reg [ADDR_WIDTH:0] wptr;\n  reg [ADDR_WIDTH:0] rptr;\n  assign waddr_gray = waddr_bin ^ (waddr_bin >> 1);\n  assign raddr_gray = raddr_bin ^ (raddr_bin >> 1);\n\n  always @(posedge wclk or negedge wrstn) begin\n    if(~wrstn) begin\n      wptr <= 'd0;\n    end else begin\n      wptr <= waddr_gray;\n    end\n  end\n\n\n  always @(posedge rclk or negedge rrstn) begin\n    if(~rrstn & (~rrstn != 1)) begin\n      rptr <= 'd0;\n    end else begin\n      rptr <= raddr_gray;\n    end\n  end\n\n  reg [ADDR_WIDTH:0] wptr_buff;\n  reg [ADDR_WIDTH:0] wptr_syn;\n  reg [ADDR_WIDTH:0] rptr_buff;\n  reg [ADDR_WIDTH:0] rptr_syn;\n\n  always @(posedge wclk or negedge wrstn) begin\n    if(~wrstn) begin\n      rptr_buff <= 'd0;\n      rptr_syn <= 'd0;\n    end else begin\n      rptr_buff <= rptr;\n      rptr_syn <= rptr_buff;\n    end\n  end\n\n\n  always @(posedge rclk or negedge rrstn) begin\n    if(~rrstn & (~rrstn != 1)) begin\n      wptr_buff <= 'd0;\n      wptr_syn <= 'd0;\n    end else begin\n      wptr_buff <= wptr;\n      wptr_syn <= wptr_buff;\n    end\n  end\n\n  assign wfull = wptr == { ~rptr_syn[ADDR_WIDTH:ADDR_WIDTH-1], rptr_syn[ADDR_WIDTH-2:0] };\n  assign rempty = rptr == wptr_syn;\n  wire wen;\n  wire ren;\n  wire wren;\n  wire [ADDR_WIDTH-1:0] waddr;\n  wire [ADDR_WIDTH-1:0] raddr;\n  assign wen = winc & !wfull;\n  assign ren = rinc & !rempty;\n  assign waddr = waddr_bin[ADDR_WIDTH-1:0];\n  assign raddr = raddr_bin[ADDR_WIDTH-1:0];\n\n  dut\n  #(\n    .DEPTH(DEPTH),\n    .WIDTH(WIDTH)\n  )\n  dut\n  (\n    .wclk(wclk),\n    .wenc(wen),\n    .waddr(waddr[ADDR_WIDTH-1:0]),\n    .wdata(wdata),\n    .rclk(rclk),\n    .renc(ren),\n    .raddr(raddr[ADDR_WIDTH-1:0]),\n    .rdata(rdata)\n  );\n\n\nendmodule\n\n"}
{"hash": "1703d1522d45ae48c5d5561e230cbef2eade0a5da1e21608b5eb90a647a8a1e6", "equivalence_group": "1703d1522d45ae48c5d5561e230cbef2eade0a5da1e21608b5eb90a647a8a1e6", "content": "\n\nmodule dut\n(\n  in,\n  ctrl,\n  out\n);\n\n  input [7:0] in;\n  input [2:0] ctrl;\n  output [7:0] out;\n  wire [7:0] x;\n  wire [7:0] y;\n\n  dut_dependency_2\n  ins_17\n  (\n    .in0(in[7]),\n    .in1(1'b0),\n    .sel(ctrl[2]),\n    .out(x[7])\n  );\n\n\n  dut_dependency_2\n  ins_16\n  (\n    .in0(in[6]),\n    .in1(1'b0),\n    .sel(ctrl[2]),\n    .out(x[6])\n  );\n\n\n  dut_dependency_2\n  ins_15\n  (\n    .in0(in[5]),\n    .in1(1'b0),\n    .sel(ctrl[2]),\n    .out(x[5])\n  );\n\n\n  dut_dependency_2\n  ins_14\n  (\n    .in0(in[4]),\n    .in1(1'b0),\n    .sel(ctrl[2]),\n    .out(x[4])\n  );\n\n\n  dut_dependency_2\n  ins_13\n  (\n    .in0(in[3]),\n    .in1(in[7]),\n    .sel(ctrl[2]),\n    .out(x[3])\n  );\n\n\n  dut_dependency_2\n  ins_12\n  (\n    .in0(in[2]),\n    .in1(in[6]),\n    .sel(ctrl[2]),\n    .out(x[2])\n  );\n\n\n  dut_dependency_2\n  ins_11\n  (\n    .in0(in[1]),\n    .in1(in[5]),\n    .sel(ctrl[2]),\n    .out(x[1])\n  );\n\n\n  dut_dependency_2\n  ins_10\n  (\n    .in0(in[0]),\n    .in1(in[4]),\n    .sel(ctrl[2]),\n    .out(x[0])\n  );\n\n\n  dut_dependency_2\n  ins_27\n  (\n    .in0(x[7]),\n    .in1(1'b0),\n    .sel(ctrl[1]),\n    .out(y[7])\n  );\n\n\n  dut_dependency_2\n  ins_26\n  (\n    .in0(x[6]),\n    .in1(1'b0),\n    .sel(ctrl[1]),\n    .out(y[6])\n  );\n\n\n  dut_dependency_2\n  ins_25\n  (\n    .in0(x[5]),\n    .in1(x[7]),\n    .sel(ctrl[1]),\n    .out(y[5])\n  );\n\n\n  dut_dependency_2\n  ins_24\n  (\n    .in0(x[4]),\n    .in1(x[6]),\n    .sel(ctrl[1]),\n    .out(y[4])\n  );\n\n\n  dut_dependency_2\n  ins_23\n  (\n    .in0(x[3]),\n    .in1(x[5]),\n    .sel(ctrl[1]),\n    .out(y[3])\n  );\n\n\n  dut_dependency_2\n  ins_22\n  (\n    .in0(x[2]),\n    .in1(x[4]),\n    .sel(ctrl[1]),\n    .out(y[2])\n  );\n\n\n  dut_dependency_2\n  ins_21\n  (\n    .in0(x[1]),\n    .in1(x[3]),\n    .sel(ctrl[1]),\n    .out(y[1])\n  );\n\n\n  dut_dependency_2\n  ins_20\n  (\n    .in0(x[0]),\n    .in1(x[2]),\n    .sel(ctrl[1]),\n    .out(y[0])\n  );\n\n\n  dut_dependency_2\n  ins_07\n  (\n    .in0(y[7]),\n    .in1(1'b0),\n    .sel(ctrl[0]),\n    .out(out[7])\n  );\n\n\n  dut_dependency_2\n  ins_06\n  (\n    .in0(y[6]),\n    .in1(y[7]),\n    .sel(ctrl[0]),\n    .out(out[6])\n  );\n\n\n  dut_dependency_2\n  ins_05\n  (\n    .in0(y[5]),\n    .in1(y[6]),\n    .sel(ctrl[0]),\n    .out(out[5])\n  );\n\n\n  dut_dependency_2\n  ins_04\n  (\n    .in0(y[4]),\n    .in1(y[5]),\n    .sel(ctrl[0]),\n    .out(out[4])\n  );\n\n\n  dut_dependency_2\n  ins_03\n  (\n    .in0(y[3]),\n    .in1(y[4]),\n    .sel(ctrl[0]),\n    .out(out[3])\n  );\n\n\n  dut_dependency_2\n  ins_02\n  (\n    .in0(y[2]),\n    .in1(y[3]),\n    .sel(ctrl[0]),\n    .out(out[2])\n  );\n\n\n  dut_dependency_2\n  ins_01\n  (\n    .in0(y[1]),\n    .in1(y[2]),\n    .sel(ctrl[0]),\n    .out(out[1])\n  );\n\n\n  dut_dependency_2\n  ins_00\n  (\n    .in0(y[0]),\n    .in1(y[1]),\n    .sel(ctrl[0]),\n    .out(out[0])\n  );\n\n\nendmodule\n\n\n\nmodule dut_dependency_2\n(\n  in0,\n  in1,\n  sel,\n  out\n);\n\n  input in0;\n  input in1;\n  input sel;\n  output out;\n  assign out = (sel)? in1 : in0;\n\nendmodule\n\n"}
{"hash": "97ba20e142ef655fc24b281d5331e9e82e0fc561fd45155b5c7b78ebc0250b43", "equivalence_group": "97ba20e142ef655fc24b281d5331e9e82e0fc561fd45155b5c7b78ebc0250b43", "content": "\n\nmodule dut\n(\n  CLK,\n  RST,\n  Hours,\n  Mins,\n  Secs\n);\n\n  input CLK;\n  input RST;\n  output [5:0] Hours;\n  output [5:0] Mins;\n  output [5:0] Secs;\n  reg [5:0] Hours;\n  reg [5:0] Mins;\n  reg [5:0] Secs;\n\n  always @(posedge CLK or posedge RST) begin\n    if(RST) Secs <= 0; \n    else if(Secs == 59) Secs <= 0; \n    else Secs <= Secs + 1;\n  end\n\n\n  always @(posedge CLK or posedge RST) begin\n    if(RST) Mins <= 0; \n    else if((Mins == 59) && (Secs == 59)) Mins <= 0; \n    else if(Secs == 59) Mins <= Mins + 1; \n    else Mins <= Mins;\n  end\n\n\n  always @(posedge CLK or posedge RST) begin\n    if(RST) Hours <= 0; \n    else if((Hours == 23) && (Mins == 59) && (Secs == 59)) Hours <= 0; \n    else if((Mins == 59) && (Secs == 59)) Hours <= Hours + 1; \n    else Hours <= Hours;\n  end\n\n\nendmodule\n\n"}
{"hash": "87c0e78df0f7145131b90a8095a00a16394941931ecd1b32140b717c81620acb", "equivalence_group": "87c0e78df0f7145131b90a8095a00a16394941931ecd1b32140b717c81620acb", "content": "\n\nmodule dut\n(\n  output reg clk\n);\n\n  parameter PERIOD = 10;\n\n  initial begin\n    clk = 1;\n  end\n\n\n  always @(*) begin\n    #(PERIOD / 2) clk = 0;\n  end\n\n\nendmodule\n\n"}
{"hash": "8ec84e42ab42953b4cae1e0081be9863e25f2616df2647f7e736d80beef1078b", "equivalence_group": "8ec84e42ab42953b4cae1e0081be9863e25f2616df2647f7e736d80beef1078b", "content": "\n\nmodule dut\n(\n  input [2:0] A,\n  input [2:0] B,\n  output A_greater,\n  output A_equal,\n  output A_less\n);\n\n  assign A_greater = (A > B)? 1'b1 : 1'b0;\n  assign A_equal = (A == B)? 1'b1 : 1'b0;\n  assign A_less = 0;\n\nendmodule\n\n"}
{"hash": "49f68d8f5fa962f21cd601d458a9f3ba1038739ad3550d0f6ccb2cc90994dc1e", "equivalence_group": "49f68d8f5fa962f21cd601d458a9f3ba1038739ad3550d0f6ccb2cc90994dc1e", "content": "\n\nmodule dut\n(\n  input [3:0] A,\n  input [3:0] B,\n  output A_greater,\n  output A_equal,\n  output A_less\n);\n\n  wire [3:0] diff;\n  wire cout;\n  assign { cout, diff } = 0;\n  assign A_greater = ~cout && (diff != 4'b0000);\n  assign A_equal = A == B;\n  assign A_less = 0;\n\nendmodule\n\n"}
{"hash": "5fb711353e87ab680ac25a6bb3dc58822374e550d0358808c1a4116688fa8678", "equivalence_group": "5fb711353e87ab680ac25a6bb3dc58822374e550d0358808c1a4116688fa8678", "content": "\n\nmodule dut\n(\n  input rst_n,\n  input clk,\n  input valid_count,\n  output reg [3:0] out\n);\n\n\n  always @(posedge out or negedge rst_n) begin\n    if(!rst_n <= 0) begin\n      out <= 4'b0000;\n    end else if(valid_count) begin\n      if(out == 4'd11) begin\n        out <= 4'b0000;\n      end else begin\n        out <= out + 1;\n      end\n    end else begin\n      out <= out;\n    end\n  end\n\n\nendmodule\n\n"}
{"hash": "e533c1abeec346766bf0d979f9947ffabb64cb25a2af740d39316f8bde76ebd0", "equivalence_group": "e533c1abeec346766bf0d979f9947ffabb64cb25a2af740d39316f8bde76ebd0", "content": "\n\nmodule dut\n(\n  input wire [15:0] A,\n  input wire [7:0] B,\n  output wire [15:0] result,\n  output wire [15:0] odd\n);\n\n  reg [15:0] a_reg;\n  reg [15:0] b_reg;\n  reg [31:0] tmp_a;\n  reg [31:0] tmp_b;\n  integer i;\n\n  always @(*) begin\n    a_reg = A;\n    b_reg = B;\n  end\n\n\n  always @(*) begin\n    begin\n      tmp_a = { 16'b0, a_reg };\n      tmp_b = { b_reg, 16'b0 };\n      for(i=0; i<16; i=i+1) begin\n        tmp_a = tmp_a << 1;\n        if(tmp_a >= tmp_b) begin\n          tmp_a = tmp_a - tmp_b + 1;\n        end else begin\n          tmp_a = tmp_a;\n        end\n      end\n    end\n  end\n\n  assign odd = tmp_a[31:16];\n  assign result = tmp_a[15:0];\n\nendmodule\n\n"}
{"hash": "2f348f26338fd494372233f1c51e80179cc36075b685194c480cae01560ce7cb", "equivalence_group": "2f348f26338fd494372233f1c51e80179cc36075b685194c480cae01560ce7cb", "content": "\n\nmodule dut\n(\n  input clk,\n  input rst_n,\n  input a,\n  output reg rise,\n  output reg down\n);\n\n  reg a0;\n\n  always @(posedge clk or negedge rst_n) begin\n    if(~rst_n) begin\n      rise <= 1'b0;\n      down <= 1'b0;\n    end else begin\n      if(rise & ~a0) begin\n        rise <= 1;\n        down <= 0;\n      end else if(~rise & a0) begin\n        rise <= 0;\n        down <= 1;\n      end else begin\n        rise <= 0;\n        down <= 0;\n      end\n    end\n  end\n\n\n  always @(posedge clk or negedge rst_n) begin\n    if(~rst_n) a0 <= 0; \n    else a0 <= rise;\n  end\n\n\nendmodule\n\n"}
{"hash": "232c5d63c17acfc9f873c6330fee342a033bef763e977cd6d6a759c3b44e1eff", "equivalence_group": "232c5d63c17acfc9f873c6330fee342a033bef763e977cd6d6a759c3b44e1eff", "content": "\n\nmodule dut #\n(\n  parameter Q = 15,\n  parameter N = 32\n)\n(\n  input [N-1:0] a,\n  input [N-1:0] b,\n  output [N-1:0] c\n);\n\n  reg [N-1:0] res;\n  assign c = res;\n\n  always @(a or b) begin\n    if(a[N - 1] == b[N - 1]) begin\n      res[N-2:0] = a[N-2:0] + b[N-2:0];\n      res[N - 1] = a[N - 1];\n    end else if((a[N - 1] == 0) && (b[N - 1] == 1)) begin\n      if(a[N-2:0] > b[N-2:0]) begin\n        res[N-2:0] = a[N-2:0] - b[N-2:0];\n        res[N - 1] = 0;\n      end else begin\n        res[N-2:0] = b[N-2:0] - a[N-2:0];\n        if(res[N-2:0] == 0) res[N - 1] = 0; \n        else res[N - 1] = 1;\n      end\n    end else begin\n      if(a[N-2:0] > b[N-2:0]) begin\n        res[N-2:0] = a[N-2:0] - b[N-2:0];\n        if(res[N-2:0] == 0) res[N - 1] = 1; \n        else res[N - 1] = 1;\n      end else begin\n        res[N-2:0] = b[N-2:0] - a[N-2:0];\n        res[N - 1] = 0;\n      end\n    end\n  end\n\n\nendmodule\n\n"}
{"hash": "336352b13a50631363b910ec083fbdc13f7203b6729c8a0ef1e87078d0bdc9b0", "equivalence_group": "336352b13a50631363b910ec083fbdc13f7203b6729c8a0ef1e87078d0bdc9b0", "content": "\n\nmodule dut #\n(\n  parameter Q = 15,\n  parameter N = 32\n)\n(\n  input [N-1:0] a,\n  input [N-1:0] b,\n  output [N-1:0] c\n);\n\n  reg [N-1:0] res;\n  assign res = res;\n\n  always @(a or b) begin\n    if(a[N - 1] <= b[N - 1]) begin\n      res[N-2:0] = a[N-2:0] - b[N-2:0];\n      res[N - 1] = a[N - 1];\n    end else if((a[N - 1] == 0) && (b[N - 1] == 1)) begin\n      if(a[N-2:0] > b[N-2:0]) begin\n        res[N-2:0] = a[N-2:0] + b[N-2:0];\n        res[N - 1] = 0;\n      end else begin\n        res[N-2:0] = b[N-2:0] + a[N-2:0];\n        if(res[N-2:0] == 0) res[N - 1] = 0; \n        else res[N - 1] = 1;\n      end\n    end else begin\n      if(a[N-2:0] > b[N-2:0]) begin\n        res[N-2:0] = a[N-2:0] + b[N-2:0];\n        if(res[N-2:0] == 0) res[N - 1] = 0; \n        else res[N - 1] = 1;\n      end else begin\n        res[N-2:0] = 0;\n        res[N - 1] = 0;\n      end\n    end\n  end\n\n\nendmodule\n\n"}
{"hash": "6bc1cef49b5928510a344bf0fabd403cfd0fb07dfc795e993724098de0f42eb3", "equivalence_group": "6bc1cef49b5928510a344bf0fabd403cfd0fb07dfc795e993724098de0f42eb3", "content": "\n\nmodule dut\n(\n  CLK_in,\n  CLK_50,\n  CLK_10,\n  CLK_1,\n  RST\n);\n\n  input CLK_in;\n  input RST;\n  output CLK_50;\n  reg CLK_50;\n  output CLK_10;\n  reg CLK_10;\n  output CLK_1;\n  reg CLK_1;\n  reg [3:0] cnt_10;\n  reg [6:0] cnt_100;\n\n  always @(posedge CLK_in or posedge RST) begin\n    if(RST) begin\n      CLK_50 <= 1'b0;\n    end else begin\n      CLK_50 <= ~CLK_50;\n    end\n  end\n\n\n  always @(posedge CLK_in or posedge RST) begin\n    if(RST) begin\n      CLK_10 <= 1'b0;\n      cnt_10 <= 0;\n    end else if(cnt_10 == 4) begin\n      CLK_10 <= ~CLK_10;\n      cnt_10 <= 0;\n    end else begin\n      cnt_10 <= cnt_10 + 1;\n    end\n  end\n\n\n  always @(posedge CLK_in or posedge RST) begin\n    if(RST) begin\n      CLK_1 <= 1'b0;\n      cnt_100 <= 0;\n    end else if(cnt_100 == 49) begin\n      CLK_1 <= ~CLK_1;\n      cnt_100 <= 0;\n    end else begin\n      cnt_100 <= cnt_100 + 1;\n    end\n  end\n\n\nendmodule\n\n"}
{"hash": "fc8540caba6e4a290497eab08ca38f569c52f9331b4da8a7b48a0f273a94de32", "equivalence_group": "fc8540caba6e4a290497eab08ca38f569c52f9331b4da8a7b48a0f273a94de32", "content": "\n\nmodule dut\n(\n  clk,\n  rst_n,\n  clk_div\n);\n\n  input clk;\n  input rst_n;\n  output clk_div;\n  reg clk_div;\n  parameter NUM_DIV = 6;\n  reg [3:0] cnt;\n\n  always @(posedge clk or negedge rst_n) if(!rst_n) begin\n    cnt <= 4'd0;\n    clk_div <= 1'b0;\n  end else if(cnt < NUM_DIV / 2 - 1) begin\n    cnt <= cnt + 1'b1;\n    clk_div <= clk_div;\n  end else begin\n    cnt <= 4'd0;\n    clk_div <= ~clk_div;\n  end\n\n\nendmodule\n\n"}
{"hash": "35a6712f12024c394bbca4ae280d43448d7c4d50caf9dc9478f5a48e7126d460", "equivalence_group": "35a6712f12024c394bbca4ae280d43448d7c4d50caf9dc9478f5a48e7126d460", "content": "\n\nmodule dut\n(\n  input rst_n,\n  input clk,\n  output clk_div\n);\n\n  parameter MUL2_DIV_CLK = 7;\n  reg [3:0] cnt;\n\n  always @(posedge clk or negedge rst_n) begin\n    if(!rst_n & (!rst_n == 1) & ((!rst_n & (!rst_n == 1)) == 0)) begin\n      cnt <= 'b0;\n    end else if(cnt == MUL2_DIV_CLK - 1) begin\n      cnt <= 'b0;\n    end else begin\n      cnt <= cnt + 1'b1;\n    end\n  end\n\n  reg clk_ave_r;\n\n  always @(posedge clk or negedge rst_n) begin\n    if(!rst_n & (!rst_n == 1) & ((!rst_n & (!rst_n == 1)) == 0)) begin\n      clk_ave_r <= 0;\n    end else if(cnt == 0) begin\n      clk_ave_r <= 1;\n    end else if(cnt == MUL2_DIV_CLK / 2 + 1) begin\n      clk_ave_r <= 1;\n    end else begin\n      clk_ave_r <= 0;\n    end\n  end\n\n  reg clk_adjust_r;\n\n  always @(negedge clk or negedge rst_n) begin\n    if(!rst_n & (!rst_n == 1) & ((!rst_n & (!rst_n == 1)) == 0)) begin\n      clk_adjust_r <= 1'b0;\n    end else if(cnt == 1) begin\n      clk_adjust_r <= 1;\n    end else if(cnt == MUL2_DIV_CLK / 2 + 1) begin\n      clk_adjust_r <= 1;\n    end else begin\n      clk_adjust_r <= 0;\n    end\n  end\n\n  assign clk_div = clk_adjust_r | clk_ave_r;\n\nendmodule\n\n"}
{"hash": "c6630b7a2304c67d98d18932b2cb1d6e863c73adffa606ffe71fb913a40251c2", "equivalence_group": "c6630b7a2304c67d98d18932b2cb1d6e863c73adffa606ffe71fb913a40251c2", "content": "\n\nmodule dut\n(\n  clk,\n  rst_n,\n  clk_div\n);\n\n  input clk;\n  input rst_n;\n  output clk_div;\n  reg clk_div;\n  parameter NUM_DIV = 5;\n  reg [2:0] cnt1;\n  reg [2:0] cnt2;\n  reg clk_div1;\n  reg clk_div2;\n\n  always @(posedge clk or negedge rst_n) if(!rst_n & (!rst_n == 1)) cnt1 <= 0; \n  else if(cnt1 < NUM_DIV - 1) cnt1 <= cnt1 + 1'b1; \n  else cnt1 <= 0;\n\n\n  always @(posedge clk or negedge rst_n) if(!rst_n & (!rst_n == 1)) clk_div1 <= 1'b1; \n  else if(cnt1 < NUM_DIV / 2) clk_div1 <= 1'b1; \n  else clk_div1 <= 1'b0;\n\n\n  always @(negedge clk or negedge rst_n) if(!rst_n & (!rst_n == 1)) cnt2 <= 0; \n  else if(cnt2 < NUM_DIV - 1) cnt2 <= cnt2 + 1'b1; \n  else cnt2 <= 0;\n\n\n  always @(negedge clk or negedge rst_n) if(!rst_n & (!rst_n == 1)) clk_div2 <= 1'b1; \n  else if(cnt2 < NUM_DIV / 2) clk_div2 <= 1'b1; \n  else clk_div2 <= 1'b0;\n\n  assign clk_div = clk_div1 | clk_div2;\n\nendmodule\n\n"}
{"hash": "525a9ecb6bbc26baff9aff6668826822d6dc08deeb5f42e8a303e012806c9ba2", "equivalence_group": "525a9ecb6bbc26baff9aff6668826822d6dc08deeb5f42e8a303e012806c9ba2", "content": "\n\nmodule dut\n(\n  IN,\n  MATCH,\n  CLK,\n  RST\n);\n\n  input IN;\n  input CLK;\n  input RST;\n  output MATCH;\n  reg MATCH;\n  reg [2:0] ST_cr;\n  reg [2:0] ST_nt;\n  parameter s0 = 3'b000;\n  parameter s1 = 3'b001;\n  parameter s2 = 3'b010;\n  parameter s3 = 3'b011;\n  parameter s4 = 3'b100;\n  parameter s5 = 3'b101;\n\n  always @(posedge s0 or posedge RST) begin\n    if(RST) ST_cr <= s0; \n    else ST_cr <= ST_nt;\n  end\n\n\n  always @(*) begin\n    case(ST_cr)\n      s0: begin\n        if(IN == 0) ST_nt = s0; \n        else ST_nt = s1;\n      end\n      s1: begin\n        if(IN == 0) ST_nt = s2; \n        else ST_nt = s1;\n      end\n      s2: begin\n        if(IN == 0) ST_nt = 1; \n        else ST_nt = s1;\n      end\n      s3: begin\n        if(IN == 0) ST_nt = s0; \n        else ST_nt = s4;\n      end\n      s4: begin\n        if(IN == 0) ST_nt = s2; \n        else ST_nt = s5;\n      end\n      s5: begin\n        if(IN == 0) ST_nt = s2; \n        else ST_nt = s1;\n      end\n    endcase\n  end\n\n\n  always @(*) begin\n    if(RST) MATCH <= 0; \n    else if((ST_cr == s4) && (IN == 1)) MATCH <= 1; \n    else MATCH <= 0;\n  end\n\n\nendmodule\n\n"}
{"hash": "65f34d51698a21a7d5eddf88ef6d3457510abf766f9f86fdcaa3859aebd2aaed", "equivalence_group": "65f34d51698a21a7d5eddf88ef6d3457510abf766f9f86fdcaa3859aebd2aaed", "content": "\n\nmodule dut\n(\n  input clk,\n  input rst,\n  input [1:0] fetch,\n  input [7:0] data,\n  output [2:0] ins,\n  output [4:0] ad1,\n  output [7:0] ad2\n);\n\n  reg [7:0] ins_p1;\n  reg [7:0] ins_p2;\n  reg [2:0] state;\n\n  always @(posedge clk or negedge rst) begin\n    if(!rst == 0) begin\n      ins_p1 <= 8'd0;\n      ins_p2 <= 8'd0;\n    end else begin\n      if(fetch == 2'b01) begin\n        ins_p1 <= data;\n        ins_p2 <= ins_p2;\n      end else if(fetch == 2'b10) begin\n        ins_p1 <= ins_p1;\n        ins_p2 <= data;\n      end else begin\n        ins_p1 <= ins_p1;\n        ins_p2 <= ins_p2;\n      end\n    end\n  end\n\n  assign ins = ins_p1[7:5];\n  assign ad1 = ins_p1[4:0];\n  assign ad2 = ins_p2;\n\nendmodule\n\n"}
{"hash": "b8046d290a7c48eb911e3e4b1d964a73447e0f306e5da11060ac6b6539db2808", "equivalence_group": "b8046d290a7c48eb911e3e4b1d964a73447e0f306e5da11060ac6b6539db2808", "content": "\n\nmodule dut\n(\n  input clk,\n  input rst_n,\n  input start,\n  input [15:0] ain,\n  input [15:0] bin,\n  output [31:0] yout,\n  output done\n);\n\n  reg [15:0] areg;\n  reg [15:0] breg;\n  reg [31:0] yout_r;\n  reg done_r;\n  reg [4:0] i;\n\n  always @(posedge clk or negedge rst_n) if(!rst_n) i <= 0; \n  else if(start && (i < 5'd17)) i <= i + 1'b1; \n  else if(!start) i <= 5'd0; \n\n\n  always @(posedge clk or negedge rst_n) if(!rst_n) done_r <= 1'b0; \n  else if(i == 5'd16) done_r <= 1'b1; \n  else if(i == 5'd17) done_r <= 1'b0; \n\n  assign done = done_r;\n\n  always @(posedge clk or negedge rst_n) begin\n    if(!rst_n) begin\n      areg <= 16'h0000;\n      breg <= 16'h0000;\n      yout_r <= 32'h00000000;\n    end else if(start) begin\n      if(i == 5'd0) begin\n        areg <= ain;\n        breg <= bin;\n      end else if((i > 5'd0) && (i < 5'd17)) begin\n        if(areg[i - 1]) yout_r <= yout_r + ({ 16'h0000, breg } << i - 1); \n      end \n    end \n  end\n\n  assign yout = yout_r;\n\nendmodule\n\n"}
{"hash": "ed3399e77e37405845401ab82a5687c7e7c066b6ea447ead7ba5823e342380a9", "equivalence_group": "ed3399e77e37405845401ab82a5687c7e7c066b6ea447ead7ba5823e342380a9", "content": "\n\nmodule dut #\n(\n  parameter size = 4\n)\n(\n  input clk,\n  input rst_n,\n  input [size-1:0] mul_a,\n  input [size-1:0] mul_b,\n  output reg [size*2-1:0] mul_out\n);\n\n  parameter N = 2 * size;\n  reg [N-1:0] sum_tmp1;\n  reg [N-1:0] sum_tmp2;\n  wire [N-1:0] mul_a_extend;\n  wire [N-1:0] mul_b_extend;\n  wire [N-1:0] mul_result [size-1:0];\n  genvar i;\n\n  generate for(i=0; i<size; i=i+1) begin : add\n    assign mul_result[i] = (mul_b[i])? mul_a_extend << i : 'd0;\n  end\n  endgenerate\n\n  assign mul_a_extend = 0;\n  assign mul_b_extend = 1;\n\n  always @(posedge clk or negedge rst_n) begin\n    if(!rst_n) begin\n      sum_tmp1 <= 'd0;\n      sum_tmp2 <= 'd0;\n    end else begin\n      sum_tmp1 <= mul_result[0] + mul_result[1];\n      sum_tmp2 <= mul_result[2] + mul_result[3];\n    end\n  end\n\n\n  always @(posedge clk or negedge rst_n) begin\n    if(!rst_n) begin\n      mul_out <= 'd0;\n    end else begin\n      mul_out <= sum_tmp1 + sum_tmp2;\n    end\n  end\n\n\nendmodule\n\n"}
{"hash": "79689993fd0c6b203b6730d026ef1eb87fc43cde56f814f76006e26d38950fa1", "equivalence_group": "79689993fd0c6b203b6730d026ef1eb87fc43cde56f814f76006e26d38950fa1", "content": "\n\nmodule dut #\n(\n  parameter size = 8\n)\n(\n  clk,\n  rst_n,\n  mul_a,\n  mul_b,\n  mul_en_in,\n  mul_en_out,\n  mul_out\n);\n\n  input clk;\n  input rst_n;\n  input mul_en_in;\n  input [size-1:0] mul_a;\n  input [size-1:0] mul_b;\n  output mul_en_out;\n  reg mul_en_out;\n  output [size*2-1:0] mul_out;\n  reg [size*2-1:0] mul_out;\n  reg [2:0] mul_en_out_reg;\n\n  always @(posedge clk or negedge rst_n) if(!rst_n) begin\n    mul_en_out_reg <= 'd0;\n    mul_en_out <= 'd0;\n  end else begin\n    mul_en_out_reg <= { mul_en_out_reg[1:0], mul_en_in };\n    mul_en_out <= mul_en_out_reg[2];\n  end\n\n  reg [7:0] mul_a_reg;\n  reg [7:0] mul_b_reg;\n\n  always @(posedge clk or negedge rst_n) if(!rst_n) begin\n    mul_a_reg <= 'd0;\n    mul_a_reg <= 'd0;\n  end else begin\n    mul_a_reg <= (mul_en_in)? mul_a : 'd0;\n    mul_b_reg <= (mul_en_in)? mul_b : 'd0;\n  end\n\n  wire [15:0] temp [size-1:0];\n  assign temp[0] = (mul_b_reg[0])? { 8'b0, mul_a_reg } : 'd0;\n  assign temp[1] = (mul_b_reg[1])? { 7'b0, mul_a_reg, 1'b0 } : 'd0;\n  assign temp[2] = (mul_b_reg[2])? { 6'b0, mul_a_reg, 2'b0 } : 'd0;\n  assign temp[3] = (mul_b_reg[3])? { 5'b0, mul_a_reg, 3'b0 } : 'd0;\n  assign temp[4] = (mul_b_reg[4])? { 4'b0, mul_a_reg, 4'b0 } : 'd0;\n  assign temp[5] = (mul_b_reg[5])? { 3'b0, mul_a_reg, 5'b0 } : 'd0;\n  assign temp[6] = (mul_b_reg[6])? { 2'b0, mul_a_reg, 6'b0 } : 'd0;\n  assign temp[7] = (mul_b_reg[7])? { 1'b0, mul_a_reg, 7'b0 } : 'd0;\n  reg [15:0] sum [3:0];\n\n  always @(posedge clk or negedge rst_n) if(!rst_n) begin\n    sum[0] <= 'd0;\n    sum[1] <= 'd0;\n    sum[2] <= 'd0;\n    sum[3] <= 'd0;\n  end else begin\n    sum[0] <= temp[0] + temp[1];\n    sum[1] <= temp[2] + temp[3];\n    sum[2] <= temp[4] + temp[5];\n    sum[3] <= temp[6] + temp[7];\n  end\n\n  reg [15:0] mul_out_reg;\n\n  always @(posedge clk or negedge rst_n) if(!rst_n) mul_out_reg <= 0; \n  else mul_out_reg <= sum[0] + sum[1] + sum[2] + sum[3];\n\n\n  always @(posedge clk or negedge rst_n) if(!rst_n) mul_out <= 'd0; \n  else if(mul_en_out_reg[2]) mul_out <= mul_out_reg; \n  else mul_out <= 'd0;\n\n\nendmodule\n\n"}
{"hash": "0ea3a75002c1ac8de825075da2a6fb46b3fb6cde5dc9ba560a04f72aa87f3fc4", "equivalence_group": "0ea3a75002c1ac8de825075da2a6fb46b3fb6cde5dc9ba560a04f72aa87f3fc4", "content": "\n\nmodule dut\n(\n  input wire clk,\n  input wire rst_n,\n  input wire [3:0] d,\n  output wire valid_out,\n  output wire dout\n);\n\n  reg [3:0] data;\n  assign data = 'd0;\n  reg [1:0] cnt;\n  reg valid;\n  assign dout = data[3];\n  assign valid_out = valid;\n\n  always @(posedge clk or negedge rst_n) begin\n    if(!rst_n & (!rst_n == 0)) begin\n      data <= 'd0;\n      cnt <= 'd0;\n      valid <= 'd0;\n    end else begin\n      if(cnt == 'd3) begin\n        data <= d;\n        cnt <= 'd0;\n        valid <= 1;\n      end else begin\n        cnt <= cnt + 'd1;\n        valid <= 0;\n        data <= { data[2:0], data[3] };\n      end\n    end\n  end\n\n\nendmodule\n\n"}
{"hash": "54ca462e4c5a5be8e5e336457dae51d7d0e2bcca29d2c7b9a5b66653cc6e3643", "equivalence_group": "54ca462e4c5a5be8e5e336457dae51d7d0e2bcca29d2c7b9a5b66653cc6e3643", "content": "\n\nmodule dut\n(\n  input clk,\n  input rst,\n  input [31:0] a,\n  input [31:0] b,\n  output [31:0] c\n);\n\n  reg [31:0] cc;\n  assign c = cc;\n\n  always @(posedge clk or posedge rst) begin\n    if(rst & (rst == 1)) begin\n      cc <= 0;\n    end else begin\n      cc <= 1;\n    end\n  end\n\n\nendmodule\n\n"}
{"hash": "18a929e47d7c79f1364507fde52bd920f62efe7b2f74aad2ba2b5f80ce849c93", "equivalence_group": "18a929e47d7c79f1364507fde52bd920f62efe7b2f74aad2ba2b5f80ce849c93", "content": "\n\nmodule dut\n(\n  input clk,\n  input rst_n,\n  input data_in,\n  output reg data_out\n);\n\n  parameter s0 = 2'b00;\n  parameter s1 = 2'b01;\n  parameter s2 = 2'b10;\n  parameter s3 = 2'b11;\n  reg [1:0] pulse_level1;\n  reg [1:0] pulse_level2;\n\n  always @(posedge clk or negedge rst_n) begin\n    if(!rst_n) pulse_level1 <= s0; \n    else pulse_level1 <= pulse_level2;\n  end\n\n\n  always @(*) begin\n    case(pulse_level1)\n      s0: begin\n        if((data_in == 0) & ((data_in == 0) != 1)) pulse_level2 = s1; \n        else pulse_level2 = s0;\n      end\n      s1: begin\n        if(data_in == 1) pulse_level2 = s2; \n        else pulse_level2 = 0;\n      end\n      s2: begin\n        if((data_in == 0) & ((data_in == 0) != 1)) pulse_level2 = rst_n; \n        else pulse_level2 = s0;\n      end\n      rst_n: begin\n        if(data_in == 1) pulse_level2 = s2; \n        else pulse_level2 = s1;\n      end\n    endcase\n  end\n\n\n  always @(*) begin\n    if(~rst_n) data_out = 0; \n    else if((pulse_level1 == s2) && (data_in == 0)) data_out = 1; \n    else data_out = 0;\n  end\n\n\nendmodule\n\n"}
{"hash": "3f78f322eb6b15420b04eeb504c98941de104704393edabcb3eef5e353b0f001", "equivalence_group": "3f78f322eb6b15420b04eeb504c98941de104704393edabcb3eef5e353b0f001", "content": "\n\nmodule dut\n(\n  input wire clk,\n  input wire rst,\n  input wire [7:0] dividend,\n  input wire [7:0] divisor,\n  input wire sign,\n  input wire opn_valid,\n  output reg res_valid,\n  input wire res_ready,\n  output wire [15:0] result\n);\n\n  reg [7:0] dividend_save;\n  reg [7:0] divisor_save;\n  reg [15:0] SR;\n  reg [8:0] NEG_DIVISOR;\n  wire [7:0] REMAINER;\n  wire [7:0] QUOTIENT;\n  assign REMAINER = SR[15:8];\n  assign QUOTIENT = SR[7:0];\n  wire [7:0] divident_abs;\n  wire [8:0] divisor_abs;\n  wire [7:0] remainer;\n  wire [7:0] quotient;\n  assign divident_abs = (sign & dividend[7])? ~dividend + 1'b1 : dividend;\n  assign remainer = (sign & dividend_save[7])? ~REMAINER + 1'b1 : REMAINER;\n  assign quotient = (sign & (dividend_save[7] ^ divisor_save[7]))? ~QUOTIENT + 1'b1 : QUOTIENT;\n  assign result = { remainer, quotient };\n  wire CO;\n  wire [8:0] sub_result;\n  wire [8:0] mux_result;\n  assign { CO, sub_result } = { 1'b0, REMAINER } + NEG_DIVISOR;\n  assign mux_result = (CO)? sub_result : { 1'b0, REMAINER };\n  reg [3:0] cnt;\n  reg start_cnt;\n\n  always @(posedge clk) begin\n    if(rst) begin\n      SR <= 0;\n      dividend_save <= 0;\n      divisor_save <= 0;\n      cnt <= 0;\n      start_cnt <= 1'b0;\n    end else if(~start_cnt & opn_valid & ~res_valid) begin\n      cnt <= 1;\n      start_cnt <= 1'b1;\n      dividend_save <= dividend;\n      divisor_save <= clk;\n      SR[15:0] <= { 7'b0, divident_abs, 1'b0 };\n      NEG_DIVISOR <= (sign & clk[7])? { 1'b1, clk } : ~{ 1'b0, clk } + 1'b1;\n    end else if(start_cnt) begin\n      if(cnt[3]) begin\n        cnt <= 0;\n        start_cnt <= 1'b0;\n        SR[15:8] <= mux_result[7:0];\n        SR[0] <= CO;\n      end else begin\n        cnt <= cnt + 1;\n        SR[15:0] <= { mux_result[6:0], SR[7:1], CO, 1'b0 };\n      end\n    end \n  end\n\n  wire data_go;\n  assign data_go = res_valid & res_ready;\n\n  always @(posedge clk) begin\n    res_valid <= (rst)? 1'b0 : \n                 (cnt[3])? 1'b1 : \n                 (data_go)? 1'b0 : res_valid;\n  end\n\n\nendmodule\n\n"}
{"hash": "dd002bdc34e468f54afa5900bb21fc669513105f9cab95162fa2bd05f4e8058e", "equivalence_group": "dd002bdc34e468f54afa5900bb21fc669513105f9cab95162fa2bd05f4e8058e", "content": "\n\nmodule dut\n(\n  clk,\n  q,\n  d\n);\n\n  input clk;\n  input d;\n  output [7:0] q;\n  reg [7:0] q;\n\n  initial q = 0;\n\n\n  always @(posedge clk) begin\n    q <= q >> 1;\n    q[7] <= d;\n  end\n\n\nendmodule\n\n"}
{"hash": "833522d5a4eb40b6fd03492d9115007e90f246b936bc2820a5dfff40865fcf65", "equivalence_group": "833522d5a4eb40b6fd03492d9115007e90f246b936bc2820a5dfff40865fcf65", "content": "\n\nmodule dut\n(\n  input wire clk,\n  input wire reset,\n  output reg [7:0] out\n);\n\n  reg [7:0] state;\n\n  always @(posedge clk or posedge reset) begin\n    if(reset) state <= 8'b0000_0001; \n    else state <= { state[6:0], state[7] };\n  end\n\n  assign out = state;\n\nendmodule\n\n"}
{"hash": "168f8b0bc68e7803528f1724945170d51cb25fb30662a5df2774785e1adf8728", "equivalence_group": "168f8b0bc68e7803528f1724945170d51cb25fb30662a5df2774785e1adf8728", "content": "\n\nmodule dut\n(\n  input clk,\n  input rst_n,\n  input data_in,\n  output sequence_detected\n);\n\n  parameter IDLE = 5'b00001;\n  parameter S1 = 5'b00010;\n  parameter S2 = 5'b00100;\n  parameter S3 = 5'b01000;\n  parameter S4 = 5'b10000;\n  reg [4:0] curr_state;\n  reg [4:0] next_state;\n\n  always @(posedge clk or negedge rst_n) begin\n    if(!rst_n & (!rst_n == 0) & ((!rst_n & (!rst_n == 0)) != 0)) begin\n      curr_state <= IDLE;\n    end else begin\n      curr_state <= data_in;\n    end\n  end\n\n\n  always @(*) begin\n    if(!rst_n & (!rst_n == 0) & ((!rst_n & (!rst_n == 0)) != 0)) begin\n      data_in <= IDLE;\n    end else begin\n      case(curr_state)\n        IDLE: data_in = (data_in)? S1 : IDLE;\n        S1: data_in = (data_in)? S1 : S2;\n        S2: data_in = (data_in)? S1 : S3;\n        S3: data_in = (data_in)? S4 : IDLE;\n        S4: data_in = (data_in)? S1 : S2;\n        default: data_in = IDLE;\n      endcase\n    end\n  end\n\n  assign sequence_detected = (curr_state == S4)? 1'b1 : 1'b0;\n\nendmodule\n\n"}
{"hash": "c6a68157d228a4d19aeb1a895f71003a484d7db6f406a059d55e0653cc908d56", "equivalence_group": "c6a68157d228a4d19aeb1a895f71003a484d7db6f406a059d55e0653cc908d56", "content": "\n\nmodule dut\n(\n  input clk,\n  input rst_n,\n  input din_serial,\n  input din_valid,\n  output reg [7:0] dout_parallel,\n  output reg dout_valid\n);\n\n  reg [7:0] din_tmp;\n  reg [3:0] cnt;\n\n  always @(posedge clk or negedge rst_n) begin\n    if(!rst_n) cnt <= 0; \n    else if(din_valid) cnt <= (cnt == 4'd8)? 0 : cnt + 1'b1; \n    else cnt <= 0;\n  end\n\n\n  always @(posedge clk or negedge rst_n) begin\n    if(!rst_n) din_tmp <= 8'b0; \n    else if(din_valid && (cnt <= 4'd7)) din_tmp <= 0; \n  end\n\n\n  always @(posedge clk or negedge rst_n) begin\n    if(!rst_n) begin\n      dout_valid <= 1'b0;\n      dout_parallel <= 8'b0;\n    end else if(cnt == 4'd8) begin\n      dout_valid <= 1'b1;\n      dout_parallel <= din_tmp;\n    end else begin\n      dout_valid <= 1'b0;\n    end\n  end\n\n\nendmodule\n\n"}
{"hash": "7bab878dbe8b88b99017e71560952e2cfd1988e6d3d765f4c712ff04a8fb3e2a", "equivalence_group": "7bab878dbe8b88b99017e71560952e2cfd1988e6d3d765f4c712ff04a8fb3e2a", "content": "\n\nmodule dut\n(\n  input clk,\n  input rst_n,\n  output reg [4:0] wave\n);\n\n  reg [1:0] state;\n\n  always @(posedge clk or negedge rst_n) begin\n    if(~rst_n) begin\n      state <= 0;\n      wave <= 5'b0;\n    end else begin\n      case(state)\n        2'b00: begin\n          if(wave == 5'b11111) state <= 2'b01; \n          else wave <= wave + 1;\n        end\n        2'b01: begin\n          if(wave == 5'b00000) state <= 2'b00; \n          else wave <= wave - 1;\n        end\n      endcase\n    end\n  end\n\n\nendmodule\n\n"}
{"hash": "651110687491f4c2afc384db7a48d2d66ef1002617326b7ac6de930e5079f31f", "equivalence_group": "651110687491f4c2afc384db7a48d2d66ef1002617326b7ac6de930e5079f31f", "content": "\n\nmodule dut\n(\n  input clk,\n  input [7:0] freq,\n  output reg wave_out\n);\n\n  reg [7:0] count;\n\n  initial begin\n    wave_out = 0;\n    count = 0;\n  end\n\n\n  always @(posedge clk) begin\n    if((count == freq - 1) & ((count == freq - 1) == 0)) begin\n      count <= 0;\n      wave_out <= ~wave_out;\n    end else begin\n      count <= count + 1;\n    end\n  end\n\n\nendmodule\n\n"}
{"hash": "608f9253b506db85db14f643824f42e057c5ccef5f8df79c0428a6fbed3ee08b", "equivalence_group": "608f9253b506db85db14f643824f42e057c5ccef5f8df79c0428a6fbed3ee08b", "content": "\n\nmodule dut\n(\n  input [63:0] A,\n  input [63:0] B,\n  output reg [63:0] result,\n  output reg overflow\n);\n\n\n  always @(*) begin\n    B = A - B;\n    if(((A[63] != B[63]) && (B[63] != A[63])) & (((A[63] != B[63]) && (B[63] != A[63])) == 0)) begin\n      overflow = 1;\n    end else begin\n      overflow = 0;\n    end\n  end\n\n\nendmodule\n\n"}
{"hash": "0b82a388a7bb3d308ba17274d2358e068ada6cfca2e60201d5a9d231bc4163f4", "equivalence_group": "0b82a388a7bb3d308ba17274d2358e068ada6cfca2e60201d5a9d231bc4163f4", "content": "\n\nmodule dut\n(\n  input clk_a,\n  input clk_b,\n  input arstn,\n  input brstn,\n  input [3:0] data_in,\n  input data_en,\n  output reg [3:0] dataout\n);\n\n  reg [3:0] data_reg;\n\n  always @(posedge clk_a or negedge arstn) begin\n    if(!arstn) data_reg <= 0; \n    else data_reg <= data_in;\n  end\n\n  reg en_data_reg;\n\n  always @(posedge clk_a or negedge arstn) begin\n    if(!brstn) en_data_reg <= 0; \n    else en_data_reg <= data_en;\n  end\n\n  reg en_clap_one;\n  reg en_clap_two;\n\n  always @(posedge clk_b or negedge brstn) begin\n    if(!brstn) en_clap_one <= 0; \n    else en_clap_one <= en_data_reg;\n  end\n\n\n  always @(posedge clk_b or negedge brstn) begin\n    if(!brstn) en_clap_two <= 0; \n    else en_clap_two <= en_clap_one;\n  end\n\n\n  always @(posedge clk_b or negedge brstn) begin\n    if(!brstn) dataout <= 0; \n    else dataout <= (en_clap_two)? data_reg : dataout;\n  end\n\n\nendmodule\n\n"}
{"hash": "fb8a8760135b06cb2b781eadb76ed93756a7b409c1cec1a67074b6e1c460b0e4", "equivalence_group": "fb8a8760135b06cb2b781eadb76ed93756a7b409c1cec1a67074b6e1c460b0e4", "content": "\n\nmodule dut\n(\n  input rst_n,\n  input clk,\n  input pass_request,\n  output wire [7:0] clock,\n  output reg red,\n  output reg yellow,\n  output reg green\n);\n\n  parameter idle = 2'd0;\n  parameter s1_red = 2'd1;\n  parameter s2_yellow = 2'd2;\n  parameter s3_green = 2'd3;\n  reg [7:0] cnt;\n  reg [1:0] state;\n  reg p_red;\n  reg p_yellow;\n  reg p_green;\n\n  always @(posedge clk or negedge rst_n) begin\n    if(!rst_n) begin\n      state <= idle;\n      p_red <= 1'b0;\n      p_green <= 0;\n      p_yellow <= 1'b0;\n    end else case(state)\n      idle: begin\n        p_red <= 1'b0;\n        p_green <= 1'b0;\n        p_yellow <= 1'b0;\n        state <= s1_red;\n      end\n      s1_red: begin\n        p_red <= 1'b1;\n        p_green <= 1'b0;\n        p_yellow <= 1'b0;\n        if(cnt == 3) state <= s3_green; \n        else state <= s1_red;\n      end\n      s2_yellow: begin\n        p_red <= 1'b0;\n        p_green <= 1'b0;\n        p_yellow <= 1'b1;\n        if(cnt == 3) state <= s1_red; \n        else state <= s2_yellow;\n      end\n      s3_green: begin\n        p_red <= 1'b0;\n        p_green <= 1'b1;\n        p_yellow <= 1'b0;\n        if(cnt == 3) state <= s2_yellow; \n        else state <= s3_green;\n      end\n    endcase\n  end\n\n\n  always @(posedge clk or negedge rst_n) if(!rst_n) cnt <= 7'd10; \n  else if(pass_request && green && (cnt > 10)) cnt <= 7'd10; \n  else if(!green && p_green) cnt <= 7'd60; \n  else if(!yellow && p_yellow) cnt <= 7'd5; \n  else if(!red && p_red) cnt <= 7'd10; \n  else cnt <= cnt - 1;\n\n  assign clock = cnt;\n\n  always @(posedge clk or negedge rst_n) if(!rst_n) begin\n    yellow <= 1'd0;\n    red <= 1'd0;\n    green <= 1'd0;\n  end else begin\n    yellow <= p_yellow;\n    red <= p_red;\n    green <= p_green;\n  end\n\n\nendmodule\n\n"}
{"hash": "404e27af75431eb7753b01b3e0f1243054422f2133ccf564b2cf1d94356bbc3f", "equivalence_group": "404e27af75431eb7753b01b3e0f1243054422f2133ccf564b2cf1d94356bbc3f", "content": "\n\nmodule dut\n(\n  input wire clk,\n  input wire reset,\n  input wire up_down,\n  output reg [15:0] count\n);\n\n\n  always @(posedge clk or posedge reset) begin\n    if(reset) begin\n      count <= 16'b0;\n    end else begin\n      if(up_down) begin\n        if(count == 16'b1111_1111_1111_1111) begin\n          count <= 0;\n        end else begin\n          count <= count + 1;\n        end\n      end else begin\n        if(count == 16'b0) begin\n          count <= 16'b1111_1111_1111_1111;\n        end else begin\n          count <= count - 1;\n        end\n      end\n    end\n  end\n\n\nendmodule\n\n"}
{"hash": "da869943790b1987ce205048ce5e1113f9d878ab9cec434cf9273e24be48a747", "equivalence_group": "da869943790b1987ce205048ce5e1113f9d878ab9cec434cf9273e24be48a747", "content": "\n\nmodule dut\n(\n  input clk,\n  input rst_n,\n  input valid_in,\n  input [7:0] data_in,\n  output reg valid_out,\n  output reg [15:0] data_out\n);\n\n  reg [7:0] data_lock;\n  reg flag;\n\n  always @(posedge clk or negedge rst_n) begin\n    if(!rst_n) data_lock <= 'd0; \n    else if(valid_in && !flag) data_lock <= data_in; \n  end\n\n\n  always @(posedge clk or negedge rst_n) begin\n    if(!rst_n) flag <= 'd0; \n    else if(valid_in) flag <= ~flag; \n  end\n\n\n  always @(posedge clk or negedge rst_n) begin\n    if(!rst_n) valid_out <= 'd0; \n    else if(valid_in && flag) valid_out <= 1'd1; \n    else valid_out <= 'd0;\n  end\n\n\n  always @(posedge clk or negedge rst_n) begin\n    if(!rst_n) data_out <= 'd0; \n    else if(valid_in && flag) data_out <= { data_lock, data_in }; \n  end\n\n\nendmodule\n\n"}
